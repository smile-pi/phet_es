{"version":3,"file":"resistance-in-a-wire.min.js","sources":["../node_modules/grunt-requirejs/node_modules/almond/almond.js","../../joist/js/joistImageLoader.js","../../joist/js/SimLauncher.js","../../assert/js/assert.js","../../scenery/js/scenery.js","../../dot/js/dot.js","../../phet-core/js/extend.js","../../phet-core/js/inherit.js","../../dot/js/Util.js","../../dot/js/Vector2.js","../../dot/js/Vector4.js","../../dot/js/Vector3.js","../../dot/js/Matrix4.js","../../dot/js/Matrix3.js","../../dot/js/Ray2.js","../../dot/js/Transform3.js","../../dot/js/Bounds2.js","../../scenery/js/util/Util.js","../../kite/js/kite.js","../../kite/js/segments/Segment.js","../../kite/js/segments/Line.js","../../kite/js/segments/Arc.js","../../kite/js/util/Subpath.js","../../kite/js/../parser/svgPath.js","../../kite/js/util/LineStyles.js","../../kite/js/segments/Quadratic.js","../../kite/js/segments/Cubic.js","../../kite/js/segments/EllipticalArc.js","../../kite/js/Shape.js","../../scenery/js/util/FixedNodeEvents.js","../../scenery/js/layers/LayerStrategy.js","../../scenery/js/nodes/Node.js","../../scenery/js/layers/LayerType.js","../../scenery/js/util/Trail.js","../../scenery/js/layers/Layer.js","../../scenery/js/util/CanvasContextWrapper.js","../../scenery/js/util/TrailPointer.js","../../scenery/js/layers/CanvasLayer.js","../../scenery/js/layers/DOMLayer.js","../../scenery/js/layers/SVGLayer.js","../../scenery/js/layers/Renderer.js","../../scenery/js/nodes/Fillable.js","../../scenery/js/nodes/Strokable.js","../../scenery/js/nodes/Path.js","../../scenery/js/nodes/HBox.js","../../scenery/js/nodes/VBox.js","../../phet-core/js/escapeHTML.js","../../scenery/js/util/Font.js","../../scenery/js/nodes/Text.js","../../scenery/js/nodes/Image.js","../../scenery/js/nodes/DOM.js","../../phet-core/js/collect.js","../../scenery/js/util/AccessibilityPeer.js","../../scenery/js/util/LiveRegion.js","../../scenery/js/util/Instance.js","../../scenery/js/util/RenderInterval.js","../../scenery/js/input/Pointer.js","../../scenery/js/input/Mouse.js","../../scenery/js/input/Touch.js","../../scenery/js/input/Pen.js","../../scenery/js/input/Key.js","../../scenery/js/input/Event.js","../../scenery/js/input/Input.js","../../scenery/js/layers/LayerBoundary.js","../../scenery/js/layers/LayerBuilder.js","../../scenery/js/Scene.js","../../scenery/js/nodes/Rectangle.js","../../scenery/js/input/SimpleDragHandler.js","../../sun/js/FontAwesomeNode.js","../../sun/js/Panel.js","../../scenery-phet/js/HomeButton.js","../../scenery-phet/js/MultiLineText.js","../../kite/js/shape.js","../../joist/js/ScreenView.js","../../scenery/js/nodes/HTMLText.js","../../scenery-phet/js/PhetFont.js","../../joist/js/AboutDialog.js","../../scenery/js/input/DownUpListener.js","../../scenery/js/input/ButtonListener.js","../../scenery/js/nodes/Plane.js","../../axon/js/axon.js","../../axon/js/log.js","../../joist/js/PhetMenu.js","../../scenery/js/util/Color.js","../../scenery/js/util/Gradient.js","../../scenery/js/util/LinearGradient.js","../../phet-core/js/platform.js","../../joist/js/PhetButton.js","../../joist/js/Highlight.js","../../joist/js/NavigationBar.js","../../joist/js/Frame.js","../../axon/js/Property.js","../../joist/js/FullScreenButton.js","../../joist/js/HomeScreen.js","../js/version.js","../../axon/js/DerivedProperty.js","../../axon/js/PropertySet.js","../../joist/js/share/Pointer.js","../../joist/js/share/Pointers.js","../../joist/js/share/LogPointers.js","../../joist/js/Sim.js","../lib/i18n-2.0.2.js","../js/../nls/resistance-in-a-wire-strings.js","../js/resistance-in-a-wire-strings.js","../js/model/ResistanceInAWireModel.js","../js/imageLoader.js","../../sun/js/PushButton.js","../js/view/ResetAllButton.js","../../scenery-phet/js/ArrowShape.js","../../scenery-phet/js/ArrowNode.js","../js/view/shape-views/slider-box-view/WhiteBox.js","../../dot/js/LinearFunction.js","../js/view/shape-views/slider-box-view/Slider.js","../js/view/shape-views/slider-box-view/CurrentResistanceView.js","../js/view/shape-views/SlidersBox.js","../js/view/shape-views/FormulaView.js","../../scenery/js/nodes/Circle.js","../js/view/shape-views/ResistorView.js","../js/view/ResistanceInAWireStageContainer.js","../js/view/ResistanceInAWireView.js","../js/resistance-in-a-wire-main.js","../js/resistance-in-a-wire-config.js"],"names":[],"mappings":"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AAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,GACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,OAAA,IACA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,MAAA,KAAA,M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AA,SACA,WAAA,SACA,MAAA,SACA,UAAA,SACA,UAAA,SACA,WAAA,SACA,UAAA,SACA,MAAA,SACA,eAAA,SACA,SAAA,SACA,QAAA,SACA,KAAA,SACA,SAAA,SACA,SAAA,SACA,cAAA,SACA,SAAA,SACA,UAAA,SACA,UAAA,SACA,YAAA,SACA,eAAA,SACA,WAAA,SACA,WAAA,SACA,QAAA,SACA,WAAA,SACA,aAAA,SACA,cAAA,SACA,cAAA,SACA,cAAA,SACA,WAAA,SACA,SAAA,SACA,YAAA,SACA,QAAA,SACA,WAAA,SACA,SAAA,SACA,UAAA,SACA,YAAA,SACA,YAAA,SACA,QAAA,SACA,UAAA,SACA,WAAA,SACA,KAAA,SACA,UAAA,SACA,KAAA,SACA,MAAA,SACA,YAAA,SACA,SAAA,SACA,QAAA,SACA,UAAA,SACA,OAAA,SACA,MAAA,SACA,MAAA,SACA,SAAA,SACA,cAAA,SACA,UAAA,SACA,aAAA,SACA,UAAA,SACA,WAAA,SACA,UAAA,SACA,qBAAA,SACA,UAAA,SACA,WAAA,SACA,UAAA,SACA,YAAA,SACA,cAAA,SACA,aAAA,SACA,eAAA,SACA,eAAA,SACA,eAAA,SACA,YAAA,SACA,KAAA,SACA,UAAA,SACA,MAAA,SACA,QAAA,SACA,OAAA,SACA,iBAAA,SACA,WAAA,SACA,aAAA,SACA,aAAA,SACA,eAAA,SACA,gBAAA,SACA,kBAAA,SACA,gBAAA,SACA,gBAAA,SACA,aAAA,SACA,UAAA,SACA,UAAA,SACA,SAAA,SACA,YAAA,SACA,KAAA,SACA,QAAA,SACA,MAAA,SACA,UAAA,SACA,OAAA,SACA,UAAA,SACA,OAAA,SACA,cAAA,SACA,UAAA,SACA,cAAA,SACA,cAAA,SACA,WAAA,SACA,UAAA,SACA,KAAA,SACA,KAAA,SACA,KAAA,SACA,WAAA,SACA,OAAA,SACA,IAAA,SACA,UAAA,SACA,UAAA,SACA,YAAA,SACA,OAAA,SACA,WAAA,SACA,SAAA,SACA,SAAA,SACA,OAAA,SACA,OAAA,SACA,QAAA,SACA,UAAA,SACA,UAAA,SACA,KAAA,S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","sourcesContent":["\n/**\n * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.\n * Available via the MIT or new BSD license.\n * see: http://github.com/jrburke/almond for details\n */\n//Going sloppy to avoid 'use strict' string cost, but strict practices should\n//be followed.\n/*jslint sloppy: true */\n/*global setTimeout: false */\n\nvar requirejs, require, define;\n(function (undef) {\n    var main, req, makeMap, handlers,\n        defined = {},\n        waiting = {},\n        config = {},\n        defining = {},\n        hasOwn = Object.prototype.hasOwnProperty,\n        aps = [].slice;\n\n    function hasProp(obj, prop) {\n        return hasOwn.call(obj, prop);\n    }\n\n    /**\n     * Given a relative module name, like ./something, normalize it to\n     * a real name that can be mapped to a path.\n     * @param {String} name the relative name\n     * @param {String} baseName a real name that the name arg is relative\n     * to.\n     * @returns {String} normalized name\n     */\n    function normalize(name, baseName) {\n        var nameParts, nameSegment, mapValue, foundMap,\n            foundI, foundStarMap, starI, i, j, part,\n            baseParts = baseName && baseName.split(\"/\"),\n            map = config.map,\n            starMap = (map && map['*']) || {};\n\n        //Adjust any relative paths.\n        if (name && name.charAt(0) === \".\") {\n            //If have a base name, try to normalize against it,\n            //otherwise, assume it is a top-level require that will\n            //be relative to baseUrl in the end.\n            if (baseName) {\n                //Convert baseName to array, and lop off the last part,\n                //so that . matches that \"directory\" and not name of the baseName's\n                //module. For instance, baseName of \"one/two/three\", maps to\n                //\"one/two/three.js\", but we want the directory, \"one/two\" for\n                //this normalization.\n                baseParts = baseParts.slice(0, baseParts.length - 1);\n\n                name = baseParts.concat(name.split(\"/\"));\n\n                //start trimDots\n                for (i = 0; i < name.length; i += 1) {\n                    part = name[i];\n                    if (part === \".\") {\n                        name.splice(i, 1);\n                        i -= 1;\n                    } else if (part === \"..\") {\n                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {\n                            //End of the line. Keep at least one non-dot\n                            //path segment at the front so it can be mapped\n                            //correctly to disk. Otherwise, there is likely\n                            //no path mapping for a path starting with '..'.\n                            //This can still fail, but catches the most reasonable\n                            //uses of ..\n                            break;\n                        } else if (i > 0) {\n                            name.splice(i - 1, 2);\n                            i -= 2;\n                        }\n                    }\n                }\n                //end trimDots\n\n                name = name.join(\"/\");\n            } else if (name.indexOf('./') === 0) {\n                // No baseName, so this is ID is resolved relative\n                // to baseUrl, pull off the leading dot.\n                name = name.substring(2);\n            }\n        }\n\n        //Apply map config if available.\n        if ((baseParts || starMap) && map) {\n            nameParts = name.split('/');\n\n            for (i = nameParts.length; i > 0; i -= 1) {\n                nameSegment = nameParts.slice(0, i).join(\"/\");\n\n                if (baseParts) {\n                    //Find the longest baseName segment match in the config.\n                    //So, do joins on the biggest to smallest lengths of baseParts.\n                    for (j = baseParts.length; j > 0; j -= 1) {\n                        mapValue = map[baseParts.slice(0, j).join('/')];\n\n                        //baseName segment has  config, find if it has one for\n                        //this name.\n                        if (mapValue) {\n                            mapValue = mapValue[nameSegment];\n                            if (mapValue) {\n                                //Match, update name to the new value.\n                                foundMap = mapValue;\n                                foundI = i;\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                if (foundMap) {\n                    break;\n                }\n\n                //Check for a star map match, but just hold on to it,\n                //if there is a shorter segment match later in a matching\n                //config, then favor over this star map.\n                if (!foundStarMap && starMap && starMap[nameSegment]) {\n                    foundStarMap = starMap[nameSegment];\n                    starI = i;\n                }\n            }\n\n            if (!foundMap && foundStarMap) {\n                foundMap = foundStarMap;\n                foundI = starI;\n            }\n\n            if (foundMap) {\n                nameParts.splice(0, foundI, foundMap);\n                name = nameParts.join('/');\n            }\n        }\n\n        return name;\n    }\n\n    function makeRequire(relName, forceSync) {\n        return function () {\n            //A version of a require function that passes a moduleName\n            //value for items that may need to\n            //look up paths relative to the moduleName\n            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));\n        };\n    }\n\n    function makeNormalize(relName) {\n        return function (name) {\n            return normalize(name, relName);\n        };\n    }\n\n    function makeLoad(depName) {\n        return function (value) {\n            defined[depName] = value;\n        };\n    }\n\n    function callDep(name) {\n        if (hasProp(waiting, name)) {\n            var args = waiting[name];\n            delete waiting[name];\n            defining[name] = true;\n            main.apply(undef, args);\n        }\n\n        if (!hasProp(defined, name) && !hasProp(defining, name)) {\n            throw new Error('No ' + name);\n        }\n        return defined[name];\n    }\n\n    //Turns a plugin!resource to [plugin, resource]\n    //with the plugin being undefined if the name\n    //did not have a plugin prefix.\n    function splitPrefix(name) {\n        var prefix,\n            index = name ? name.indexOf('!') : -1;\n        if (index > -1) {\n            prefix = name.substring(0, index);\n            name = name.substring(index + 1, name.length);\n        }\n        return [prefix, name];\n    }\n\n    /**\n     * Makes a name map, normalizing the name, and using a plugin\n     * for normalization if necessary. Grabs a ref to plugin\n     * too, as an optimization.\n     */\n    makeMap = function (name, relName) {\n        var plugin,\n            parts = splitPrefix(name),\n            prefix = parts[0];\n\n        name = parts[1];\n\n        if (prefix) {\n            prefix = normalize(prefix, relName);\n            plugin = callDep(prefix);\n        }\n\n        //Normalize according\n        if (prefix) {\n            if (plugin && plugin.normalize) {\n                name = plugin.normalize(name, makeNormalize(relName));\n            } else {\n                name = normalize(name, relName);\n            }\n        } else {\n            name = normalize(name, relName);\n            parts = splitPrefix(name);\n            prefix = parts[0];\n            name = parts[1];\n            if (prefix) {\n                plugin = callDep(prefix);\n            }\n        }\n\n        //Using ridiculous property names for space reasons\n        return {\n            f: prefix ? prefix + '!' + name : name, //fullName\n            n: name,\n            pr: prefix,\n            p: plugin\n        };\n    };\n\n    function makeConfig(name) {\n        return function () {\n            return (config && config.config && config.config[name]) || {};\n        };\n    }\n\n    handlers = {\n        require: function (name) {\n            return makeRequire(name);\n        },\n        exports: function (name) {\n            var e = defined[name];\n            if (typeof e !== 'undefined') {\n                return e;\n            } else {\n                return (defined[name] = {});\n            }\n        },\n        module: function (name) {\n            return {\n                id: name,\n                uri: '',\n                exports: defined[name],\n                config: makeConfig(name)\n            };\n        }\n    };\n\n    main = function (name, deps, callback, relName) {\n        var cjsModule, depName, ret, map, i,\n            args = [],\n            usingExports;\n\n        //Use name if no relName\n        relName = relName || name;\n\n        //Call the callback to define the module, if necessary.\n        if (typeof callback === 'function') {\n\n            //Pull out the defined dependencies and pass the ordered\n            //values to the callback.\n            //Default to [require, exports, module] if no deps\n            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;\n            for (i = 0; i < deps.length; i += 1) {\n                map = makeMap(deps[i], relName);\n                depName = map.f;\n\n                //Fast path CommonJS standard dependencies.\n                if (depName === \"require\") {\n                    args[i] = handlers.require(name);\n                } else if (depName === \"exports\") {\n                    //CommonJS module spec 1.1\n                    args[i] = handlers.exports(name);\n                    usingExports = true;\n                } else if (depName === \"module\") {\n                    //CommonJS module spec 1.1\n                    cjsModule = args[i] = handlers.module(name);\n                } else if (hasProp(defined, depName) ||\n                           hasProp(waiting, depName) ||\n                           hasProp(defining, depName)) {\n                    args[i] = callDep(depName);\n                } else if (map.p) {\n                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});\n                    args[i] = defined[depName];\n                } else {\n                    throw new Error(name + ' missing ' + depName);\n                }\n            }\n\n            ret = callback.apply(defined[name], args);\n\n            if (name) {\n                //If setting exports via \"module\" is in play,\n                //favor that over return value and exports. After that,\n                //favor a non-undefined return value over exports use.\n                if (cjsModule && cjsModule.exports !== undef &&\n                        cjsModule.exports !== defined[name]) {\n                    defined[name] = cjsModule.exports;\n                } else if (ret !== undef || !usingExports) {\n                    //Use the return value from the function.\n                    defined[name] = ret;\n                }\n            }\n        } else if (name) {\n            //May just be an object definition for the module. Only\n            //worry about defining if have a module name.\n            defined[name] = callback;\n        }\n    };\n\n    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {\n        if (typeof deps === \"string\") {\n            if (handlers[deps]) {\n                //callback in this case is really relName\n                return handlers[deps](callback);\n            }\n            //Just return the module wanted. In this scenario, the\n            //deps arg is the module name, and second arg (if passed)\n            //is just the relName.\n            //Normalize module name, if it contains . or ..\n            return callDep(makeMap(deps, callback).f);\n        } else if (!deps.splice) {\n            //deps is a config object, not an array.\n            config = deps;\n            if (callback.splice) {\n                //callback is an array, which means it is a dependency list.\n                //Adjust args if there are dependencies\n                deps = callback;\n                callback = relName;\n                relName = null;\n            } else {\n                deps = undef;\n            }\n        }\n\n        //Support require(['a'])\n        callback = callback || function () {};\n\n        //If relName is a function, it is an errback handler,\n        //so remove it.\n        if (typeof relName === 'function') {\n            relName = forceSync;\n            forceSync = alt;\n        }\n\n        //Simulate async callback;\n        if (forceSync) {\n            main(undef, deps, callback, relName);\n        } else {\n            //Using a non-zero value because of concern for what old browsers\n            //do, and latest browsers \"upgrade\" to 4 if lower value is used:\n            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:\n            //If want a value immediately, use require('id') instead -- something\n            //that works in almond on the global level, but not guaranteed and\n            //unlikely to work in other AMD implementations.\n            setTimeout(function () {\n                main(undef, deps, callback, relName);\n            }, 4);\n        }\n\n        return req;\n    };\n\n    /**\n     * Just drops the config on the floor, but returns req in case\n     * the config return value is used.\n     */\n    req.config = function (cfg) {\n        config = cfg;\n        if (config.deps) {\n            req(config.deps, config.callback);\n        }\n        return req;\n    };\n\n    define = function (name, deps, callback) {\n\n        //This module may not have dependencies\n        if (!deps.splice) {\n            //deps is not an array, so probably means\n            //an object literal or factory function for\n            //the value. Adjust args.\n            callback = deps;\n            deps = [];\n        }\n\n        if (!hasProp(defined, name) && !hasProp(waiting, name)) {\n            waiting[name] = [name, deps, callback];\n        }\n    };\n\n    define.amd = {\n        jQuery: true\n    };\n}());\n\ndefine(\"almond\", function(){});\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Module that defines the image names and gets a getImage method once they are loaded.  See SimLauncher.\r\n * Makes it possible to load through the module system rather than passed as parameter everywhere or used as global.\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/joistImageLoader',[],function() {\r\n  'use strict';\r\n\r\n  return {\r\n    imageNames: [\r\n      'phet-logo-loading.svg',\r\n      'phet-logo-short.svg',\r\n      'phet-logo-short.png'\r\n    ]\r\n  };\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n/**\r\n * Launches a PhET Simulation, after preloading the specified images.\r\n * Requires PxLoader and PxImage\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/SimLauncher',['require','JOIST/joistImageLoader'],function( require ) {\r\n  'use strict';\r\n\r\n  var joistImageLoader = require( 'JOIST/joistImageLoader' );\r\n\r\n  var loadedResourceCount = 0;\r\n\r\n  return {\r\n    /**\r\n     * Launch the Sim by preloading the images and calling the callback.\r\n     *\r\n     * TODO: add an awesome loading screen\r\n     *\r\n     * @param {*} simImageLoader an object with an {Array<String>} imageNames property\r\n     * @param callback the callback function which should create and start the sim, given that the images are loaded\r\n     */\r\n    launch: function( simImageLoader, callback ) {\r\n      \r\n      // the image progress loader (only set to an instance if it is needed)\r\n      var pxLoader;\r\n      \r\n      // image elements to remove once we are fully loaded\r\n      var elementsToRemove = [];\r\n      \r\n      // in Safari (but right now not other browsers), the images are not fully loaded by the time this code is reached,\r\n      // so we don't send the immediate completion\r\n      var delayCompletionEvent = false;\r\n\r\n      function doneLoadingImages() {\r\n        loadedResourceCount++;\r\n        if ( loadedResourceCount === 1 ) {\r\n          $( '#splash' ).remove();\r\n          callback();\r\n        }\r\n      }\r\n\r\n      //Load the images for a single imageLoader.\r\n      function load( imageLoader, path ) {\r\n        var loadedImages = {};\r\n        imageLoader.getImage = function( name ) { return loadedImages[name]; };\r\n        \r\n        imageLoader.imageNames.forEach( function( image ) {\r\n          var filename = path + '/' + image;\r\n          \r\n          // check to see if we have a reference to this image in the DOM (included with data URI in base64)\r\n          loadedImages[image] = document.getElementById( filename );\r\n          if ( loadedImages[image] ) {\r\n            // window.console && console.log && console.log( 'loaded ' + filename + ' with dimensions: ' + loadedImages[image].width + 'x' + loadedImages[image].height );\r\n            if ( loadedImages[image].width === 0 || loadedImages[image].height === 0 ) {\r\n              // if it exists but doesn't have dimensions, we wait until window's onload to trigger the \"all images loaded\" signal\r\n              delayCompletionEvent = true;\r\n            }\r\n            \r\n            // mark the element to be removed from the DOM\r\n            elementsToRemove.push( loadedImages[image] );\r\n          } else {\r\n            // TODO: only print warning if we detect we are a production / release candidate build\r\n            window.console && console.log && console.log( 'WARNING: could not find image: ' + filename + ', using PxLoader' );\r\n            \r\n            // use PxLoader to load the image from an external resource\r\n            if ( !pxLoader ) { pxLoader = new PxLoader(); }\r\n            loadedImages[image] = pxLoader.addImage( filename );\r\n          }\r\n        } );\r\n      }\r\n\r\n      // load images and configure the image loader\r\n      load( simImageLoader, 'images' );\r\n      load( joistImageLoader, '../joist/images' );\r\n      \r\n      // if any images failed to load normally, use the PxLoader\r\n      if ( pxLoader ) {\r\n        pxLoader.addCompletionListener( doneLoadingImages );\r\n        pxLoader.start();\r\n      } else {\r\n        // if pxLoader wasn't needed AND image dimensions exist, immediately fire the \"all images loaded\" event\r\n        if ( !delayCompletionEvent ) {\r\n          doneLoadingImages();\r\n        }\r\n      }\r\n      \r\n      $( window ).load( function() {\r\n        // if images were not loaded immediately (and we didn't use PxLoader), signal the \"all images loaded\" event\r\n        if ( delayCompletionEvent && !pxLoader ) {\r\n          doneLoadingImages();\r\n        }\r\n        \r\n        // we wait for here to remove the images from the DOM, otherwise IE9/10 treat the images as completely blank!\r\n        _.each( elementsToRemove, function( element ) {\r\n          element.parentNode.removeChild( element );\r\n        } );\r\n      } );\r\n    }};\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/*\r\n * Usage:\r\n * var assert = require( '<assert>' )( 'flagName' );\r\n *\r\n * assert && assert( <simple value or big computation>, \"<message here>\" );\r\n *\r\n * TODO: decide on usages and viability, and if so document further\r\n *\r\n * NOTE: for changing build, add has.js tests for 'assert.' + flagName\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'ASSERT/assert',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = function( name, excludeByDefault ) {\r\n    var hasName = 'assert.' + name;\r\n    \r\n    var flagDefined = window.has && window.has( hasName ) !== undefined;\r\n    var skipAssert = flagDefined ? !window.has( hasName ) : excludeByDefault;\r\n    \r\n    if ( skipAssert ) {\r\n      return null;\r\n    } else {\r\n      return function( predicate, message ) {\r\n        var result = typeof predicate === 'function' ? predicate() : predicate;\r\n        \r\n        if ( !result ) {\r\n\r\n          //Log the stack trace to IE.  Just creating an Error is not enough, it has to be caught to get a stack.\r\n          //TODO: What will this do for IE9?  Probably just print stack = undefined.\r\n          if ( window.navigator && window.navigator.appName === 'Microsoft Internet Explorer' ) {\r\n            try { throw new Error(); }\r\n            catch( e ) { message = message + \", stack=\\n\" + e.stack; }\r\n          }\r\n          \r\n          // TODO: custom error?\r\n          throw new Error( 'Assertion failed: ' + message );\r\n        }\r\n      };\r\n    }\r\n  };\r\n  \r\n  return assert;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * The main 'scenery' namespace object for the exported (non-Require.js) API. Used internally\r\n * since it prevents Require.js issues with circular dependencies.\r\n *\r\n * The returned scenery object namespace may be incomplete if not all modules are listed as\r\n * dependencies. Please use the 'main' module for that purpose if all of Scenery is desired.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/scenery',['require','ASSERT/assert','ASSERT/assert'],function( require ) {\r\n  'use strict';\r\n  \r\n  window.sceneryAssert = require( 'ASSERT/assert' )( 'scenery' );\r\n  window.sceneryAssertExtra = require( 'ASSERT/assert' )( 'scenery.extra' );\r\n  \r\n  window.sceneryLayerLog = null;\r\n  window.sceneryEventLog = null;\r\n  window.sceneryAccessibilityLog = null;\r\n  \r\n  var scratchCanvas = document.createElement( 'canvas' );\r\n  var scratchContext = scratchCanvas.getContext( '2d' );\r\n  \r\n  // will be filled in by other modules\r\n  return {\r\n    scratchCanvas: scratchCanvas,   // a canvas used for convenience functions (think of it as having arbitrary state)\r\n    scratchContext: scratchContext, // a context used for convenience functions (think of it as having arbitrary state)\r\n    \r\n    enableLayerLogging: function() {\r\n      window.sceneryLayerLog = function( ob ) { console.log( ob ); };\r\n    },\r\n  \r\n    disableLayerLogging: function() {\r\n      window.sceneryLayerLog = null;\r\n    },\r\n    \r\n    enableEventLogging: function() {\r\n      window.sceneryEventLog = function( ob ) { console.log( ob ); };\r\n    },\r\n  \r\n    disableEventLogging: function() {\r\n      window.sceneryEventLog = null;\r\n    },\r\n    \r\n    enableAccessibilityLogging: function() {\r\n      window.sceneryAccessibilityLog = function( ob ) { console.log( ob ); };\r\n    },\r\n  \r\n    disableAccessibilityLogging: function() {\r\n      window.sceneryAccessibilityLog = null;\r\n    }\r\n  };\r\n} );\r\n","\n\r\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\ndefine( 'DOT/dot',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = function dot() {\r\n    switch ( arguments.length ) {\r\n      case 2:\r\n        return new dot.Vector2( arguments[0], arguments[1] );\r\n      case 3:\r\n        return new dot.Vector3( arguments[0], arguments[1], arguments[2] );\r\n      case 4:\r\n        return new dot.Vector4( arguments[0], arguments[1], arguments[2], arguments[3] );\r\n      default:\r\n        throw new Error( 'dot takes 2-4 arguments' );\r\n    }\r\n  };\r\n  \r\n  // TODO: performance: check browser speed to compare how fast this is. We may need to add a 32 option for GL ES.\r\n  dot.FastArray = window.Float64Array ? window.Float64Array : window.Array;\r\n  \r\n  // will be filled in by other modules\r\n  return dot;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Like Underscore's _.extend, but with hardcoded support for ES5 getters/setters.\r\n *\r\n * See https://github.com/documentcloud/underscore/pull/986.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'PHET_CORE/extend',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  return function extend( obj ) {\r\n    _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {\r\n      if ( source ) {\r\n        for ( var prop in source ) {\r\n          Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );\r\n        }\r\n      }\r\n    });\r\n    return obj;\r\n  };\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Experimental prototype inheritance\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\ndefine( 'PHET_CORE/inherit',['require','PHET_CORE/extend'],function( require ) {\r\n  'use strict';\r\n  \r\n  var extend = require( 'PHET_CORE/extend' );\r\n  \r\n  /**\r\n   * Experimental inheritance prototype, similar to Inheritance.inheritPrototype, but maintains\r\n   * supertype.prototype.constructor while properly copying ES5 getters and setters.\r\n   *\r\n   * TODO: find problems with this! It's effectively what is being used by Scenery\r\n   * TODO: consider inspecting arguments to see whether they are functions or just objects, to support\r\n   *       something like inherit( subtype, supertypeA, supertypeB, properties )\r\n   *\r\n   * Usage:\r\n   * function A() { scenery.Node.call( this ); };\r\n   * inherit( scenery.Node, A, {\r\n   *   customBehavior: function() { ... },\r\n   *   isAnA: true\r\n   * } );\r\n   * new A().isAnA // true\r\n   * new scenery.Node().isAnA // undefined\r\n   * new A().constructor.name // 'A'\r\n   *\r\n   * @param subtype             Constructor for the subtype. Generally should contain supertype.call( this, ... )\r\n   * @param supertype           Constructor for the supertype.\r\n   * @param prototypeProperties [optional] object containing properties that will be set on the prototype.\r\n   * @param staticProperties [optional] object containing properties that will be set on the constructor function itself\r\n   */\r\n  function inherit( supertype, subtype, prototypeProperties, staticProperties ) {\r\n    function F() {}\r\n    F.prototype = supertype.prototype; // so new F().__proto__ === supertype.prototype\r\n    \r\n    subtype.prototype = extend( // extend will combine the properties and constructor into the new F copy\r\n      new F(),                  // so new F().__proto__ === supertype.prototype, and the prototype chain is set up nicely\r\n      { constructor: subtype }, // overrides the constructor properly\r\n      prototypeProperties       // [optional] additional properties for the prototype, as an object.\r\n    );\r\n\r\n    //Copy the static properties onto the subtype constructor so they can be accessed 'statically'\r\n    extend( subtype, staticProperties );\r\n    \r\n    return subtype; // pass back the subtype so it can be returned immediately as a module export\r\n  }\r\n\r\n  return inherit;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Utility functions for Dot, placed into the dot.X namespace.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Util',['require','ASSERT/assert','DOT/dot'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  // require( 'DOT/Vector2' ); // Require.js doesn't like the circular reference\r\n  \r\n  dot.Util = {\r\n    testAssert: function() {\r\n      return 'assert.dot: ' + ( assert ? 'true' : 'false' );\r\n    },\r\n    \r\n    clamp: function( value, min, max ) {\r\n      if ( value < min ) {\r\n        return min;\r\n      }\r\n      else if ( value > max ) {\r\n        return max;\r\n      }\r\n      else {\r\n        return value;\r\n      }\r\n    },\r\n    \r\n    // returns a number between [min,max) with the same equivalence class as value mod (max-min)\r\n    moduloBetweenDown: function( value, min, max ) {\r\n      assert && assert( max > min, 'max > min required for moduloBetween' );\r\n      \r\n      var divisor = max - min;\r\n      \r\n      // get a partial result of value-min between [0,divisor)\r\n      var partial = ( value - min ) % divisor;\r\n      if ( partial < 0 ) {\r\n        // since if value-min < 0, the remainder will give us a negative number\r\n        partial += divisor;\r\n      }\r\n      \r\n      return partial + min; // add back in the minimum value\r\n    },\r\n    \r\n    // returns a number between (min,max] with the same equivalence class as value mod (max-min)\r\n    moduloBetweenUp: function( value, min, max ) {\r\n      return -Util.moduloBetweenDown( -value, -max, -min );\r\n    },\r\n    \r\n    // Returns an array of integers from A to B (including both A to B)\r\n    rangeInclusive: function( a, b ) {\r\n      if ( b < a ) {\r\n        return [];\r\n      }\r\n      var result = new Array( b - a + 1 );\r\n      for ( var i = a; i <= b; i++ ) {\r\n        result[i-a] = i;\r\n      }\r\n      return result;\r\n    },\r\n    \r\n    // Returns an array of integers between A and B (excluding both A to B)\r\n    rangeExclusive: function( a, b ) {\r\n      return Util.rangeInclusive( a + 1, b - 1 );\r\n    },\r\n    \r\n    toRadians: function( degrees ) {\r\n      return Math.PI * degrees / 180;\r\n    },\r\n    \r\n    toDegrees: function( radians ) {\r\n      return 180 * radians / Math.PI;\r\n    },\r\n    \r\n    // intersection between the line from p1-p2 and the line from p3-p4\r\n    lineLineIntersection: function( p1, p2, p3, p4 ) {\r\n      return new dot.Vector2(\r\n        ( ( p1.x * p2.y - p1.y * p2.x ) * ( p3.x - p4.x ) - ( p1.x - p2.x ) * ( p3.x * p4.y - p3.y * p4.x ) ) / ( ( p1.x - p2.x ) * ( p3.y - p4.y ) - ( p1.y - p2.y ) * ( p3.x - p4.x ) ),\r\n        ( ( p1.x * p2.y - p1.y * p2.x ) * ( p3.y - p4.y ) - ( p1.y - p2.y ) * ( p3.x * p4.y - p3.y * p4.x ) ) / ( ( p1.x - p2.x ) * ( p3.y - p4.y ) - ( p1.y - p2.y ) * ( p3.x - p4.x ) )\r\n      );\r\n    },\r\n    \r\n    // return an array of real roots of ax^2 + bx + c = 0\r\n    solveQuadraticRootsReal: function( a, b, c ) {\r\n      var discriminant = b * b - 4 * a * c;\r\n      if ( discriminant < 0 ) {\r\n        return [];\r\n      }\r\n      var sqrt = Math.sqrt( discriminant );\r\n      // TODO: how to handle if discriminant is 0? give unique root or double it?\r\n      // TODO: probably just use Complex for the future\r\n      return [\r\n        ( -b - sqrt ) / ( 2 * a ),\r\n        ( -b + sqrt ) / ( 2 * a )\r\n      ];\r\n    },\r\n    \r\n    // return an array of real roots of ax^3 + bx^2 + cx + d = 0\r\n    solveCubicRootsReal: function( a, b, c, d ) {\r\n      // TODO: a Complex type!\r\n      \r\n      //We need to test whether a is several orders of magnitude less than b, c, d\r\n      var epsilon = 1E7;\r\n      \r\n      if ( a === 0 || Math.abs( b / a ) > epsilon || Math.abs( c / a ) > epsilon || Math.abs( d / a ) > epsilon ) {\r\n        return Util.solveQuadraticRootsReal( b, c, d );\r\n      }\r\n      if ( d === 0 || Math.abs( a / d ) > epsilon || Math.abs( b / d ) > epsilon || Math.abs( c / d ) > epsilon ) {\r\n        return Util.solveQuadraticRootsReal( a, b, c );\r\n      }\r\n      \r\n      b /= a;\r\n      c /= a;\r\n      d /= a;\r\n      \r\n      var s, t;\r\n      var q = ( 3.0 * c - ( b * b ) ) / 9;\r\n      var r = ( -(27 * d) + b * (9 * c - 2 * (b * b)) ) / 54;\r\n      var discriminant = q  * q  * q + r  * r;\r\n      var b3 = b / 3;\r\n      \r\n      if ( discriminant > 0 ) {\r\n        // a single real root\r\n        var dsqrt = Math.sqrt( discriminant );\r\n        return [ Util.cubeRoot( r + dsqrt ) + Util.cubeRoot( r - dsqrt ) - b3 ];\r\n      }\r\n      \r\n      // three real roots\r\n      if ( discriminant === 0 ) {\r\n        // contains a double root\r\n        var rsqrt = Util.cubeRoot( r );\r\n        var doubleRoot = b3 - rsqrt;\r\n        return [ -b3 + 2 * rsqrt, doubleRoot, doubleRoot ];\r\n      } else {\r\n        // all unique\r\n        var qX = -q * q * q;\r\n        qX = Math.acos( r / Math.sqrt( qX ) );\r\n        var rr = 2 * Math.sqrt( -q );\r\n        return [\r\n          -b3 + rr * Math.cos( qX / 3 ),\r\n          -b3 + rr * Math.cos( ( qX + 2 * Math.PI ) / 3 ),\r\n          -b3 + rr * Math.cos( ( qX + 4 * Math.PI ) / 3 )\r\n        ];\r\n      }\r\n    },\r\n    \r\n    cubeRoot: function( x ) {\r\n      return x >= 0 ? Math.pow( x, 1/3 ) : -Math.pow( -x, 1/3 );\r\n    },\r\n\r\n    // Linearly interpolate two points and evaluate the line equation for a third point\r\n    // f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>\r\n    linear: function( a1, a2, b1, b2, a3 ) {\r\n      return ( b2 - b1 ) / ( a2 - a1 ) * ( a3 - a1 ) + b1;\r\n    },\r\n\r\n    /**\r\n     * A predictable implementation of toFixed.\r\n     * JavaScript's toFixed is notoriously buggy, behavior differs depending on browser,\r\n     * because the spec doesn't specify whether to round or floor.\r\n     */\r\n    toFixed: function( number, decimalPlaces ) {\r\n      var multiplier = Math.pow( 10, decimalPlaces );\r\n      return Math.round( number * multiplier ) / multiplier;\r\n    },\r\n\r\n    isInteger: function( number ) {\r\n      return Math.floor( number ) === number;\r\n    }\r\n  };\r\n  var Util = dot.Util;\r\n  \r\n  // make these available in the main namespace directly (for now)\r\n  dot.testAssert = Util.testAssert;\r\n  dot.clamp = Util.clamp;\r\n  dot.moduloBetweenDown = Util.moduloBetweenDown;\r\n  dot.moduloBetweenUp = Util.moduloBetweenUp;\r\n  dot.rangeInclusive = Util.rangeInclusive;\r\n  dot.rangeExclusive = Util.rangeExclusive;\r\n  dot.toRadians = Util.toRadians;\r\n  dot.toDegrees = Util.toDegrees;\r\n  dot.lineLineIntersection = Util.lineLineIntersection;\r\n  dot.solveQuadraticRootsReal = Util.solveQuadraticRootsReal;\r\n  dot.solveCubicRootsReal = Util.solveCubicRootsReal;\r\n  dot.cubeRoot = Util.cubeRoot;\r\n  dot.linear = Util.linear;\r\n  \r\n  return Util;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Basic 2-dimensional vector\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Vector2',['require','ASSERT/assert','DOT/dot','PHET_CORE/inherit','DOT/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  require( 'DOT/Util' );\r\n  // require( 'DOT/Vector3' ); // commented out since Require.js complains about the circular dependency\r\n  \r\n  dot.Vector2 = function Vector2( x, y ) {\r\n    // allow optional parameters\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    \r\n    assert && assert( typeof this.x === 'number', 'x needs to be a number' );\r\n    assert && assert( typeof this.y === 'number', 'y needs to be a number' );\r\n  };\r\n  var Vector2 = dot.Vector2;\r\n  \r\n  Vector2.createPolar = function( magnitude, angle ) {\r\n    return new Vector2( magnitude * Math.cos( angle ), magnitude * Math.sin( angle ) );\r\n  };\r\n  \r\n  Vector2.prototype = {\r\n    constructor: Vector2,\r\n    \r\n    isVector2: true,\r\n    \r\n    dimension: 2,\r\n    \r\n    magnitude: function() {\r\n      return Math.sqrt( this.magnitudeSquared() );\r\n    },\r\n    \r\n    magnitudeSquared: function() {\r\n      return this.dot( this );\r\n    },\r\n    \r\n    // the distance between this vector (treated as a point) and another point\r\n    distance: function( point ) {\r\n      return this.minus( point ).magnitude();\r\n    },\r\n    \r\n    // the squared distance between this vector (treated as a point) and another point\r\n    distanceSquared: function( point ) {\r\n      return this.minus( point ).magnitudeSquared();\r\n    },\r\n    \r\n    dot: function( v ) {\r\n      return this.x * v.x + this.y * v.y;\r\n    },\r\n    \r\n    equals: function( other ) {\r\n      return this.x === other.x && this.y === other.y;\r\n    },\r\n    \r\n    equalsEpsilon: function( other, epsilon ) {\r\n      if ( !epsilon ) {\r\n        epsilon = 0;\r\n      }\r\n      return Math.max( Math.abs( this.x - other.x ), Math.abs( this.y - other.y ) ) <= epsilon;\r\n    },\r\n    \r\n    isFinite: function() {\r\n      return isFinite( this.x ) && isFinite( this.y );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n     * Immutables\r\n     *----------------------------------------------------------------------------*/\r\n    \r\n    copy: function() {\r\n      return new Vector2( this.x, this.y );\r\n    },\r\n    \r\n    // z component of the equivalent 3-dimensional cross product (this.x, this.y,0) x (v.x, v.y, 0)\r\n    crossScalar: function( v ) {\r\n      return this.x * v.y - this.y * v.x;\r\n    },\r\n    \r\n    normalized: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return new Vector2( this.x / mag, this.y / mag );\r\n      }\r\n    },\r\n    \r\n    timesScalar: function( scalar ) {\r\n      return new Vector2( this.x * scalar, this.y * scalar );\r\n    },\r\n    \r\n    times: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.timesScalar( scalar );\r\n    },\r\n    \r\n    componentTimes: function( v ) {\r\n      return new Vector2( this.x * v.x, this.y * v.y );\r\n    },\r\n    \r\n    plus: function( v ) {\r\n      return new Vector2( this.x + v.x, this.y + v.y );\r\n    },\r\n    \r\n    plusScalar: function( scalar ) {\r\n      return new Vector2( this.x + scalar, this.y + scalar );\r\n    },\r\n    \r\n    minus: function( v ) {\r\n      return new Vector2( this.x - v.x, this.y - v.y );\r\n    },\r\n    \r\n    minusScalar: function( scalar ) {\r\n      return new Vector2( this.x - scalar, this.y - scalar );\r\n    },\r\n    \r\n    dividedScalar: function( scalar ) {\r\n      return new Vector2( this.x / scalar, this.y / scalar );\r\n    },\r\n    \r\n    negated: function() {\r\n      return new Vector2( -this.x, -this.y );\r\n    },\r\n    \r\n    angle: function() {\r\n      return Math.atan2( this.y, this.x );\r\n    },\r\n    \r\n    // equivalent to a -PI/2 rotation (right hand rotation)\r\n    perpendicular: function() {\r\n      return new Vector2( this.y, -this.x );\r\n    },\r\n    \r\n    angleBetween: function( v ) {\r\n      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );\r\n    },\r\n    \r\n    rotated: function( angle ) {\r\n      var newAngle = this.angle() + angle;\r\n      return new Vector2( Math.cos( newAngle ), Math.sin( newAngle ) ).timesScalar( this.magnitude() );\r\n    },\r\n    \r\n    // linear interpolation from this (ratio=0) to vector (ratio=1)\r\n    blend: function( vector, ratio ) {\r\n      return new Vector2( this.x + (vector.x - this.x) * ratio, this.y + (vector.y - this.y) * ratio );\r\n    },\r\n    \r\n    toString: function() {\r\n      return \"Vector2(\" + this.x + \", \" + this.y + \")\";\r\n    },\r\n    \r\n    toVector3: function() {\r\n      return new dot.Vector3( this.x, this.y );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n     * Mutables\r\n     *----------------------------------------------------------------------------*/\r\n    \r\n    set: function( x, y ) {\r\n      this.x = x;\r\n      this.y = y;\r\n      return this;\r\n    },\r\n    \r\n    setX: function( x ) {\r\n      this.x = x;\r\n      return this;\r\n    },\r\n    \r\n    setY: function( y ) {\r\n      this.y = y;\r\n      return this;\r\n    },\r\n    \r\n    add: function( v ) {\r\n      this.x += v.x;\r\n      this.y += v.y;\r\n      return this;\r\n    },\r\n    \r\n    addScalar: function( scalar ) {\r\n      this.x += scalar;\r\n      this.y += scalar;\r\n      return this;\r\n    },\r\n    \r\n    subtract: function( v ) {\r\n      this.x -= v.x;\r\n      this.y -= v.y;\r\n      return this;\r\n    },\r\n    \r\n    subtractScalar: function( scalar ) {\r\n      this.x -= scalar;\r\n      this.y -= scalar;\r\n      return this;\r\n    },\r\n    \r\n    componentMultiply: function( v ) {\r\n      this.x *= v.x;\r\n      this.y *= v.y;\r\n      return this;\r\n    },\r\n    \r\n    divideScalar: function( scalar ) {\r\n      this.x /= scalar;\r\n      this.y /= scalar;\r\n      return this;\r\n    },\r\n    \r\n    negate: function() {\r\n      this.x = -this.x;\r\n      this.y = -this.y;\r\n      return this;\r\n    }\r\n    \r\n  };\r\n  \r\n  /*---------------------------------------------------------------------------*\r\n   * Immutable Vector form\r\n   *----------------------------------------------------------------------------*/\r\n  Vector2.Immutable = function ImmutableVector2( x, y ) {\r\n    Vector2.call( this, x, y );\r\n  };\r\n  var Immutable = Vector2.Immutable;\r\n  \r\n  inherit( Vector2, Immutable );\r\n  \r\n  // throw errors whenever a mutable method is called on our immutable vector\r\n  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {\r\n    Immutable.prototype[mutableFunctionName] = function() {\r\n      throw new Error( \"Cannot call mutable method '\" + mutableFunctionName + \"' on immutable Vector2\" );\r\n    };\r\n  };\r\n  \r\n  // TODO: better way to handle this list?\r\n  Immutable.mutableOverrideHelper( 'set' );\r\n  Immutable.mutableOverrideHelper( 'setX' );\r\n  Immutable.mutableOverrideHelper( 'setY' );\r\n  Immutable.mutableOverrideHelper( 'copy' );\r\n  Immutable.mutableOverrideHelper( 'add' );\r\n  Immutable.mutableOverrideHelper( 'addScalar' );\r\n  Immutable.mutableOverrideHelper( 'subtract' );\r\n  Immutable.mutableOverrideHelper( 'subtractScalar' );\r\n  Immutable.mutableOverrideHelper( 'componentMultiply' );\r\n  Immutable.mutableOverrideHelper( 'divideScalar' );\r\n  Immutable.mutableOverrideHelper( 'negate' );\r\n  \r\n  // helpful immutable constants\r\n  Vector2.ZERO = new Immutable( 0, 0 );\r\n  Vector2.X_UNIT = new Immutable( 1, 0 );\r\n  Vector2.Y_UNIT = new Immutable( 0, 1 );\r\n  \r\n  return Vector2;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Basic 4-dimensional vector\r\n *\r\n * TODO: sync with Vector2 changes\r\n * TODO: add quaternion extension\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Vector4',['require','ASSERT/assert','DOT/dot','DOT/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Util' );\r\n  // require( 'DOT/Vector3' ); // commented out so Require.js doesn't complain about the circular dependency\r\n  \r\n  dot.Vector4 = function Vector4( x, y, z, w ) {\r\n    // allow optional parameters\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n    this.w = w !== undefined ? w : 1; // since w could be zero!\r\n  };\r\n  var Vector4 = dot.Vector4;\r\n  \r\n  Vector4.prototype = {\r\n    constructor: Vector4,\r\n\r\n    magnitude: function() {\r\n      return Math.sqrt( this.magnitudeSquared() );\r\n    },\r\n\r\n    magnitudeSquared: function() {\r\n      this.dot( this );\r\n    },\r\n    \r\n    // the distance between this vector (treated as a point) and another point\r\n    distance: function( point ) {\r\n      return this.minus( point ).magnitude();\r\n    },\r\n    \r\n    // the squared distance between this vector (treated as a point) and another point\r\n    distanceSquared: function( point ) {\r\n      return this.minus( point ).magnitudeSquared();\r\n    },\r\n\r\n    dot: function( v ) {\r\n      return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;\r\n    },\r\n    \r\n    isFinite: function() {\r\n      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z ) && isFinite( this.w );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    normalized: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return new Vector4( this.x / mag, this.y / mag, this.z / mag, this.w / mag );\r\n      }\r\n    },\r\n\r\n    timesScalar: function( scalar ) {\r\n      return new Vector4( this.x * scalar, this.y * scalar, this.z * scalar, this.w * scalar );\r\n    },\r\n\r\n    times: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.timesScalar( scalar );\r\n    },\r\n\r\n    componentTimes: function( v ) {\r\n      return new Vector4( this.x * v.x, this.y * v.y, this.z * v.z, this.w * v.w );\r\n    },\r\n\r\n    plus: function( v ) {\r\n      return new Vector4( this.x + v.x, this.y + v.y, this.z + v.z, this.w + v.w );\r\n    },\r\n\r\n    plusScalar: function( scalar ) {\r\n      return new Vector4( this.x + scalar, this.y + scalar, this.z + scalar, this.w + scalar );\r\n    },\r\n\r\n    minus: function( v ) {\r\n      return new Vector4( this.x - v.x, this.y - v.y, this.z - v.z, this.w - v.w );\r\n    },\r\n\r\n    minusScalar: function( scalar ) {\r\n      return new Vector4( this.x - scalar, this.y - scalar, this.z - scalar, this.w - scalar );\r\n    },\r\n\r\n    dividedScalar: function( scalar ) {\r\n      return new Vector4( this.x / scalar, this.y / scalar, this.z / scalar, this.w / scalar );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Vector4( -this.x, -this.y, -this.z, -this.w );\r\n    },\r\n\r\n    angleBetween: function( v ) {\r\n      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );\r\n    },\r\n    \r\n    // linear interpolation from this (ratio=0) to vector (ratio=1)\r\n    blend: function( vector, ratio ) {\r\n      return this.plus( vector.minus( this ).times( ratio ) );\r\n    },\r\n\r\n    toString: function() {\r\n      return \"Vector4(\" + this.x + \", \" + this.y + \", \" + this.z + \", \" + this.w + \")\";\r\n    },\r\n\r\n    toVector3: function() {\r\n      return new dot.Vector3( this.x, this.y, this.z );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    set: function( x, y, z, w ) {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n      this.w = w;\r\n    },\r\n\r\n    setX: function( x ) {\r\n      this.x = x;\r\n    },\r\n\r\n    setY: function( y ) {\r\n      this.y = y;\r\n    },\r\n\r\n    setZ: function( z ) {\r\n      this.z = z;\r\n    },\r\n\r\n    setW: function( w ) {\r\n      this.w = w;\r\n    },\r\n\r\n    copy: function( v ) {\r\n      this.x = v.x;\r\n      this.y = v.y;\r\n      this.z = v.z;\r\n      this.w = v.w;\r\n    },\r\n\r\n    add: function( v ) {\r\n      this.x += v.x;\r\n      this.y += v.y;\r\n      this.z += v.z;\r\n      this.w += v.w;\r\n    },\r\n\r\n    addScalar: function( scalar ) {\r\n      this.x += scalar;\r\n      this.y += scalar;\r\n      this.z += scalar;\r\n      this.w += scalar;\r\n    },\r\n\r\n    subtract: function( v ) {\r\n      this.x -= v.x;\r\n      this.y -= v.y;\r\n      this.z -= v.z;\r\n      this.w -= v.w;\r\n    },\r\n\r\n    subtractScalar: function( scalar ) {\r\n      this.x -= scalar;\r\n      this.y -= scalar;\r\n      this.z -= scalar;\r\n      this.w -= scalar;\r\n    },\r\n\r\n    componentMultiply: function( v ) {\r\n      this.x *= v.x;\r\n      this.y *= v.y;\r\n      this.z *= v.z;\r\n      this.w *= v.w;\r\n    },\r\n\r\n    divideScalar: function( scalar ) {\r\n      this.x /= scalar;\r\n      this.y /= scalar;\r\n      this.z /= scalar;\r\n      this.w /= scalar;\r\n    },\r\n\r\n    negate: function() {\r\n      this.x = -this.x;\r\n      this.y = -this.y;\r\n      this.z = -this.z;\r\n      this.w = -this.w;\r\n    },\r\n    \r\n    equals: function( other ) {\r\n      return this.x === other.x && this.y === other.y && this.z === other.z && this.w === other.w;\r\n    },\r\n    \r\n    equalsEpsilon: function( other, epsilon ) {\r\n      if ( !epsilon ) {\r\n        epsilon = 0;\r\n      }\r\n      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) + Math.abs( this.w - other.w ) <= epsilon;\r\n    },\r\n\r\n    isVector4: true,\r\n\r\n    dimension: 4\r\n\r\n  };\r\n\r\n  /*---------------------------------------------------------------------------*\r\n   * Immutable Vector form\r\n   *----------------------------------------------------------------------------*/\r\n  Vector4.Immutable = function( x, y, z, w ) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n    this.w = w !== undefined ? w : 1;\r\n  };\r\n  var Immutable = Vector4.Immutable;\r\n\r\n  Immutable.prototype = new Vector4();\r\n  Immutable.prototype.constructor = Immutable;\r\n\r\n  // throw errors whenever a mutable method is called on our immutable vector\r\n  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {\r\n    Immutable.prototype[mutableFunctionName] = function() {\r\n      throw new Error( \"Cannot call mutable method '\" + mutableFunctionName + \"' on immutable Vector4\" );\r\n    };\r\n  };\r\n\r\n  // TODO: better way to handle this list?\r\n  Immutable.mutableOverrideHelper( 'set' );\r\n  Immutable.mutableOverrideHelper( 'setX' );\r\n  Immutable.mutableOverrideHelper( 'setY' );\r\n  Immutable.mutableOverrideHelper( 'setZ' );\r\n  Immutable.mutableOverrideHelper( 'setW' );\r\n  Immutable.mutableOverrideHelper( 'copy' );\r\n  Immutable.mutableOverrideHelper( 'add' );\r\n  Immutable.mutableOverrideHelper( 'addScalar' );\r\n  Immutable.mutableOverrideHelper( 'subtract' );\r\n  Immutable.mutableOverrideHelper( 'subtractScalar' );\r\n  Immutable.mutableOverrideHelper( 'componentMultiply' );\r\n  Immutable.mutableOverrideHelper( 'divideScalar' );\r\n  Immutable.mutableOverrideHelper( 'negate' );\r\n\r\n  // helpful immutable constants\r\n  Vector4.ZERO = new Immutable( 0, 0, 0, 0 );\r\n  Vector4.X_UNIT = new Immutable( 1, 0, 0, 0 );\r\n  Vector4.Y_UNIT = new Immutable( 0, 1, 0, 0 );\r\n  Vector4.Z_UNIT = new Immutable( 0, 0, 1, 0 );\r\n  Vector4.W_UNIT = new Immutable( 0, 0, 0, 1 );\r\n  \r\n  return Vector4;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Basic 3-dimensional vector\r\n *\r\n * TODO: sync with Vector2 changes\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Vector3',['require','ASSERT/assert','DOT/dot','DOT/Util','DOT/Vector2','DOT/Vector4'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Util' );\r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Vector4' );\r\n\r\n  dot.Vector3 = function Vector3( x, y, z ) {\r\n    // allow optional parameters\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n  };\r\n  var Vector3 = dot.Vector3;\r\n\r\n  Vector3.prototype = {\r\n    constructor: Vector3,\r\n\r\n    magnitude: function() {\r\n      return Math.sqrt( this.magnitudeSquared() );\r\n    },\r\n\r\n    magnitudeSquared: function() {\r\n      return this.dot( this );\r\n    },\r\n    \r\n    // the distance between this vector (treated as a point) and another point\r\n    distance: function( point ) {\r\n      return this.minus( point ).magnitude();\r\n    },\r\n    \r\n    // the squared distance between this vector (treated as a point) and another point\r\n    distanceSquared: function( point ) {\r\n      return this.minus( point ).magnitudeSquared();\r\n    },\r\n\r\n    dot: function( v ) {\r\n      return this.x * v.x + this.y * v.y + this.z * v.z;\r\n    },\r\n    \r\n    isFinite: function() {\r\n      return isFinite( this.x ) && isFinite( this.y ) && isFinite( this.z );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Immutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    cross: function( v ) {\r\n      return new Vector3(\r\n          this.y * v.z - this.z * v.y,\r\n          this.z * v.x - this.x * v.z,\r\n          this.x * v.y - this.y * v.x\r\n      );\r\n    },\r\n\r\n    normalized: function() {\r\n      var mag = this.magnitude();\r\n      if ( mag === 0 ) {\r\n        throw new Error( \"Cannot normalize a zero-magnitude vector\" );\r\n      }\r\n      else {\r\n        return new Vector3( this.x / mag, this.y / mag, this.z / mag );\r\n      }\r\n    },\r\n\r\n    timesScalar: function( scalar ) {\r\n      return new Vector3( this.x * scalar, this.y * scalar, this.z * scalar );\r\n    },\r\n\r\n    times: function( scalar ) {\r\n      // make sure it's not a vector!\r\n      assert && assert( scalar.dimension === undefined );\r\n      return this.timesScalar( scalar );\r\n    },\r\n\r\n    componentTimes: function( v ) {\r\n      return new Vector3( this.x * v.x, this.y * v.y, this.z * v.z );\r\n    },\r\n\r\n    plus: function( v ) {\r\n      return new Vector3( this.x + v.x, this.y + v.y, this.z + v.z );\r\n    },\r\n\r\n    plusScalar: function( scalar ) {\r\n      return new Vector3( this.x + scalar, this.y + scalar, this.z + scalar );\r\n    },\r\n\r\n    minus: function( v ) {\r\n      return new Vector3( this.x - v.x, this.y - v.y, this.z - v.z );\r\n    },\r\n\r\n    minusScalar: function( scalar ) {\r\n      return new Vector3( this.x - scalar, this.y - scalar, this.z - scalar );\r\n    },\r\n\r\n    dividedScalar: function( scalar ) {\r\n      return new Vector3( this.x / scalar, this.y / scalar, this.z / scalar );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Vector3( -this.x, -this.y, -this.z );\r\n    },\r\n\r\n    angleBetween: function( v ) {\r\n      return Math.acos( dot.clamp( this.normalized().dot( v.normalized() ), -1, 1 ) );\r\n    },\r\n    \r\n    // linear interpolation from this (ratio=0) to vector (ratio=1)\r\n    blend: function( vector, ratio ) {\r\n      return this.plus( vector.minus( this ).times( ratio ) );\r\n    },\r\n\r\n    toString: function() {\r\n      return \"Vector3(\" + this.x + \", \" + this.y + \", \" + this.z + \")\";\r\n    },\r\n\r\n    toVector2: function() {\r\n      return new dot.Vector2( this.x, this.y );\r\n    },\r\n\r\n    toVector4: function() {\r\n      return new dot.Vector4( this.x, this.y, this.z );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * Mutables\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    set: function( x, y, z ) {\r\n      this.x = x;\r\n      this.y = y;\r\n      this.z = z;\r\n    },\r\n\r\n    setX: function( x ) {\r\n      this.x = x;\r\n    },\r\n\r\n    setY: function( y ) {\r\n      this.y = y;\r\n    },\r\n\r\n    setZ: function( z ) {\r\n      this.z = z;\r\n    },\r\n\r\n    copy: function( v ) {\r\n      this.x = v.x;\r\n      this.y = v.y;\r\n      this.z = v.z;\r\n    },\r\n\r\n    add: function( v ) {\r\n      this.x += v.x;\r\n      this.y += v.y;\r\n      this.z += v.z;\r\n    },\r\n\r\n    addScalar: function( scalar ) {\r\n      this.x += scalar;\r\n      this.y += scalar;\r\n      this.z += scalar;\r\n    },\r\n\r\n    subtract: function( v ) {\r\n      this.x -= v.x;\r\n      this.y -= v.y;\r\n      this.z -= v.z;\r\n    },\r\n\r\n    subtractScalar: function( scalar ) {\r\n      this.x -= scalar;\r\n      this.y -= scalar;\r\n      this.z -= scalar;\r\n    },\r\n\r\n    componentMultiply: function( v ) {\r\n      this.x *= v.x;\r\n      this.y *= v.y;\r\n      this.z *= v.z;\r\n    },\r\n\r\n    divideScalar: function( scalar ) {\r\n      this.x /= scalar;\r\n      this.y /= scalar;\r\n      this.z /= scalar;\r\n    },\r\n\r\n    negate: function() {\r\n      this.x = -this.x;\r\n      this.y = -this.y;\r\n      this.z = -this.z;\r\n    },\r\n    \r\n    equals: function( other ) {\r\n      return this.x === other.x && this.y === other.y && this.z === other.z;\r\n    },\r\n    \r\n    equalsEpsilon: function( other, epsilon ) {\r\n      if ( !epsilon ) {\r\n        epsilon = 0;\r\n      }\r\n      return Math.abs( this.x - other.x ) + Math.abs( this.y - other.y ) + Math.abs( this.z - other.z ) <= epsilon;\r\n    },\r\n\r\n    isVector3: true,\r\n\r\n    dimension: 3\r\n\r\n  };\r\n\r\n  /*---------------------------------------------------------------------------*\r\n   * Immutable Vector form\r\n   *----------------------------------------------------------------------------*/\r\n  Vector3.Immutable = function( x, y, z ) {\r\n    this.x = x || 0;\r\n    this.y = y || 0;\r\n    this.z = z || 0;\r\n  };\r\n  var Immutable = Vector3.Immutable;\r\n\r\n  Immutable.prototype = new Vector3();\r\n  Immutable.prototype.constructor = Immutable;\r\n\r\n  // throw errors whenever a mutable method is called on our immutable vector\r\n  Immutable.mutableOverrideHelper = function( mutableFunctionName ) {\r\n    Immutable.prototype[mutableFunctionName] = function() {\r\n      throw new Error( \"Cannot call mutable method '\" + mutableFunctionName + \"' on immutable Vector3\" );\r\n    };\r\n  };\r\n\r\n  // TODO: better way to handle this list?\r\n  Immutable.mutableOverrideHelper( 'set' );\r\n  Immutable.mutableOverrideHelper( 'setX' );\r\n  Immutable.mutableOverrideHelper( 'setY' );\r\n  Immutable.mutableOverrideHelper( 'setZ' );\r\n  Immutable.mutableOverrideHelper( 'copy' );\r\n  Immutable.mutableOverrideHelper( 'add' );\r\n  Immutable.mutableOverrideHelper( 'addScalar' );\r\n  Immutable.mutableOverrideHelper( 'subtract' );\r\n  Immutable.mutableOverrideHelper( 'subtractScalar' );\r\n  Immutable.mutableOverrideHelper( 'componentMultiply' );\r\n  Immutable.mutableOverrideHelper( 'divideScalar' );\r\n  Immutable.mutableOverrideHelper( 'negate' );\r\n\r\n  // helpful immutable constants\r\n  Vector3.ZERO = new Immutable( 0, 0, 0 );\r\n  Vector3.X_UNIT = new Immutable( 1, 0, 0 );\r\n  Vector3.Y_UNIT = new Immutable( 0, 1, 0 );\r\n  Vector3.Z_UNIT = new Immutable( 0, 0, 1 );\r\n  \r\n  return Vector3;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * 4-dimensional Matrix\r\n *\r\n * TODO: consider adding affine flag if it will help performance (a la Matrix3)\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Matrix4',['require','DOT/dot','DOT/Vector3','DOT/Vector4'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Vector4' );\r\n  \r\n  var Float32Array = window.Float32Array || Array;\r\n  \r\n  dot.Matrix4 = function Matrix4( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {\r\n\r\n    // entries stored in column-major format\r\n    this.entries = new Float32Array( 16 );\r\n\r\n    this.rowMajor( v00 === undefined ? 1 : v00, v01 || 0, v02 || 0, v03 || 0,\r\n             v10 || 0, v11 === undefined ? 1 : v11, v12 || 0, v13 || 0,\r\n             v20 || 0, v21 || 0, v22 === undefined ? 1 : v22, v23 || 0,\r\n             v30 || 0, v31 || 0, v32 || 0, v33 === undefined ? 1 : v33,\r\n             type );\r\n  };\r\n  var Matrix4 = dot.Matrix4;\r\n\r\n  Matrix4.Types = {\r\n    OTHER: 0, // default\r\n    IDENTITY: 1,\r\n    TRANSLATION_3D: 2,\r\n    SCALING: 3\r\n\r\n    // TODO: possibly add rotations\r\n  };\r\n\r\n  var Types = Matrix4.Types;\r\n\r\n  Matrix4.identity = function() {\r\n    return new Matrix4( 1, 0, 0, 0,\r\n              0, 1, 0, 0,\r\n              0, 0, 1, 0,\r\n              0, 0, 0, 1,\r\n              Types.IDENTITY );\r\n  };\r\n\r\n  Matrix4.translation = function( x, y, z ) {\r\n    return new Matrix4( 1, 0, 0, x,\r\n              0, 1, 0, y,\r\n              0, 0, 1, z,\r\n              0, 0, 0, 1,\r\n              Types.TRANSLATION_3D );\r\n  };\r\n\r\n  Matrix4.translationFromVector = function( v ) { return Matrix4.translation( v.x, v.y, v.z ); };\r\n\r\n  Matrix4.scaling = function( x, y, z ) {\r\n    // allow using one parameter to scale everything\r\n    y = y === undefined ? x : y;\r\n    z = z === undefined ? x : z;\r\n\r\n    return new Matrix4( x, 0, 0, 0,\r\n              0, y, 0, 0,\r\n              0, 0, z, 0,\r\n              0, 0, 0, 1,\r\n              Types.SCALING );\r\n  };\r\n\r\n  // axis is a normalized Vector3, angle in radians.\r\n  Matrix4.rotationAxisAngle = function( axis, angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n    var C = 1 - c;\r\n\r\n    return new Matrix4( axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s, 0,\r\n              axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s, 0,\r\n              axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c, 0,\r\n              0, 0, 0, 1,\r\n              Types.OTHER );\r\n  };\r\n\r\n  // TODO: add in rotation from quaternion, and from quat + translation\r\n\r\n  Matrix4.rotationX = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix4( 1, 0, 0, 0,\r\n              0, c, -s, 0,\r\n              0, s, c, 0,\r\n              0, 0, 0, 1,\r\n              Types.OTHER );\r\n  };\r\n\r\n  Matrix4.rotationY = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix4( c, 0, s, 0,\r\n              0, 1, 0, 0,\r\n              -s, 0, c, 0,\r\n              0, 0, 0, 1,\r\n              Types.OTHER );\r\n  };\r\n\r\n  Matrix4.rotationZ = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix4( c, -s, 0, 0,\r\n              s, c, 0, 0,\r\n              0, 0, 1, 0,\r\n              0, 0, 0, 1,\r\n              Types.OTHER );\r\n  };\r\n\r\n  // aspect === width / height\r\n  Matrix4.gluPerspective = function( fovYRadians, aspect, zNear, zFar ) {\r\n    var cotangent = Math.cos( fovYRadians ) / Math.sin( fovYRadians );\r\n\r\n    return new Matrix4( cotangent / aspect, 0, 0, 0,\r\n              0, cotangent, 0, 0,\r\n              0, 0, ( zFar + zNear ) / ( zNear - zFar ), ( 2 * zFar * zNear ) / ( zNear - zFar ),\r\n              0, 0, -1, 0 );\r\n  };\r\n\r\n  Matrix4.prototype = {\r\n    constructor: Matrix4,\r\n\r\n    rowMajor: function( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type ) {\r\n      this.entries[0] = v00;\r\n      this.entries[1] = v10;\r\n      this.entries[2] = v20;\r\n      this.entries[3] = v30;\r\n      this.entries[4] = v01;\r\n      this.entries[5] = v11;\r\n      this.entries[6] = v21;\r\n      this.entries[7] = v31;\r\n      this.entries[8] = v02;\r\n      this.entries[9] = v12;\r\n      this.entries[10] = v22;\r\n      this.entries[11] = v32;\r\n      this.entries[12] = v03;\r\n      this.entries[13] = v13;\r\n      this.entries[14] = v23;\r\n      this.entries[15] = v33;\r\n      this.type = type === undefined ? Types.OTHER : type;\r\n    },\r\n\r\n    columnMajor: function( v00, v10, v20, v30, v01, v11, v21, v31, v02, v12, v22, v32, v03, v13, v23, v33, type ) {\r\n      this.rowMajor( v00, v01, v02, v03, v10, v11, v12, v13, v20, v21, v22, v23, v30, v31, v32, v33, type );\r\n    },\r\n\r\n    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler\r\n    m00: function() { return this.entries[0]; },\r\n    m01: function() { return this.entries[4]; },\r\n    m02: function() { return this.entries[8]; },\r\n    m03: function() { return this.entries[12]; },\r\n    m10: function() { return this.entries[1]; },\r\n    m11: function() { return this.entries[5]; },\r\n    m12: function() { return this.entries[9]; },\r\n    m13: function() { return this.entries[13]; },\r\n    m20: function() { return this.entries[2]; },\r\n    m21: function() { return this.entries[6]; },\r\n    m22: function() { return this.entries[10]; },\r\n    m23: function() { return this.entries[14]; },\r\n    m30: function() { return this.entries[3]; },\r\n    m31: function() { return this.entries[7]; },\r\n    m32: function() { return this.entries[11]; },\r\n    m33: function() { return this.entries[15]; },\r\n\r\n    plus: function( m ) {\r\n      return new Matrix4(\r\n          this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(), this.m03() + m.m03(),\r\n          this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(), this.m13() + m.m13(),\r\n          this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22(), this.m23() + m.m23(),\r\n          this.m30() + m.m30(), this.m31() + m.m31(), this.m32() + m.m32(), this.m33() + m.m33()\r\n      );\r\n    },\r\n\r\n    minus: function( m ) {\r\n      return new Matrix4(\r\n          this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(), this.m03() - m.m03(),\r\n          this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(), this.m13() - m.m13(),\r\n          this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22(), this.m23() - m.m23(),\r\n          this.m30() - m.m30(), this.m31() - m.m31(), this.m32() - m.m32(), this.m33() - m.m33()\r\n      );\r\n    },\r\n\r\n    transposed: function() {\r\n      return new Matrix4( this.m00(), this.m10(), this.m20(), this.m30(),\r\n                this.m01(), this.m11(), this.m21(), this.m31(),\r\n                this.m02(), this.m12(), this.m22(), this.m32(),\r\n                this.m03(), this.m13(), this.m23(), this.m33() );\r\n    },\r\n\r\n    negated: function() {\r\n      return new Matrix4( -this.m00(), -this.m01(), -this.m02(), -this.m03(),\r\n                -this.m10(), -this.m11(), -this.m12(), -this.m13(),\r\n                -this.m20(), -this.m21(), -this.m22(), -this.m23(),\r\n                -this.m30(), -this.m31(), -this.m32(), -this.m33() );\r\n    },\r\n\r\n    inverted: function() {\r\n      // TODO: optimizations for matrix types (like identity)\r\n\r\n      var det = this.determinant();\r\n\r\n      if ( det !== 0 ) {\r\n        return new Matrix4(\r\n            ( -this.m31() * this.m22() * this.m13() + this.m21() * this.m32() * this.m13() + this.m31() * this.m12() * this.m23() - this.m11() * this.m32() * this.m23() - this.m21() * this.m12() * this.m33() + this.m11() * this.m22() * this.m33() ) / det,\r\n            ( this.m31() * this.m22() * this.m03() - this.m21() * this.m32() * this.m03() - this.m31() * this.m02() * this.m23() + this.m01() * this.m32() * this.m23() + this.m21() * this.m02() * this.m33() - this.m01() * this.m22() * this.m33() ) / det,\r\n            ( -this.m31() * this.m12() * this.m03() + this.m11() * this.m32() * this.m03() + this.m31() * this.m02() * this.m13() - this.m01() * this.m32() * this.m13() - this.m11() * this.m02() * this.m33() + this.m01() * this.m12() * this.m33() ) / det,\r\n            ( this.m21() * this.m12() * this.m03() - this.m11() * this.m22() * this.m03() - this.m21() * this.m02() * this.m13() + this.m01() * this.m22() * this.m13() + this.m11() * this.m02() * this.m23() - this.m01() * this.m12() * this.m23() ) / det,\r\n            ( this.m30() * this.m22() * this.m13() - this.m20() * this.m32() * this.m13() - this.m30() * this.m12() * this.m23() + this.m10() * this.m32() * this.m23() + this.m20() * this.m12() * this.m33() - this.m10() * this.m22() * this.m33() ) / det,\r\n            ( -this.m30() * this.m22() * this.m03() + this.m20() * this.m32() * this.m03() + this.m30() * this.m02() * this.m23() - this.m00() * this.m32() * this.m23() - this.m20() * this.m02() * this.m33() + this.m00() * this.m22() * this.m33() ) / det,\r\n            ( this.m30() * this.m12() * this.m03() - this.m10() * this.m32() * this.m03() - this.m30() * this.m02() * this.m13() + this.m00() * this.m32() * this.m13() + this.m10() * this.m02() * this.m33() - this.m00() * this.m12() * this.m33() ) / det,\r\n            ( -this.m20() * this.m12() * this.m03() + this.m10() * this.m22() * this.m03() + this.m20() * this.m02() * this.m13() - this.m00() * this.m22() * this.m13() - this.m10() * this.m02() * this.m23() + this.m00() * this.m12() * this.m23() ) / det,\r\n            ( -this.m30() * this.m21() * this.m13() + this.m20() * this.m31() * this.m13() + this.m30() * this.m11() * this.m23() - this.m10() * this.m31() * this.m23() - this.m20() * this.m11() * this.m33() + this.m10() * this.m21() * this.m33() ) / det,\r\n            ( this.m30() * this.m21() * this.m03() - this.m20() * this.m31() * this.m03() - this.m30() * this.m01() * this.m23() + this.m00() * this.m31() * this.m23() + this.m20() * this.m01() * this.m33() - this.m00() * this.m21() * this.m33() ) / det,\r\n            ( -this.m30() * this.m11() * this.m03() + this.m10() * this.m31() * this.m03() + this.m30() * this.m01() * this.m13() - this.m00() * this.m31() * this.m13() - this.m10() * this.m01() * this.m33() + this.m00() * this.m11() * this.m33() ) / det,\r\n            ( this.m20() * this.m11() * this.m03() - this.m10() * this.m21() * this.m03() - this.m20() * this.m01() * this.m13() + this.m00() * this.m21() * this.m13() + this.m10() * this.m01() * this.m23() - this.m00() * this.m11() * this.m23() ) / det,\r\n            ( this.m30() * this.m21() * this.m12() - this.m20() * this.m31() * this.m12() - this.m30() * this.m11() * this.m22() + this.m10() * this.m31() * this.m22() + this.m20() * this.m11() * this.m32() - this.m10() * this.m21() * this.m32() ) / det,\r\n            ( -this.m30() * this.m21() * this.m02() + this.m20() * this.m31() * this.m02() + this.m30() * this.m01() * this.m22() - this.m00() * this.m31() * this.m22() - this.m20() * this.m01() * this.m32() + this.m00() * this.m21() * this.m32() ) / det,\r\n            ( this.m30() * this.m11() * this.m02() - this.m10() * this.m31() * this.m02() - this.m30() * this.m01() * this.m12() + this.m00() * this.m31() * this.m12() + this.m10() * this.m01() * this.m32() - this.m00() * this.m11() * this.m32() ) / det,\r\n            ( -this.m20() * this.m11() * this.m02() + this.m10() * this.m21() * this.m02() + this.m20() * this.m01() * this.m12() - this.m00() * this.m21() * this.m12() - this.m10() * this.m01() * this.m22() + this.m00() * this.m11() * this.m22() ) / det\r\n        );\r\n      }\r\n      else {\r\n        throw new Error( \"Matrix could not be inverted, determinant === 0\" );\r\n      }\r\n    },\r\n\r\n    timesMatrix: function( m ) {\r\n      var newType = Types.OTHER;\r\n      if ( this.type === Types.TRANSLATION_3D && m.type === Types.TRANSLATION_3D ) {\r\n        newType = Types.TRANSLATION_3D;\r\n      }\r\n      if ( this.type === Types.SCALING && m.type === Types.SCALING ) {\r\n        newType = Types.SCALING;\r\n      }\r\n      if ( this.type === Types.IDENTITY ) {\r\n        newType = m.type;\r\n      }\r\n      if ( m.type === Types.IDENTITY ) {\r\n        newType = this.type;\r\n      }\r\n      return new Matrix4( this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20() + this.m03() * m.m30(),\r\n                this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21() + this.m03() * m.m31(),\r\n                this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22() + this.m03() * m.m32(),\r\n                this.m00() * m.m03() + this.m01() * m.m13() + this.m02() * m.m23() + this.m03() * m.m33(),\r\n                this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20() + this.m13() * m.m30(),\r\n                this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21() + this.m13() * m.m31(),\r\n                this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22() + this.m13() * m.m32(),\r\n                this.m10() * m.m03() + this.m11() * m.m13() + this.m12() * m.m23() + this.m13() * m.m33(),\r\n                this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20() + this.m23() * m.m30(),\r\n                this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21() + this.m23() * m.m31(),\r\n                this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() + this.m23() * m.m32(),\r\n                this.m20() * m.m03() + this.m21() * m.m13() + this.m22() * m.m23() + this.m23() * m.m33(),\r\n                this.m30() * m.m00() + this.m31() * m.m10() + this.m32() * m.m20() + this.m33() * m.m30(),\r\n                this.m30() * m.m01() + this.m31() * m.m11() + this.m32() * m.m21() + this.m33() * m.m31(),\r\n                this.m30() * m.m02() + this.m31() * m.m12() + this.m32() * m.m22() + this.m33() * m.m32(),\r\n                this.m30() * m.m03() + this.m31() * m.m13() + this.m32() * m.m23() + this.m33() * m.m33(),\r\n                newType );\r\n    },\r\n\r\n    timesVector4: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z + this.m03() * v.w;\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z + this.m13() * v.w;\r\n      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z + this.m23() * v.w;\r\n      var w = this.m30() * v.x + this.m31() * v.y + this.m32() * v.z + this.m33() * v.w;\r\n      return new dot.Vector4( x, y, z, w );\r\n    },\r\n\r\n    timesVector3: function( v ) {\r\n      return this.timesVector4( v.toVector4() ).toVector3();\r\n    },\r\n\r\n    timesTransposeVector4: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z + this.m30() * v.w;\r\n      var y = this.m01() * v.x + this.m11() * v.y + this.m21() * v.z + this.m31() * v.w;\r\n      var z = this.m02() * v.x + this.m12() * v.y + this.m22() * v.z + this.m32() * v.w;\r\n      var w = this.m03() * v.x + this.m13() * v.y + this.m23() * v.z + this.m33() * v.w;\r\n      return new dot.Vector4( x, y, z, w );\r\n    },\r\n\r\n    timesTransposeVector3: function( v ) {\r\n      return this.timesTransposeVector4( v.toVector4() ).toVector3();\r\n    },\r\n\r\n    timesRelativeVector3: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y + this.m20() * v.z;\r\n      var y = this.m01() * v.y + this.m11() * v.y + this.m21() * v.z;\r\n      var z = this.m02() * v.z + this.m12() * v.y + this.m22() * v.z;\r\n      return new dot.Vector3( x, y, z );\r\n    },\r\n\r\n    determinant: function() {\r\n      return this.m03() * this.m12() * this.m21() * this.m30() -\r\n          this.m02() * this.m13() * this.m21() * this.m30() -\r\n          this.m03() * this.m11() * this.m22() * this.m30() +\r\n          this.m01() * this.m13() * this.m22() * this.m30() +\r\n          this.m02() * this.m11() * this.m23() * this.m30() -\r\n          this.m01() * this.m12() * this.m23() * this.m30() -\r\n          this.m03() * this.m12() * this.m20() * this.m31() +\r\n          this.m02() * this.m13() * this.m20() * this.m31() +\r\n          this.m03() * this.m10() * this.m22() * this.m31() -\r\n          this.m00() * this.m13() * this.m22() * this.m31() -\r\n          this.m02() * this.m10() * this.m23() * this.m31() +\r\n          this.m00() * this.m12() * this.m23() * this.m31() +\r\n          this.m03() * this.m11() * this.m20() * this.m32() -\r\n          this.m01() * this.m13() * this.m20() * this.m32() -\r\n          this.m03() * this.m10() * this.m21() * this.m32() +\r\n          this.m00() * this.m13() * this.m21() * this.m32() +\r\n          this.m01() * this.m10() * this.m23() * this.m32() -\r\n          this.m00() * this.m11() * this.m23() * this.m32() -\r\n          this.m02() * this.m11() * this.m20() * this.m33() +\r\n          this.m01() * this.m12() * this.m20() * this.m33() +\r\n          this.m02() * this.m10() * this.m21() * this.m33() -\r\n          this.m00() * this.m12() * this.m21() * this.m33() -\r\n          this.m01() * this.m10() * this.m22() * this.m33() +\r\n          this.m00() * this.m11() * this.m22() * this.m33();\r\n    },\r\n\r\n    toString: function() {\r\n      return this.m00() + \" \" + this.m01() + \" \" + this.m02() + \" \" + this.m03() + \"\\n\" +\r\n           this.m10() + \" \" + this.m11() + \" \" + this.m12() + \" \" + this.m13() + \"\\n\" +\r\n           this.m20() + \" \" + this.m21() + \" \" + this.m22() + \" \" + this.m23() + \"\\n\" +\r\n           this.m30() + \" \" + this.m31() + \" \" + this.m32() + \" \" + this.m33();\r\n    },\r\n\r\n    translation: function() { return new dot.Vector3( this.m03(), this.m13(), this.m23() ); },\r\n    scaling: function() { return new dot.Vector3( this.m00(), this.m11(), this.m22() );},\r\n\r\n    makeImmutable: function() {\r\n      this.rowMajor = function() {\r\n        throw new Error( \"Cannot modify immutable matrix\" );\r\n      };\r\n    }\r\n  };\r\n\r\n  // create an immutable\r\n  Matrix4.IDENTITY = new Matrix4();\r\n  Matrix4.IDENTITY.makeImmutable();\r\n  \r\n  return Matrix4;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * 3-dimensional Matrix\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Matrix3',['require','DOT/dot','DOT/Vector2','DOT/Vector3','DOT/Matrix4'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  var FastArray = dot.FastArray;\r\n  \r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Vector3' );\r\n  require( 'DOT/Matrix4' );\r\n  \r\n  dot.Matrix3 = function Matrix3( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {\r\n\r\n    // entries stored in column-major format\r\n    this.entries = new FastArray( 9 ); // TODO: consider a typed array if possible (double even?) for performance and compatibility with WebGL\r\n\r\n    this.rowMajor( v00 === undefined ? 1 : v00, v01 || 0, v02 || 0,\r\n                   v10 || 0, v11 === undefined ? 1 : v11, v12 || 0,\r\n                   v20 || 0, v21 || 0, v22 === undefined ? 1 : v22,\r\n                   type );\r\n  };\r\n  var Matrix3 = dot.Matrix3;\r\n\r\n  Matrix3.Types = {\r\n    // NOTE: if an inverted matrix of a type is not that type, change inverted()!\r\n    // NOTE: if two matrices with identical types are multiplied, the result should have the same type. if not, changed timesMatrix()!\r\n    // NOTE: on adding a type, exaustively check all type usage\r\n    OTHER: 0, // default\r\n    IDENTITY: 1,\r\n    TRANSLATION_2D: 2,\r\n    SCALING: 3,\r\n    AFFINE: 4\r\n\r\n    // TODO: possibly add rotations\r\n  };\r\n\r\n  var Types = Matrix3.Types;\r\n\r\n  Matrix3.identity = function() {\r\n    return new Matrix3( 1, 0, 0,\r\n                        0, 1, 0,\r\n                        0, 0, 1,\r\n                        Types.IDENTITY );\r\n  };\r\n\r\n  Matrix3.translation = function( x, y ) {\r\n    return new Matrix3( 1, 0, x,\r\n                        0, 1, y,\r\n                        0, 0, 1,\r\n                        Types.TRANSLATION_2D );\r\n  };\r\n\r\n  Matrix3.translationFromVector = function( v ) { return Matrix3.translation( v.x, v.y ); };\r\n\r\n  Matrix3.scaling = function( x, y ) {\r\n    // allow using one parameter to scale everything\r\n    y = y === undefined ? x : y;\r\n\r\n    return new Matrix3( x, 0, 0,\r\n                        0, y, 0,\r\n                        0, 0, 1,\r\n                        Types.SCALING );\r\n  };\r\n  Matrix3.scale = Matrix3.scaling;\r\n  \r\n  Matrix3.affine = function( m00, m10, m01, m11, m02, m12 ) {\r\n    return new Matrix3( m00, m01, m02, m10, m11, m12, 0, 0, 1, Types.AFFINE );\r\n  };\r\n\r\n  // axis is a normalized Vector3, angle in radians.\r\n  Matrix3.rotationAxisAngle = function( axis, angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n    var C = 1 - c;\r\n\r\n    return new Matrix3( axis.x * axis.x * C + c, axis.x * axis.y * C - axis.z * s, axis.x * axis.z * C + axis.y * s,\r\n                        axis.y * axis.x * C + axis.z * s, axis.y * axis.y * C + c, axis.y * axis.z * C - axis.x * s,\r\n                        axis.z * axis.x * C - axis.y * s, axis.z * axis.y * C + axis.x * s, axis.z * axis.z * C + c,\r\n                        Types.OTHER );\r\n  };\r\n\r\n  // TODO: add in rotation from quaternion, and from quat + translation\r\n\r\n  Matrix3.rotationX = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix3( 1, 0, 0,\r\n                        0, c, -s,\r\n                        0, s, c,\r\n                        Types.OTHER );\r\n  };\r\n\r\n  Matrix3.rotationY = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix3( c, 0, s,\r\n                        0, 1, 0,\r\n                        -s, 0, c,\r\n                        Types.OTHER );\r\n  };\r\n\r\n  Matrix3.rotationZ = function( angle ) {\r\n    var c = Math.cos( angle );\r\n    var s = Math.sin( angle );\r\n\r\n    return new Matrix3( c, -s, 0,\r\n                        s, c, 0,\r\n                        0, 0, 1,\r\n                        Types.AFFINE );\r\n  };\r\n  \r\n  // standard 2d rotation\r\n  Matrix3.rotation2 = Matrix3.rotationZ;\r\n  \r\n  Matrix3.fromSVGMatrix = function( svgMatrix ) {\r\n    return new Matrix3( svgMatrix.a, svgMatrix.c, svgMatrix.e,\r\n                        svgMatrix.b, svgMatrix.d, svgMatrix.f,\r\n                        0, 0, 1,\r\n                        Types.AFFINE );\r\n  };\r\n\r\n  // a rotation matrix that rotates A to B, by rotating about the axis A.cross( B ) -- Shortest path. ideally should be unit vectors\r\n  Matrix3.rotateAToB = function( a, b ) {\r\n    // see http://graphics.cs.brown.edu/~jfh/papers/Moller-EBA-1999/paper.pdf for information on this implementation\r\n    var start = a;\r\n    var end = b;\r\n\r\n    var epsilon = 0.0001;\r\n\r\n    var e, h, f;\r\n\r\n    var v = start.cross( end );\r\n    e = start.dot( end );\r\n    f = ( e < 0 ) ? -e : e;\r\n\r\n    // if \"from\" and \"to\" vectors are nearly parallel\r\n    if ( f > 1.0 - epsilon ) {\r\n      var c1, c2, c3;\r\n      /* coefficients for later use */\r\n      var i, j;\r\n\r\n      var x = new dot.Vector3(\r\n        ( start.x > 0.0 ) ? start.x : -start.x,\r\n        ( start.y > 0.0 ) ? start.y : -start.y,\r\n        ( start.z > 0.0 ) ? start.z : -start.z\r\n      );\r\n\r\n      if ( x.x < x.y ) {\r\n        if ( x.x < x.z ) {\r\n          x = dot.Vector3.X_UNIT;\r\n        }\r\n        else {\r\n          x = dot.Vector3.Z_UNIT;\r\n        }\r\n      }\r\n      else {\r\n        if ( x.y < x.z ) {\r\n          x = dot.Vector3.Y_UNIT;\r\n        }\r\n        else {\r\n          x = dot.Vector3.Z_UNIT;\r\n        }\r\n      }\r\n\r\n      var u = x.minus( start );\r\n      v = x.minus( end );\r\n\r\n      c1 = 2.0 / u.dot( u );\r\n      c2 = 2.0 / v.dot( v );\r\n      c3 = c1 * c2 * u.dot( v );\r\n\r\n      return Matrix3.IDENTITY.plus( Matrix3.rowMajor(\r\n        -c1 * u.x * u.x - c2 * v.x * v.x + c3 * v.x * u.x,\r\n        -c1 * u.x * u.y - c2 * v.x * v.y + c3 * v.x * u.y,\r\n        -c1 * u.x * u.z - c2 * v.x * v.z + c3 * v.x * u.z,\r\n        -c1 * u.y * u.x - c2 * v.y * v.x + c3 * v.y * u.x,\r\n        -c1 * u.y * u.y - c2 * v.y * v.y + c3 * v.y * u.y,\r\n        -c1 * u.y * u.z - c2 * v.y * v.z + c3 * v.y * u.z,\r\n        -c1 * u.z * u.x - c2 * v.z * v.x + c3 * v.z * u.x,\r\n        -c1 * u.z * u.y - c2 * v.z * v.y + c3 * v.z * u.y,\r\n        -c1 * u.z * u.z - c2 * v.z * v.z + c3 * v.z * u.z\r\n      ) );\r\n    }\r\n    else {\r\n      // the most common case, unless \"start\"=\"end\", or \"start\"=-\"end\"\r\n      var hvx, hvz, hvxy, hvxz, hvyz;\r\n      h = 1.0 / ( 1.0 + e );\r\n      hvx = h * v.x;\r\n      hvz = h * v.z;\r\n      hvxy = hvx * v.y;\r\n      hvxz = hvx * v.z;\r\n      hvyz = hvz * v.y;\r\n\r\n      return Matrix3.rowMajor(\r\n        e + hvx * v.x, hvxy - v.z, hvxz + v.y,\r\n        hvxy + v.z, e + h * v.y * v.y, hvyz - v.x,\r\n        hvxz - v.y, hvyz + v.x, e + hvz * v.z\r\n      );\r\n    }\r\n  };\r\n\r\n  Matrix3.prototype = {\r\n    constructor: Matrix3,\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * \"Properties\"\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // convenience getters. inline usages of these when performance is critical? TODO: test performance of inlining these, with / without closure compiler\r\n    m00: function() { return this.entries[0]; },\r\n    m01: function() { return this.entries[3]; },\r\n    m02: function() { return this.entries[6]; },\r\n    m10: function() { return this.entries[1]; },\r\n    m11: function() { return this.entries[4]; },\r\n    m12: function() { return this.entries[7]; },\r\n    m20: function() { return this.entries[2]; },\r\n    m21: function() { return this.entries[5]; },\r\n    m22: function() { return this.entries[8]; },\r\n    \r\n    isAffine: function() {\r\n      return this.type === Types.AFFINE || ( this.m20() === 0 && this.m21() === 0 && this.m22() === 1 );\r\n    },\r\n    \r\n    isFinite: function() {\r\n      return isFinite( this.m00() ) &&\r\n             isFinite( this.m01() ) &&\r\n             isFinite( this.m02() ) &&\r\n             isFinite( this.m10() ) &&\r\n             isFinite( this.m11() ) &&\r\n             isFinite( this.m12() ) &&\r\n             isFinite( this.m20() ) &&\r\n             isFinite( this.m21() ) &&\r\n             isFinite( this.m22() );\r\n    },\r\n    \r\n    getDeterminant: function() {\r\n      return this.m00() * this.m11() * this.m22() + this.m01() * this.m12() * this.m20() + this.m02() * this.m10() * this.m21() - this.m02() * this.m11() * this.m20() - this.m01() * this.m10() * this.m22() - this.m00() * this.m12() * this.m21();\r\n    },\r\n    get determinant() { return this.getDeterminant(); },\r\n    \r\n    getTranslation: function() {\r\n      return new dot.Vector2( this.m02(), this.m12() );\r\n    },\r\n    get translation() { return this.getTranslation(); },\r\n    \r\n    // returns a vector that is equivalent to ( T(1,0).magnitude(), T(0,1).magnitude() ) where T is a relative transform\r\n    getScaleVector: function() {\r\n      return new dot.Vector2( Math.sqrt( this.m00() * this.m00() + this.m10() * this.m10() ),\r\n                              Math.sqrt( this.m01() * this.m01() + this.m11() * this.m11() ) );\r\n    },\r\n    get scaleVector() { return this.getScaleVector(); },\r\n    \r\n    // angle in radians for the 2d rotation from this matrix, between pi, -pi\r\n    getRotation: function() {\r\n      var transformedVector = this.timesVector2( dot.Vector2.X_UNIT ).minus( this.timesVector2( dot.Vector2.ZERO ) );\r\n      return Math.atan2( transformedVector.y, transformedVector.x );\r\n    },\r\n    get rotation() { return this.getRotation(); },\r\n    \r\n    toMatrix4: function() {\r\n      return new dot.Matrix4( this.m00(), this.m01(), this.m02(), 0,\r\n                              this.m10(), this.m11(), this.m12(), 0,\r\n                              this.m20(), this.m21(), this.m22(), 0,\r\n                              0, 0, 0, 1 );\r\n    },\r\n    \r\n    toString: function() {\r\n      return this.m00() + ' ' + this.m01() + ' ' + this.m02() + '\\n' +\r\n             this.m10() + ' ' + this.m11() + ' ' + this.m12() + '\\n' +\r\n             this.m20() + ' ' + this.m21() + ' ' + this.m22();\r\n    },\r\n    \r\n    toSVGMatrix: function() {\r\n      var result = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' ).createSVGMatrix();\r\n      \r\n      // top two rows\r\n      result.a = this.m00();\r\n      result.b = this.m10();\r\n      result.c = this.m01();\r\n      result.d = this.m11();\r\n      result.e = this.m02();\r\n      result.f = this.m12();\r\n      \r\n      return result;\r\n    },\r\n    \r\n    getCSSTransform: function() {\r\n      // See http://www.w3.org/TR/css3-transforms/, particularly Section 13 that discusses the SVG compatibility\r\n      \r\n      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that\r\n      // 20 is the largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed\r\n      \r\n      // the inner part of a CSS3 transform, but remember to add the browser-specific parts!\r\n      // NOTE: the toFixed calls are inlined for performance reasons\r\n      return 'matrix(' + this.entries[0].toFixed( 20 ) + ',' + this.entries[1].toFixed( 20 ) + ',' + this.entries[3].toFixed( 20 ) + ',' + this.entries[4].toFixed( 20 ) + ',' + this.entries[6].toFixed( 20 ) + ',' + this.entries[7].toFixed( 20 ) + ')';\r\n    },\r\n    get cssTransform() { return this.getCSSTransform(); },\r\n    \r\n    getSVGTransform: function() {\r\n      // SVG transform presentation attribute. See http://www.w3.org/TR/SVG/coords.html#TransformAttribute\r\n      \r\n      // we need to prevent the numbers from being in an exponential toString form, since the CSS transform does not support that\r\n      function svgNumber( number ) {\r\n        // largest guaranteed number of digits according to https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Number/toFixed\r\n        return number.toFixed( 20 );\r\n      }\r\n      \r\n      switch( this.type ) {\r\n        case Types.IDENTITY:\r\n          return '';\r\n        case Types.TRANSLATION_2D:\r\n          return 'translate(' + svgNumber( this.entries[6] ) + ',' + this.entries[7] + ')';\r\n        case Types.SCALING:\r\n          return 'scale(' + svgNumber( this.entries[0] ) + ( this.entries[0] === this.entries[4] ? '' : ',' + svgNumber( this.entries[4] ) ) + ')';\r\n        default:\r\n          return 'matrix(' + svgNumber( this.entries[0] ) + ',' + svgNumber( this.entries[1] ) + ',' + svgNumber( this.entries[3] ) + ',' + svgNumber( this.entries[4] ) + ',' + svgNumber( this.entries[6] ) + ',' + svgNumber( this.entries[7] ) + ')';\r\n      }\r\n    },\r\n    get svgTransform() { return this.getSVGTransform(); },\r\n    \r\n    // returns a parameter object suitable for use with jQuery's .css()\r\n    getCSSTransformStyles: function() {\r\n      var transformCSS = this.getCSSTransform();\r\n      \r\n      // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/\r\n      return {\r\n        // force iOS hardware acceleration\r\n        '-webkit-perspective': 1000,\r\n        '-webkit-backface-visibility': 'hidden',\r\n        \r\n        '-webkit-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible\r\n        '-moz-transform': transformCSS + ' translateZ(0)', // trigger hardware acceleration if possible\r\n        '-ms-transform': transformCSS,\r\n        '-o-transform': transformCSS,\r\n        'transform': transformCSS,\r\n        'transform-origin': 'top left', // at the origin of the component. consider 0px 0px instead. Critical, since otherwise this defaults to 50% 50%!!! see https://developer.mozilla.org/en-US/docs/CSS/transform-origin\r\n        '-ms-transform-origin': 'top left' // TODO: do we need other platform-specific transform-origin styles?\r\n      };\r\n    },\r\n    get cssTransformStyles() { return this.getCSSTransformStyles(); },\r\n    \r\n    // exact equality\r\n    equals: function( m ) {\r\n      return this.m00() === m.m00() && this.m01() === m.m01() && this.m02() === m.m02() &&\r\n             this.m10() === m.m10() && this.m11() === m.m11() && this.m12() === m.m12() &&\r\n             this.m20() === m.m20() && this.m21() === m.m21() && this.m22() === m.m22();\r\n    },\r\n    \r\n    // equality within a margin of error\r\n    equalsEpsilon: function( m, epsilon ) {\r\n      return Math.abs( this.m00() - m.m00() ) < epsilon && Math.abs( this.m01() - m.m01() ) < epsilon && Math.abs( this.m02() - m.m02() ) < epsilon &&\r\n             Math.abs( this.m10() - m.m10() ) < epsilon && Math.abs( this.m11() - m.m11() ) < epsilon && Math.abs( this.m12() - m.m12() ) < epsilon &&\r\n             Math.abs( this.m20() - m.m20() ) < epsilon && Math.abs( this.m21() - m.m21() ) < epsilon && Math.abs( this.m22() - m.m22() ) < epsilon;\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Immutable operations (returns a new matrix)\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    copy: function() {\r\n      return new Matrix3(\r\n        this.m00(), this.m01(), this.m02(),\r\n        this.m10(), this.m11(), this.m12(),\r\n        this.m20(), this.m21(), this.m22(),\r\n        this.type\r\n      );\r\n    },\r\n    \r\n    plus: function( m ) {\r\n      return new Matrix3(\r\n        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),\r\n        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),\r\n        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()\r\n      );\r\n    },\r\n    \r\n    minus: function( m ) {\r\n      return new Matrix3(\r\n        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),\r\n        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),\r\n        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()\r\n      );\r\n    },\r\n    \r\n    transposed: function() {\r\n      return new Matrix3(\r\n        this.m00(), this.m10(), this.m20(),\r\n        this.m01(), this.m11(), this.m21(),\r\n        this.m02(), this.m12(), this.m22(), ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined\r\n      );\r\n    },\r\n    \r\n    negated: function() {\r\n      return new Matrix3(\r\n        -this.m00(), -this.m01(), -this.m02(),\r\n        -this.m10(), -this.m11(), -this.m12(),\r\n        -this.m20(), -this.m21(), -this.m22()\r\n      );\r\n    },\r\n    \r\n    inverted: function() {\r\n      var det;\r\n      \r\n      switch ( this.type ) {\r\n        case Types.IDENTITY:\r\n          return this;\r\n        case Types.TRANSLATION_2D:\r\n          return new Matrix3( 1, 0, -this.m02(),\r\n                              0, 1, -this.m12(),\r\n                              0, 0, 1, Types.TRANSLATION_2D );\r\n        case Types.SCALING:\r\n          return new Matrix3( 1 / this.m00(), 0, 0,\r\n                              0, 1 / this.m11(), 0,\r\n                              0, 0, 1 / this.m22(), Types.SCALING );\r\n        case Types.AFFINE:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return new Matrix3(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              0, 0, 1, Types.AFFINE\r\n            );\r\n          } else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        case Types.OTHER:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return new Matrix3(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,\r\n              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,\r\n              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,\r\n              Types.OTHER\r\n            );\r\n          } else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        default:\r\n          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );\r\n      }\r\n    },\r\n    \r\n    timesMatrix: function( m ) {\r\n      // I * M === M * I === I (the identity)\r\n      if( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {\r\n        return this.type === Types.IDENTITY ? m : this;\r\n      }\r\n      \r\n      if ( this.type === m.type ) {\r\n        // currently two matrices of the same type will result in the same result type\r\n        if ( this.type === Types.TRANSLATION_2D ) {\r\n          // faster combination of translations\r\n          return new Matrix3( 1, 0, this.m02() + m.m02(),\r\n                              0, 1, this.m12() + m.m12(),\r\n                              0, 0, 1, Types.TRANSLATION_2D );\r\n        } else if ( this.type === Types.SCALING ) {\r\n          // faster combination of scaling\r\n          return new Matrix3( this.m00() * m.m00(), 0, 0,\r\n                              0, this.m11() * m.m11(), 0,\r\n                              0, 0, 1, Types.SCALING );\r\n        }\r\n      }\r\n      \r\n      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {\r\n        // currently two matrices that are anything but \"other\" are technically affine, and the result will be affine\r\n        \r\n        // affine case\r\n        return new Matrix3( this.m00() * m.m00() + this.m01() * m.m10(),\r\n                            this.m00() * m.m01() + this.m01() * m.m11(),\r\n                            this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),\r\n                            this.m10() * m.m00() + this.m11() * m.m10(),\r\n                            this.m10() * m.m01() + this.m11() * m.m11(),\r\n                            this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),\r\n                            0, 0, 1, Types.AFFINE );\r\n      }\r\n      \r\n      // general case\r\n      return new Matrix3( this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),\r\n                          this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),\r\n                          this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),\r\n                          this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),\r\n                          this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),\r\n                          this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),\r\n                          this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),\r\n                          this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),\r\n                          this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Immutable operations (returns new form of a parameter)\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    timesVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02();\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12();\r\n      return new dot.Vector2( x, y );\r\n    },\r\n    \r\n    timesVector3: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z;\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z;\r\n      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z;\r\n      return new dot.Vector3( x, y, z );\r\n    },\r\n    \r\n    timesTransposeVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y;\r\n      var y = this.m01() * v.x + this.m11() * v.y;\r\n      return new dot.Vector2( x, y );\r\n    },\r\n    \r\n    // TODO: this operation seems to not work for transformDelta2, should be vetted\r\n    timesRelativeVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y;\r\n      var y = this.m10() * v.y + this.m11() * v.y;\r\n      return new dot.Vector2( x, y );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Mutable operations (changes this matrix)\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    makeImmutable: function() {\r\n      this.rowMajor = function() {\r\n        throw new Error( 'Cannot modify immutable matrix' );\r\n      };\r\n      return this;\r\n    },\r\n    \r\n    rowMajor: function( v00, v01, v02, v10, v11, v12, v20, v21, v22, type ) {\r\n      this.entries[0] = v00;\r\n      this.entries[1] = v10;\r\n      this.entries[2] = v20;\r\n      this.entries[3] = v01;\r\n      this.entries[4] = v11;\r\n      this.entries[5] = v21;\r\n      this.entries[6] = v02;\r\n      this.entries[7] = v12;\r\n      this.entries[8] = v22;\r\n      \r\n      // TODO: consider performance of the affine check here\r\n      this.type = type === undefined ? ( ( v20 === 0 && v21 === 0 && v22 === 1 ) ? Types.AFFINE : Types.OTHER ) : type;\r\n      return this;\r\n    },\r\n    \r\n    columnMajor: function( v00, v10, v20, v01, v11, v21, v02, v12, v22, type ) {\r\n      return this.rowMajor( v00, v01, v02, v10, v11, v12, v20, v21, v22, type );\r\n    },\r\n    \r\n    add: function( m ) {\r\n      return this.rowMajor(\r\n        this.m00() + m.m00(), this.m01() + m.m01(), this.m02() + m.m02(),\r\n        this.m10() + m.m10(), this.m11() + m.m11(), this.m12() + m.m12(),\r\n        this.m20() + m.m20(), this.m21() + m.m21(), this.m22() + m.m22()\r\n      );\r\n    },\r\n    \r\n    subtract: function( m ) {\r\n      return this.rowMajor(\r\n        this.m00() - m.m00(), this.m01() - m.m01(), this.m02() - m.m02(),\r\n        this.m10() - m.m10(), this.m11() - m.m11(), this.m12() - m.m12(),\r\n        this.m20() - m.m20(), this.m21() - m.m21(), this.m22() - m.m22()\r\n      );\r\n    },\r\n    \r\n    transpose: function() {\r\n      return this.rowMajor(\r\n        this.m00(), this.m10(), this.m20(),\r\n        this.m01(), this.m11(), this.m21(),\r\n        this.m02(), this.m12(), this.m22(),\r\n        ( this.type === Types.IDENTITY || this.type === Types.SCALING ) ? this.type : undefined\r\n      );\r\n    },\r\n    \r\n    negate: function() {\r\n      return this.rowMajor(\r\n        -this.m00(), -this.m01(), -this.m02(),\r\n        -this.m10(), -this.m11(), -this.m12(),\r\n        -this.m20(), -this.m21(), -this.m22()\r\n      );\r\n    },\r\n    \r\n    invert: function() {\r\n      var det;\r\n      \r\n      switch ( this.type ) {\r\n        case Types.IDENTITY:\r\n          return this;\r\n        case Types.TRANSLATION_2D:\r\n          return this.rowMajor( 1, 0, -this.m02(),\r\n                                0, 1, -this.m12(),\r\n                                0, 0, 1, Types.TRANSLATION_2D );\r\n        case Types.SCALING:\r\n          return this.rowMajor( 1 / this.m00(), 0, 0,\r\n                                0, 1 / this.m11(), 0,\r\n                                0, 0, 1 / this.m22(), Types.SCALING );\r\n        case Types.AFFINE:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return this.rowMajor(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              0, 0, 1, Types.AFFINE\r\n            );\r\n          } else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        case Types.OTHER:\r\n          det = this.getDeterminant();\r\n          if ( det !== 0 ) {\r\n            return this.rowMajor(\r\n              ( -this.m12() * this.m21() + this.m11() * this.m22() ) / det,\r\n              ( this.m02() * this.m21() - this.m01() * this.m22() ) / det,\r\n              ( -this.m02() * this.m11() + this.m01() * this.m12() ) / det,\r\n              ( this.m12() * this.m20() - this.m10() * this.m22() ) / det,\r\n              ( -this.m02() * this.m20() + this.m00() * this.m22() ) / det,\r\n              ( this.m02() * this.m10() - this.m00() * this.m12() ) / det,\r\n              ( -this.m11() * this.m20() + this.m10() * this.m21() ) / det,\r\n              ( this.m01() * this.m20() - this.m00() * this.m21() ) / det,\r\n              ( -this.m01() * this.m10() + this.m00() * this.m11() ) / det,\r\n              Types.OTHER\r\n            );\r\n          } else {\r\n            throw new Error( 'Matrix could not be inverted, determinant === 0' );\r\n          }\r\n          break; // because JSHint totally can't tell that this can't be reached\r\n        default:\r\n          throw new Error( 'Matrix3.inverted with unknown type: ' + this.type );\r\n      }\r\n    },\r\n    \r\n    multiplyMatrix: function( m ) {\r\n      // I * M === M * I === I (the identity)\r\n      if( this.type === Types.IDENTITY || m.type === Types.IDENTITY ) {\r\n        return this.type === Types.IDENTITY ? m : this;\r\n      }\r\n      \r\n      if ( this.type === m.type ) {\r\n        // currently two matrices of the same type will result in the same result type\r\n        if ( this.type === Types.TRANSLATION_2D ) {\r\n          // faster combination of translations\r\n          return this.rowMajor( 1, 0, this.m02() + m.m02(),\r\n                                0, 1, this.m12() + m.m12(),\r\n                                0, 0, 1, Types.TRANSLATION_2D );\r\n        } else if ( this.type === Types.SCALING ) {\r\n          // faster combination of scaling\r\n          return this.rowMajor( this.m00() * m.m00(), 0, 0,\r\n                                0, this.m11() * m.m11(), 0,\r\n                                0, 0, 1, Types.SCALING );\r\n        }\r\n      }\r\n      \r\n      if ( this.type !== Types.OTHER && m.type !== Types.OTHER ) {\r\n        // currently two matrices that are anything but \"other\" are technically affine, and the result will be affine\r\n        \r\n        // affine case\r\n        return this.rowMajor( this.m00() * m.m00() + this.m01() * m.m10(),\r\n                              this.m00() * m.m01() + this.m01() * m.m11(),\r\n                              this.m00() * m.m02() + this.m01() * m.m12() + this.m02(),\r\n                              this.m10() * m.m00() + this.m11() * m.m10(),\r\n                              this.m10() * m.m01() + this.m11() * m.m11(),\r\n                              this.m10() * m.m02() + this.m11() * m.m12() + this.m12(),\r\n                              0, 0, 1, Types.AFFINE );\r\n      }\r\n      \r\n      // general case\r\n      return this.rowMajor( this.m00() * m.m00() + this.m01() * m.m10() + this.m02() * m.m20(),\r\n                            this.m00() * m.m01() + this.m01() * m.m11() + this.m02() * m.m21(),\r\n                            this.m00() * m.m02() + this.m01() * m.m12() + this.m02() * m.m22(),\r\n                            this.m10() * m.m00() + this.m11() * m.m10() + this.m12() * m.m20(),\r\n                            this.m10() * m.m01() + this.m11() * m.m11() + this.m12() * m.m21(),\r\n                            this.m10() * m.m02() + this.m11() * m.m12() + this.m12() * m.m22(),\r\n                            this.m20() * m.m00() + this.m21() * m.m10() + this.m22() * m.m20(),\r\n                            this.m20() * m.m01() + this.m21() * m.m11() + this.m22() * m.m21(),\r\n                            this.m20() * m.m02() + this.m21() * m.m12() + this.m22() * m.m22() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Mutable operations (changes the parameter)\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    multiplyVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02();\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12();\r\n      v.setX( x );\r\n      v.setY( y );\r\n      return v;\r\n    },\r\n    \r\n    multiplyVector3: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y + this.m02() * v.z;\r\n      var y = this.m10() * v.x + this.m11() * v.y + this.m12() * v.z;\r\n      var z = this.m20() * v.x + this.m21() * v.y + this.m22() * v.z;\r\n      v.setX( x );\r\n      v.setY( y );\r\n      v.setZ( z );\r\n      return v;\r\n    },\r\n    \r\n    multiplyTransposeVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m10() * v.y;\r\n      var y = this.m01() * v.x + this.m11() * v.y;\r\n      v.setX( x );\r\n      v.setY( y );\r\n      return v;\r\n    },\r\n    \r\n    multiplyRelativeVector2: function( v ) {\r\n      var x = this.m00() * v.x + this.m01() * v.y;\r\n      var y = this.m10() * v.y + this.m11() * v.y;\r\n      v.setX( x );\r\n      v.setY( y );\r\n      return v;\r\n    },\r\n    \r\n    // sets the transform of a Canvas 2D rendering context to the affine part of this matrix\r\n    canvasSetTransform: function( context ) {\r\n      context.setTransform(\r\n        // inlined array entries\r\n        this.entries[0],\r\n        this.entries[1],\r\n        this.entries[3],\r\n        this.entries[4],\r\n        this.entries[6],\r\n        this.entries[7]\r\n      );\r\n    },\r\n    \r\n    // appends the affine part of this matrix to the Canvas 2D rendering context\r\n    canvasAppendTransform: function( context ) {\r\n      if ( this.type !== Types.IDENTITY ) {\r\n        context.transform(\r\n          // inlined array entries\r\n          this.entries[0],\r\n          this.entries[1],\r\n          this.entries[3],\r\n          this.entries[4],\r\n          this.entries[6],\r\n          this.entries[7]\r\n        );\r\n      }\r\n    }\r\n  };\r\n\r\n  // create an immutable\r\n  Matrix3.IDENTITY = new Matrix3( 1, 0, 0,\r\n                                  0, 1, 0,\r\n                                  0, 0, 1,\r\n                                  Types.IDENTITY );\r\n  Matrix3.IDENTITY.makeImmutable();\r\n  \r\n  Matrix3.X_REFLECTION = new Matrix3( -1, 0, 0,\r\n                                       0, 1, 0,\r\n                                       0, 0, 1,\r\n                                       Types.AFFINE );\r\n  Matrix3.X_REFLECTION.makeImmutable();\r\n  \r\n  Matrix3.Y_REFLECTION = new Matrix3( 1,  0, 0,\r\n                                      0, -1, 0,\r\n                                      0,  0, 1,\r\n                                      Types.AFFINE );\r\n  Matrix3.Y_REFLECTION.makeImmutable();\r\n  \r\n  Matrix3.printer = {\r\n    print: function( matrix ) {\r\n      console.log( matrix.toString() );\r\n    }\r\n  };\r\n  \r\n  return Matrix3;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * 2-dimensional ray\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Ray2',['require','ASSERT/assert','DOT/dot'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n\r\n  dot.Ray2 = function Ray2( pos, dir ) {\r\n    this.pos = pos;\r\n    this.dir = dir;\r\n    \r\n    assert && assert( Math.abs( dir.magnitude() - 1 ) < 0.01 );\r\n  };\r\n  var Ray2 = dot.Ray2;\r\n\r\n  Ray2.prototype = {\r\n    constructor: Ray2,\r\n\r\n    shifted: function( distance ) {\r\n      return new Ray2( this.pointAtDistance( distance ), this.dir );\r\n    },\r\n\r\n    pointAtDistance: function( distance ) {\r\n      return this.pos.plus( this.dir.timesScalar( distance ) );\r\n    },\r\n\r\n    toString: function() {\r\n      return this.pos.toString() + \" => \" + this.dir.toString();\r\n    }\r\n  };\r\n  \r\n  return Ray2;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Forward and inverse transforms with 3x3 matrices\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Transform3',['require','ASSERT/assert','DOT/dot','DOT/Matrix3','DOT/Vector2','DOT/Ray2'],function( require ) {\r\n  'use strict';\r\n\r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Matrix3' );\r\n  require( 'DOT/Vector2' );\r\n  require( 'DOT/Ray2' );\r\n\r\n  // takes a 4x4 matrix\r\n  dot.Transform3 = function Transform3( matrix ) {\r\n    this.listeners = [];\r\n    \r\n    // using immutable version for now. change it to the mutable identity copy if we need mutable operations on the matrices\r\n    this.set( matrix === undefined ? dot.Matrix3.IDENTITY : matrix );\r\n  };\r\n  var Transform3 = dot.Transform3;\r\n\r\n  Transform3.prototype = {\r\n    constructor: Transform3,\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * mutators\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    set: function( matrix ) {\r\n      // TODO: performance: don't notify or handle instances where the matrix is detected to be the identity matrix?\r\n      assert && assert( matrix instanceof dot.Matrix3 );\r\n      \r\n      var oldMatrix = this.matrix;\r\n      var length = this.listeners.length;\r\n      var i;\r\n      \r\n      // notify listeners before the change\r\n      for ( i = 0; i < length; i++ ) {\r\n        this.listeners[i].before( matrix, oldMatrix );\r\n      }\r\n      \r\n      this.matrix = matrix;\r\n      \r\n      // compute these lazily\r\n      this.inverse = null;\r\n      this.matrixTransposed = null;\r\n      this.inverseTransposed = null;\r\n      \r\n      // notify listeners after the change\r\n      for ( i = 0; i < length; i++ ) {\r\n        this.listeners[i].after( matrix, oldMatrix );\r\n      }\r\n    },\r\n    \r\n    prepend: function( matrix ) {\r\n      this.set( matrix.timesMatrix( this.matrix ) );\r\n    },\r\n\r\n    append: function( matrix ) {\r\n      this.set( this.matrix.timesMatrix( matrix ) );\r\n    },\r\n\r\n    prependTransform: function( transform ) {\r\n      this.prepend( transform.matrix );\r\n    },\r\n\r\n    appendTransform: function( transform ) {\r\n      this.append( transform.matrix );\r\n    },\r\n\r\n    applyToCanvasContext: function( context ) {\r\n      context.setTransform( this.matrix.m00(), this.matrix.m10(), this.matrix.m01(), this.matrix.m11(), this.matrix.m02(), this.matrix.m12() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * getters\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // uses the same matrices, for use cases where the matrices are considered immutable\r\n    copy: function() {\r\n      var transform = new Transform3( this.matrix );\r\n      transform.inverse = this.inverse;\r\n      transform.matrixTransposed = this.matrixTransposed;\r\n      transform.inverseTransposed = this.inverseTransposed;\r\n    },\r\n    \r\n    // copies matrices, for use cases where the matrices are considered mutable\r\n    deepCopy: function() {\r\n      var transform = new Transform3( this.matrix.copy() );\r\n      transform.inverse = this.inverse ? this.inverse.copy() : null;\r\n      transform.matrixTransposed = this.matrixTransposed ? this.matrixTransposed.copy() : null;\r\n      transform.inverseTransposed = this.inverseTransposed ? this.inverseTransposed.copy() : null;\r\n    },\r\n    \r\n    getMatrix: function() {\r\n      return this.matrix;\r\n    },\r\n    \r\n    getInverse: function() {\r\n      if ( this.inverse === null ) {\r\n        this.inverse = this.matrix.inverted();\r\n      }\r\n      return this.inverse;\r\n    },\r\n    \r\n    getMatrixTransposed: function() {\r\n      if ( this.matrixTransposed === null ) {\r\n        this.matrixTransposed = this.matrix.transposed();\r\n      }\r\n      return this.matrixTransposed;\r\n    },\r\n    \r\n    getInverseTransposed: function() {\r\n      if ( this.inverseTransposed === null ) {\r\n        this.inverseTransposed = this.getInverse().transposed();\r\n      }\r\n      return this.inverseTransposed;\r\n    },\r\n    \r\n    isIdentity: function() {\r\n      return this.matrix.type === dot.Matrix3.Types.IDENTITY;\r\n    },\r\n    \r\n    isFinite: function() {\r\n      return this.matrix.isFinite();\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * forward transforms (for Vector2 or scalar)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    // transform a position (includes translation)\r\n    transformPosition2: function( vec2 ) {\r\n      return this.matrix.timesVector2( vec2 );\r\n    },\r\n\r\n    // transform a vector (exclude translation)\r\n    transformDelta2: function( vec2 ) {\r\n      // transform actually has the translation rolled into the other coefficients, so we have to make this longer\r\n      return this.transformPosition2( vec2 ).minus( this.transformPosition2( dot.Vector2.ZERO ) );\r\n    },\r\n\r\n    // transform a normal vector (different than a normal vector)\r\n    transformNormal2: function( vec2 ) {\r\n      return this.getInverse().timesTransposeVector2( vec2 );\r\n    },\r\n\r\n    transformDeltaX: function( x ) {\r\n      return this.transformDelta2( new dot.Vector2( x, 0 ) ).x;\r\n    },\r\n\r\n    transformDeltaY: function( y ) {\r\n      return this.transformDelta2( new dot.Vector2( 0, y ) ).y;\r\n    },\r\n    \r\n    transformBounds2: function( bounds2 ) {\r\n      return bounds2.transformed( this.matrix );\r\n    },\r\n    \r\n    transformShape: function( shape ) {\r\n      return shape.transformed( this.matrix );\r\n    },\r\n    \r\n    transformRay2: function( ray ) {\r\n      return new dot.Ray2( this.transformPosition2( ray.pos ), this.transformDelta2( ray.dir ).normalized() );\r\n    },\r\n\r\n    /*---------------------------------------------------------------------------*\r\n     * inverse transforms (for Vector2 or scalar)\r\n     *----------------------------------------------------------------------------*/\r\n\r\n    inversePosition2: function( vec2 ) {\r\n      return this.getInverse().timesVector2( vec2 );\r\n    },\r\n\r\n    inverseDelta2: function( vec2 ) {\r\n      // inverse actually has the translation rolled into the other coefficients, so we have to make this longer\r\n      return this.inversePosition2( vec2 ).minus( this.inversePosition2( dot.Vector2.ZERO ) );\r\n    },\r\n\r\n    inverseNormal2: function( vec2 ) {\r\n      return this.matrix.timesTransposeVector2( vec2 );\r\n    },\r\n\r\n    inverseDeltaX: function( x ) {\r\n      return this.inverseDelta2( new dot.Vector2( x, 0 ) ).x;\r\n    },\r\n\r\n    inverseDeltaY: function( y ) {\r\n      return this.inverseDelta2( new dot.Vector2( 0, y ) ).y;\r\n    },\r\n    \r\n    inverseBounds2: function( bounds2 ) {\r\n      return bounds2.transformed( this.getInverse() );\r\n    },\r\n    \r\n    inverseShape: function( shape ) {\r\n      return shape.transformed( this.getInverse() );\r\n    },\r\n    \r\n    inverseRay2: function( ray ) {\r\n      return new dot.Ray2( this.inversePosition2( ray.pos ), this.inverseDelta2( ray.dir ).normalized() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * listeners\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // note: listener.before( matrix, oldMatrix ) will be called before the change, listener.after( matrix, oldMatrix ) will be called after\r\n    addTransformListener: function( listener ) {\r\n      assert && assert( !_.contains( this.listeners, listener ) );\r\n      this.listeners.push( listener );\r\n    },\r\n    \r\n    // useful for making sure the listener is triggered first\r\n    prependTransformListener: function( listener ) {\r\n      assert && assert( !_.contains( this.listeners, listener ) );\r\n      this.listeners.unshift( listener );\r\n    },\r\n    \r\n    removeTransformListener: function( listener ) {\r\n      assert && assert( _.contains( this.listeners, listener ) );\r\n      this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );\r\n    }\r\n  };\r\n  \r\n  return Transform3;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * A 2D rectangle-shaped bounded area (bounding box)\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'DOT/Bounds2',['require','ASSERT/assert','DOT/dot','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'dot' );\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  require( 'DOT/Vector2' );\r\n  \r\n  // not using x,y,width,height so that it can handle infinity-based cases in a better way\r\n  dot.Bounds2 = function Bounds2( minX, minY, maxX, maxY ) {\r\n    assert && assert( maxY !== undefined, 'Bounds2 requires 4 parameters' );\r\n    this.minX = minX;\r\n    this.minY = minY;\r\n    this.maxX = maxX;\r\n    this.maxY = maxY;\r\n  };\r\n  var Bounds2 = dot.Bounds2;\r\n\r\n  Bounds2.prototype = {\r\n    constructor: Bounds2,\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Properties\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    getWidth: function() { return this.maxX - this.minX; },\r\n    get width() { return this.getWidth(); },\r\n    \r\n    getHeight: function() { return this.maxY - this.minY; },\r\n    get height() { return this.getHeight(); },\r\n    \r\n    getX: function() { return this.minX; },\r\n    get x() { return this.getX(); },\r\n    \r\n    getY: function() { return this.minY; },\r\n    get y() { return this.getY(); },\r\n    \r\n    getCenter: function() { return new dot.Vector2( this.getCenterX(), this.getCenterY() ); },\r\n    get center() { return this.getCenter(); },\r\n    \r\n    getCenterX: function() { return ( this.maxX + this.minX ) / 2; },\r\n    get centerX() { return this.getCenterX(); },\r\n    \r\n    getCenterY: function() { return ( this.maxY + this.minY ) / 2; },\r\n    get centerY() { return this.getCenterY(); },\r\n    \r\n    getMinX: function() { return this.minX; },\r\n    getMinY: function() { return this.minY; },\r\n    getMaxX: function() { return this.maxX; },\r\n    getMaxY: function() { return this.maxY; },\r\n    \r\n    isEmpty: function() { return this.getWidth() < 0 || this.getHeight() < 0; },\r\n    \r\n    isFinite: function() {\r\n      return isFinite( this.minX ) && isFinite( this.minY ) && isFinite( this.maxX ) && isFinite( this.maxY );\r\n    },\r\n    \r\n    isValid: function() {\r\n      return !this.isEmpty() && this.isFinite();\r\n    },\r\n    \r\n    // whether the coordinates are inside the bounding box (or on the boundary)\r\n    containsCoordinates: function( x, y ) {\r\n      return this.minX <= x && x <= this.maxX && this.minY <= y && y <= this.maxY;\r\n    },\r\n    \r\n    // whether the point is inside the bounding box (or on the boundary)\r\n    containsPoint: function( point ) {\r\n      return this.containsCoordinates( point.x, point.y );\r\n    },\r\n    \r\n    // whether this bounding box completely contains the argument bounding box\r\n    containsBounds: function( bounds ) {\r\n      return this.minX <= bounds.minX && this.maxX >= bounds.maxX && this.minY <= bounds.minY && this.maxY >= bounds.maxY;\r\n    },\r\n    \r\n    // whether the intersection is non-empty (if they share any part of a boundary, this will be true)\r\n    intersectsBounds: function( bounds ) {\r\n      // TODO: more efficient way of doing this?\r\n      return !this.intersection( bounds ).isEmpty();\r\n    },\r\n    \r\n    toString: function() {\r\n      return '[x:(' + this.minX + ',' + this.maxX + '),y:(' + this.minY + ',' + this.maxY + ')]';\r\n    },\r\n    \r\n    equals: function( other ) {\r\n      return this.minX === other.minX && this.minY === other.minY && this.maxX === other.maxX && this.maxY === other.maxY;\r\n    },\r\n    \r\n    equalsEpsilon: function( other, epsilon ) {\r\n      epsilon = epsilon || 0;\r\n      var thisFinite = this.isFinite();\r\n      var otherFinite = other.isFinite();\r\n      if ( thisFinite && otherFinite ) {\r\n        // both are finite, so we can use Math.abs() - it would fail with non-finite values like Infinity\r\n        return Math.abs( this.minX - other.minX ) < epsilon &&\r\n               Math.abs( this.minY - other.minY ) < epsilon &&\r\n               Math.abs( this.maxX - other.maxX ) < epsilon &&\r\n               Math.abs( this.maxY - other.maxY ) < epsilon;\r\n      } else if ( thisFinite !== otherFinite ) {\r\n        return false; // one is finite, the other is not. definitely not equal\r\n      } else if ( this === other ) {\r\n        return true; // exact same instance, must be equal\r\n      } else {\r\n        // epsilon only applies on finite dimensions. due to JS's handling of isFinite(), it's faster to check the sum of both\r\n        return ( isFinite( this.minX + other.minX ) ? ( Math.abs( this.minX - other.minX ) < epsilon ) : ( this.minX === other.minX ) ) &&\r\n               ( isFinite( this.minY + other.minY ) ? ( Math.abs( this.minY - other.minY ) < epsilon ) : ( this.minY === other.minY ) ) &&\r\n               ( isFinite( this.maxX + other.maxX ) ? ( Math.abs( this.maxX - other.maxX ) < epsilon ) : ( this.maxX === other.maxX ) ) &&\r\n               ( isFinite( this.maxY + other.maxY ) ? ( Math.abs( this.maxY - other.maxY ) < epsilon ) : ( this.maxY === other.maxY ) );\r\n      }\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Immutable operations\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    copy: function() {\r\n      return new Bounds2( this.minX, this.minY, this.maxX, this.maxY );\r\n    },\r\n    \r\n    // immutable operations (bounding-box style handling, so that the relevant bounds contain everything)\r\n    union: function( bounds ) {\r\n      return new Bounds2(\r\n        Math.min( this.minX, bounds.minX ),\r\n        Math.min( this.minY, bounds.minY ),\r\n        Math.max( this.maxX, bounds.maxX ),\r\n        Math.max( this.maxY, bounds.maxY )\r\n      );\r\n    },\r\n    intersection: function( bounds ) {\r\n      return new Bounds2(\r\n        Math.max( this.minX, bounds.minX ),\r\n        Math.max( this.minY, bounds.minY ),\r\n        Math.min( this.maxX, bounds.maxX ),\r\n        Math.min( this.maxY, bounds.maxY )\r\n      );\r\n    },\r\n    // TODO: difference should be well-defined, but more logic is needed to compute\r\n    \r\n    withCoordinates: function( x, y ) {\r\n      return new Bounds2(\r\n        Math.min( this.minX, x ),\r\n        Math.min( this.minY, y ),\r\n        Math.max( this.maxX, x ),\r\n        Math.max( this.maxY, y )\r\n      );\r\n    },\r\n    \r\n    // like a union with a point-sized bounding box\r\n    withPoint: function( point ) {\r\n      return this.withCoordinates( point.x, point.y );\r\n    },\r\n    \r\n    withMinX: function( minX ) { return new Bounds2( minX, this.minY, this.maxX, this.maxY ); },\r\n    withMinY: function( minY ) { return new Bounds2( this.minX, minY, this.maxX, this.maxY ); },\r\n    withMaxX: function( maxX ) { return new Bounds2( this.minX, this.minY, maxX, this.maxY ); },\r\n    withMaxY: function( maxY ) { return new Bounds2( this.minX, this.minY, this.maxX, maxY ); },\r\n    \r\n    // copy rounded to integral values, expanding where necessary\r\n    roundedOut: function() {\r\n      return new Bounds2(\r\n        Math.floor( this.minX ),\r\n        Math.floor( this.minY ),\r\n        Math.ceil( this.maxX ),\r\n        Math.ceil( this.maxY )\r\n      );\r\n    },\r\n    \r\n    // copy rounded to integral values, contracting where necessary\r\n    roundedIn: function() {\r\n      return new Bounds2(\r\n        Math.ceil( this.minX ),\r\n        Math.ceil( this.minY ),\r\n        Math.floor( this.maxX ),\r\n        Math.floor( this.maxY )\r\n      );\r\n    },\r\n    \r\n    // transform a bounding box.\r\n    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box\r\n    transformed: function( matrix ) {\r\n      return this.copy().transform( matrix );\r\n    },\r\n    \r\n    // returns copy expanded on all sides by length d\r\n    dilated: function( d ) {\r\n      return new Bounds2( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );\r\n    },\r\n    \r\n    // returns copy contracted on all sides by length d\r\n    eroded: function( d ) {\r\n      return this.dilated( -d );\r\n    },\r\n    \r\n    shiftedX: function( x ) {\r\n      return new Bounds2( this.minX + x, this.minY, this.maxX + x, this.maxY );\r\n    },\r\n    \r\n    shiftedY: function( y ) {\r\n      return new Bounds2( this.minX, this.minY + y, this.maxX, this.maxY + y );\r\n    },\r\n    \r\n    shifted: function( x, y ) {\r\n      return new Bounds2( this.minX + x, this.minY + y, this.maxX + x, this.maxY + y );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Mutable operations\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    set: function( minX, minY, maxX, maxY ) {\r\n      this.minX = minX;\r\n      this.minY = minY;\r\n      this.maxX = maxX;\r\n      this.maxY = maxY;\r\n      return this;\r\n    },\r\n    \r\n    setBounds: function( bounds ) {\r\n      return this.set( bounds.minX, bounds.minY, bounds.maxX, bounds.maxY );\r\n    },\r\n    \r\n    // mutable union\r\n    includeBounds: function( bounds ) {\r\n      this.minX = Math.min( this.minX, bounds.minX );\r\n      this.minY = Math.min( this.minY, bounds.minY );\r\n      this.maxX = Math.max( this.maxX, bounds.maxX );\r\n      this.maxY = Math.max( this.maxY, bounds.maxY );\r\n      return this;\r\n    },\r\n    \r\n    // mutable intersection\r\n    constrainBounds: function( bounds ) {\r\n      this.minX = Math.max( this.minX, bounds.minX );\r\n      this.minY = Math.max( this.minY, bounds.minY );\r\n      this.maxX = Math.min( this.maxX, bounds.maxX );\r\n      this.maxY = Math.min( this.maxY, bounds.maxY );\r\n      return this;\r\n    },\r\n    \r\n    addCoordinates: function( x, y ) {\r\n      this.minX = Math.min( this.minX, x );\r\n      this.minY = Math.min( this.minY, y );\r\n      this.maxX = Math.max( this.maxX, x );\r\n      this.maxY = Math.max( this.maxY, y );\r\n      return this;\r\n    },\r\n    \r\n    addPoint: function( point ) {\r\n      return this.addCoordinates( point.x, point.y );\r\n    },\r\n    \r\n    setMinX: function( minX ) { this.minX = minX; return this; },\r\n    setMinY: function( minY ) { this.minY = minY; return this; },\r\n    setMaxX: function( maxX ) { this.maxX = maxX; return this; },\r\n    setMaxY: function( maxY ) { this.maxY = maxY; return this; },\r\n    \r\n    // round to integral values, expanding where necessary\r\n    roundOut: function() {\r\n      this.minX = Math.floor( this.minX );\r\n      this.minY = Math.floor( this.minY );\r\n      this.maxX = Math.ceil( this.maxX );\r\n      this.maxY = Math.ceil( this.maxY );\r\n      return this;\r\n    },\r\n    \r\n    // round to integral values, contracting where necessary\r\n    roundIn: function() {\r\n      this.minX = Math.ceil( this.minX );\r\n      this.minY = Math.ceil( this.minY );\r\n      this.maxX = Math.floor( this.maxX );\r\n      this.maxY = Math.floor( this.maxY );\r\n      return this;\r\n    },\r\n    \r\n    // transform a bounding box.\r\n    // NOTE that box.transformed( matrix ).transformed( inverse ) may be larger than the original box\r\n    transform: function( matrix ) {\r\n      // do nothing\r\n      if ( this.isEmpty() ) {\r\n        return this;\r\n      }\r\n      var minX = this.minX;\r\n      var minY = this.minY;\r\n      var maxX = this.maxX;\r\n      var maxY = this.maxY;\r\n      \r\n      // using mutable vector so we don't create excessive instances of Vector2 during this\r\n      // make sure all 4 corners are inside this transformed bounding box\r\n      var vector = new dot.Vector2();\r\n      this.setBounds( Bounds2.NOTHING );\r\n      this.addPoint( matrix.multiplyVector2( vector.set( minX, minY ) ) );\r\n      this.addPoint( matrix.multiplyVector2( vector.set( minX, maxY ) ) );\r\n      this.addPoint( matrix.multiplyVector2( vector.set( maxX, minY ) ) );\r\n      this.addPoint( matrix.multiplyVector2( vector.set( maxX, maxY ) ) );\r\n      return this;\r\n    },\r\n    \r\n    // expands on all sides by length d\r\n    dilate: function( d ) {\r\n      return this.set( this.minX - d, this.minY - d, this.maxX + d, this.maxY + d );\r\n    },\r\n    \r\n    // contracts on all sides by length d\r\n    erode: function( d ) {\r\n      return this.dilate( -d );\r\n    },\r\n    \r\n    shiftX: function( x ) {\r\n      return this.setMinX( this.minX + x ).setMaxX( this.maxX + x );\r\n    },\r\n    \r\n    shiftY: function( y ) {\r\n      return this.setMinY( this.minY + y ).setMaxY( this.maxY + y );\r\n    },\r\n    \r\n    shift: function( x, y ) {\r\n      return this.shiftX( x ).shiftY( y );\r\n    }\r\n  };\r\n  \r\n  Bounds2.rect = function( x, y, width, height ) {\r\n    return new Bounds2( x, y, x + width, y + height );\r\n  };\r\n  \r\n  // specific bounds useful for operations\r\n  Bounds2.EVERYTHING = new Bounds2( Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY );\r\n  Bounds2.NOTHING = new Bounds2( Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY );\r\n  \r\n  return Bounds2;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * General utility functions for Scenery\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/Util',['require','SCENERY/scenery','DOT/Matrix3','DOT/Transform3','DOT/Bounds2','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  \r\n  // convenience function\r\n  function p( x, y ) {\r\n    return new Vector2( x, y );\r\n  }\r\n  \r\n  // TODO: remove flag and tests after we're done\r\n  var debugChromeBoundsScanning = false;\r\n  \r\n  // detect properly prefixed transform and transformOrigin properties\r\n  var transformProperty = '';\r\n  var transformOriginProperty = '';\r\n  var webkitHardwareAcceleration = false;\r\n  var mozillaHardwareAcceleration = false;\r\n  if ( document && document.createElement ) {\r\n    var style = document.createElement( 'div' ).style;\r\n    \r\n    var transformNames = [\r\n      'transform',\r\n      'webkitTransform',\r\n      'oTransform',\r\n      'mozTransform',\r\n      'msTransform'\r\n    ];\r\n    var transformOriginNames = [\r\n      'transformOrigin',\r\n      'webkitTransformOrigin',\r\n      'oTransformOrigin',\r\n      'mozTransformOrigin',\r\n      'msTransformOrigin'\r\n    ];\r\n    \r\n    var i;\r\n    \r\n    for ( i = 0; i < transformNames.length; i++ ) {\r\n      if ( transformNames[i] in style ) {\r\n        transformProperty = transformNames[i];\r\n        break;\r\n      }\r\n    }\r\n    for ( i = 0; i < transformOriginNames.length; i++ ) {\r\n      if ( transformOriginNames[i] in style ) {\r\n        transformOriginProperty = transformOriginNames[i];\r\n        break;\r\n      }\r\n    }\r\n    if ( !transformOriginProperty ) {\r\n      transformOriginProperty = 'transformOrigin'; // fallback, so we don't try to set an empty string property later\r\n    }\r\n    if ( ( 'webkitBackfaceVisibility' in style ) || ( 'webkitTransform' in style ) ) {\r\n      webkitHardwareAcceleration = true;\r\n    }\r\n    if ( 'mozTransform' in style ) {\r\n      mozillaHardwareAcceleration = true;\r\n    }\r\n  }\r\n  \r\n  scenery.Util = {\r\n    // like _.extend, but with hardcoded support for https://github.com/documentcloud/underscore/pull/986\r\n    extend: function( obj ) {\r\n      _.each( Array.prototype.slice.call( arguments, 1 ), function( source ) {\r\n        if ( source ) {\r\n          for ( var prop in source ) {\r\n            Object.defineProperty( obj, prop, Object.getOwnPropertyDescriptor( source, prop ) );\r\n          }\r\n        }\r\n      });\r\n      return obj;\r\n    },\r\n    \r\n    // Object.create polyfill\r\n    objectCreate: Object.create || function ( o ) {\r\n      if ( arguments.length > 1 ) {\r\n        throw new Error( 'Object.create implementation only accepts the first parameter.' );\r\n      }\r\n      function F() {}\r\n\r\n      F.prototype = o;\r\n      return new F();\r\n    },\r\n    \r\n    applyCSSTransform: function( matrix, element ) {\r\n      var transformCSS = matrix.getCSSTransform();\r\n      // notes on triggering hardware acceleration: http://creativejs.com/2011/12/day-2-gpu-accelerate-your-dom-elements/\r\n      // TODO: consider leaving out on iOS if possible, since we might be overflowing the GPU memory\r\n      \r\n      // TODO: we may want control over this flag\r\n      if ( webkitHardwareAcceleration || mozillaHardwareAcceleration ) {\r\n        transformCSS += ' translateZ(0)';\r\n      }\r\n      \r\n      if ( webkitHardwareAcceleration ) {\r\n        // TODO: find out bug that causes BLL text to disappear unless this acceleration is present\r\n        element.style.webkitBackfaceVisibility = 'hidden';\r\n      }\r\n      \r\n      element.style[transformProperty] = transformCSS;\r\n      element.style[transformOriginProperty] = 'top left'; // TODO: performance: this only needs to be set once!\r\n    },\r\n    \r\n    testAssert: function() {\r\n      return 'assert.scenery: ' + ( sceneryAssert ? 'true' : 'false' );\r\n    },\r\n    \r\n    testAssertExtra: function() {\r\n      return 'assert.scenery.extra: ' + ( sceneryAssertExtra ? 'true' : 'false' );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n     * window.requestAnimationFrame polyfill, by Erik Moller (http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating)\r\n     * referenced by initial Paul Irish article at http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n     *----------------------------------------------------------------------------*/\r\n    polyfillRequestAnimationFrame: function() {\r\n      var lastTime = 0;\r\n      var vendors = [ 'ms', 'moz', 'webkit', 'o' ];\r\n      for ( var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x ) {\r\n        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];\r\n        window.cancelAnimationFrame = window[vendors[x]+'CancelAnimationFrame'] || window[vendors[x]+'CancelRequestAnimationFrame'];\r\n      }\r\n     \r\n      if ( !window.requestAnimationFrame ) {\r\n        window.requestAnimationFrame = function(callback) {\r\n          var currTime = new Date().getTime();\r\n          var timeToCall = Math.max(0, 16 - (currTime - lastTime));\r\n          var id = window.setTimeout(function() { callback(currTime + timeToCall); },\r\n            timeToCall);\r\n          lastTime = currTime + timeToCall;\r\n          return id;\r\n        };\r\n      }\r\n     \r\n      if ( !window.cancelAnimationFrame ) {\r\n        window.cancelAnimationFrame = function(id) {\r\n          clearTimeout(id);\r\n        };\r\n      }\r\n    },\r\n    \r\n    backingStorePixelRatio: function( context ) {\r\n      return context.webkitBackingStorePixelRatio ||\r\n             context.mozBackingStorePixelRatio ||\r\n             context.msBackingStorePixelRatio ||\r\n             context.oBackingStorePixelRatio ||\r\n             context.backingStorePixelRatio || 1;\r\n    },\r\n    \r\n    // see http://developer.apple.com/library/safari/#documentation/AudioVideo/Conceptual/HTML-canvas-guide/SettingUptheCanvas/SettingUptheCanvas.html#//apple_ref/doc/uid/TP40010542-CH2-SW5\r\n    // and updated based on http://www.html5rocks.com/en/tutorials/canvas/hidpi/\r\n    backingScale: function ( context ) {\r\n      if ( 'devicePixelRatio' in window ) {\r\n        var backingStoreRatio = Util.backingStorePixelRatio( context );\r\n        \r\n        return window.devicePixelRatio / backingStoreRatio;\r\n      }\r\n      return 1;\r\n    },\r\n    \r\n    // given a data snapshot and transform, calculate range on how large / small the bounds can be\r\n    // very conservative, with an effective 1px extra range to allow for differences in anti-aliasing\r\n    // for performance concerns, this does not support skews / rotations / anything but translation and scaling\r\n    scanBounds: function( imageData, resolution, transform ) {\r\n      \r\n      // entry will be true if any pixel with the given x or y value is non-rgba(0,0,0,0)\r\n      var dirtyX = _.map( _.range( resolution ), function() { return false; } );\r\n      var dirtyY = _.map( _.range( resolution ), function() { return false; } );\r\n      \r\n      for ( var x = 0; x < resolution; x++ ) {\r\n        for ( var y = 0; y < resolution; y++ ) {\r\n          var offset = 4 * ( y * resolution + x );\r\n          if ( imageData.data[offset] !== 0 || imageData.data[offset+1] !== 0 || imageData.data[offset+2] !== 0 || imageData.data[offset+3] !== 0 ) {\r\n            dirtyX[x] = true;\r\n            dirtyY[y] = true;\r\n          }\r\n        }\r\n      }\r\n      \r\n      var minX = _.indexOf( dirtyX, true );\r\n      var maxX = _.lastIndexOf( dirtyX, true );\r\n      var minY = _.indexOf( dirtyY, true );\r\n      var maxY = _.lastIndexOf( dirtyY, true );\r\n      \r\n      // based on pixel boundaries. for minBounds, the inner edge of the dirty pixel. for maxBounds, the outer edge of the adjacent non-dirty pixel\r\n      // results in a spread of 2 for the identity transform (or any translated form)\r\n      var extraSpread = resolution / 16; // is Chrome antialiasing really like this? dear god... TODO!!!\r\n      return {\r\n        minBounds: new Bounds2(\r\n          ( minX < 1 || minX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( minX + 1 + extraSpread, 0 ) ).x,\r\n          ( minY < 1 || minY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, minY + 1 + extraSpread ) ).y,\r\n          ( maxX < 1 || maxX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( maxX - extraSpread, 0 ) ).x,\r\n          ( maxY < 1 || maxY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, maxY - extraSpread ) ).y\r\n        ),\r\n        maxBounds: new Bounds2(\r\n          ( minX < 1 || minX >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( minX - 1 - extraSpread, 0 ) ).x,\r\n          ( minY < 1 || minY >= resolution - 1 ) ? Number.NEGATIVE_INFINITY : transform.inversePosition2( p( 0, minY - 1 - extraSpread ) ).y,\r\n          ( maxX < 1 || maxX >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( maxX + 2 + extraSpread, 0 ) ).x,\r\n          ( maxY < 1 || maxY >= resolution - 1 ) ? Number.POSITIVE_INFINITY : transform.inversePosition2( p( 0, maxY + 2 + extraSpread ) ).y\r\n        )\r\n      };\r\n    },\r\n    \r\n    canvasAccurateBounds: function( renderToContext, options ) {\r\n      // how close to the actual bounds do we need to be?\r\n      var precision = ( options && options.precision ) ? options.precision : 0.001;\r\n      \r\n      // 512x512 default square resolution\r\n      var resolution = ( options && options.resolution ) ? options.resolution : 128;\r\n      \r\n      // at 1/16x default, we want to be able to get the bounds accurately for something as large as 16x our initial resolution\r\n      // divisible by 2 so hopefully we avoid more quirks from Canvas rendering engines\r\n      var initialScale = ( options && options.initialScale ) ? options.initialScale : (1/16);\r\n      \r\n      var minBounds = Bounds2.NOTHING;\r\n      var maxBounds = Bounds2.EVERYTHING;\r\n      \r\n      var canvas = document.createElement( 'canvas' );\r\n      canvas.width = resolution;\r\n      canvas.height = resolution;\r\n      var context = canvas.getContext( '2d' );\r\n      \r\n      if ( debugChromeBoundsScanning ) {\r\n        $( window ).ready( function() {\r\n          var header = document.createElement( 'h2' );\r\n          $( header ).text( 'Bounds Scan' );\r\n          $( '#display' ).append( header );\r\n        } );\r\n      }\r\n      \r\n      function scan( transform ) {\r\n        // save/restore, in case the render tries to do any funny stuff like clipping, etc.\r\n        context.save();\r\n        transform.matrix.canvasSetTransform( context );\r\n        renderToContext( context );\r\n        context.restore();\r\n        \r\n        var data = context.getImageData( 0, 0, resolution, resolution );\r\n        var minMaxBounds = Util.scanBounds( data, resolution, transform );\r\n        \r\n        function snapshotToCanvas( snapshot ) {\r\n            var canvas = document.createElement( 'canvas' );\r\n            canvas.width = resolution;\r\n            canvas.height = resolution;\r\n            var context = canvas.getContext( '2d' );\r\n            context.putImageData( snapshot, 0, 0 );\r\n            $( canvas ).css( 'border', '1px solid black' );\r\n            $( window ).ready( function() {\r\n              //$( '#display' ).append( $( document.createElement( 'div' ) ).text( 'Bounds: ' +  ) );\r\n              $( '#display' ).append( canvas );\r\n            } );\r\n          }\r\n        \r\n        // TODO: remove after debug\r\n        if ( debugChromeBoundsScanning ) {\r\n          snapshotToCanvas( data );\r\n        }\r\n        \r\n        context.clearRect( 0, 0, resolution, resolution );\r\n        \r\n        return minMaxBounds;\r\n      }\r\n      \r\n      // attempts to map the bounds specified to the entire testing canvas (minus a fine border), so we can nail down the location quickly\r\n      function idealTransform( bounds ) {\r\n        // so that the bounds-edge doesn't land squarely on the boundary\r\n        var borderSize = 2;\r\n        \r\n        var scaleX = ( resolution - borderSize * 2 ) / ( bounds.maxX - bounds.minX );\r\n        var scaleY = ( resolution - borderSize * 2 ) / ( bounds.maxY - bounds.minY );\r\n        var translationX = -scaleX * bounds.minX + borderSize;\r\n        var translationY = -scaleY * bounds.minY + borderSize;\r\n        \r\n        return new Transform3( Matrix3.translation( translationX, translationY ).timesMatrix( Matrix3.scaling( scaleX, scaleY ) ) );\r\n      }\r\n      \r\n      var initialTransform = new Transform3( );\r\n      // make sure to initially center our object, so we don't miss the bounds\r\n      initialTransform.append( Matrix3.translation( resolution / 2, resolution / 2 ) );\r\n      initialTransform.append( Matrix3.scaling( initialScale ) );\r\n      \r\n      var coarseBounds = scan( initialTransform );\r\n      \r\n      minBounds = minBounds.union( coarseBounds.minBounds );\r\n      maxBounds = maxBounds.intersection( coarseBounds.maxBounds );\r\n      \r\n      var tempMin, tempMax, refinedBounds;\r\n      \r\n      // minX\r\n      tempMin = maxBounds.minY;\r\n      tempMax = maxBounds.maxY;\r\n      while ( isFinite( minBounds.minX ) && isFinite( maxBounds.minX ) && Math.abs( minBounds.minX - maxBounds.minX ) > precision ) {\r\n        // use maximum bounds except for the x direction, so we don't miss things that we are looking for\r\n        refinedBounds = scan( idealTransform( new Bounds2( maxBounds.minX, tempMin, minBounds.minX, tempMax ) ) );\r\n        \r\n        if ( minBounds.minX <= refinedBounds.minBounds.minX && maxBounds.minX >= refinedBounds.maxBounds.minX ) {\r\n          // sanity check - break out of an infinite loop!\r\n          if ( debugChromeBoundsScanning ) {\r\n            console.log( 'warning, exiting infinite loop!' );\r\n            console.log( 'transformed \"min\" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( minBounds.minX, 0 ) ) );\r\n            console.log( 'transformed \"max\" minX: ' + idealTransform( new Bounds2( maxBounds.minX, maxBounds.minY, minBounds.minX, maxBounds.maxY ) ).transformPosition2( p( maxBounds.minX, 0 ) ) );\r\n          }\r\n          break;\r\n        }\r\n        \r\n        minBounds = minBounds.withMinX( Math.min( minBounds.minX, refinedBounds.minBounds.minX ) );\r\n        maxBounds = maxBounds.withMinX( Math.max( maxBounds.minX, refinedBounds.maxBounds.minX ) );\r\n        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );\r\n        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );\r\n      }\r\n      \r\n      // maxX\r\n      tempMin = maxBounds.minY;\r\n      tempMax = maxBounds.maxY;\r\n      while ( isFinite( minBounds.maxX ) && isFinite( maxBounds.maxX ) && Math.abs( minBounds.maxX - maxBounds.maxX ) > precision ) {\r\n        // use maximum bounds except for the x direction, so we don't miss things that we are looking for\r\n        refinedBounds = scan( idealTransform( new Bounds2( minBounds.maxX, tempMin, maxBounds.maxX, tempMax ) ) );\r\n        \r\n        if ( minBounds.maxX >= refinedBounds.minBounds.maxX && maxBounds.maxX <= refinedBounds.maxBounds.maxX ) {\r\n          // sanity check - break out of an infinite loop!\r\n          if ( debugChromeBoundsScanning ) {\r\n            console.log( 'warning, exiting infinite loop!' );\r\n          }\r\n          break;\r\n        }\r\n        \r\n        minBounds = minBounds.withMaxX( Math.max( minBounds.maxX, refinedBounds.minBounds.maxX ) );\r\n        maxBounds = maxBounds.withMaxX( Math.min( maxBounds.maxX, refinedBounds.maxBounds.maxX ) );\r\n        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minY );\r\n        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxY );\r\n      }\r\n      \r\n      // minY\r\n      tempMin = maxBounds.minX;\r\n      tempMax = maxBounds.maxX;\r\n      while ( isFinite( minBounds.minY ) && isFinite( maxBounds.minY ) && Math.abs( minBounds.minY - maxBounds.minY ) > precision ) {\r\n        // use maximum bounds except for the y direction, so we don't miss things that we are looking for\r\n        refinedBounds = scan( idealTransform( new Bounds2( tempMin, maxBounds.minY, tempMax, minBounds.minY ) ) );\r\n        \r\n        if ( minBounds.minY <= refinedBounds.minBounds.minY && maxBounds.minY >= refinedBounds.maxBounds.minY ) {\r\n          // sanity check - break out of an infinite loop!\r\n          if ( debugChromeBoundsScanning ) {\r\n            console.log( 'warning, exiting infinite loop!' );\r\n          }\r\n          break;\r\n        }\r\n        \r\n        minBounds = minBounds.withMinY( Math.min( minBounds.minY, refinedBounds.minBounds.minY ) );\r\n        maxBounds = maxBounds.withMinY( Math.max( maxBounds.minY, refinedBounds.maxBounds.minY ) );\r\n        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );\r\n        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );\r\n      }\r\n      \r\n      // maxY\r\n      tempMin = maxBounds.minX;\r\n      tempMax = maxBounds.maxX;\r\n      while ( isFinite( minBounds.maxY ) && isFinite( maxBounds.maxY ) && Math.abs( minBounds.maxY - maxBounds.maxY ) > precision ) {\r\n        // use maximum bounds except for the y direction, so we don't miss things that we are looking for\r\n        refinedBounds = scan( idealTransform( new Bounds2( tempMin, minBounds.maxY, tempMax, maxBounds.maxY ) ) );\r\n        \r\n        if ( minBounds.maxY >= refinedBounds.minBounds.maxY && maxBounds.maxY <= refinedBounds.maxBounds.maxY ) {\r\n          // sanity check - break out of an infinite loop!\r\n          if ( debugChromeBoundsScanning ) {\r\n            console.log( 'warning, exiting infinite loop!' );\r\n          }\r\n          break;\r\n        }\r\n        \r\n        minBounds = minBounds.withMaxY( Math.max( minBounds.maxY, refinedBounds.minBounds.maxY ) );\r\n        maxBounds = maxBounds.withMaxY( Math.min( maxBounds.maxY, refinedBounds.maxBounds.maxY ) );\r\n        tempMin = Math.max( tempMin, refinedBounds.maxBounds.minX );\r\n        tempMax = Math.min( tempMax, refinedBounds.maxBounds.maxX );\r\n      }\r\n      \r\n      if ( debugChromeBoundsScanning ) {\r\n        console.log( 'minBounds: ' + minBounds );\r\n        console.log( 'maxBounds: ' + maxBounds );\r\n      }\r\n      \r\n      var result = new Bounds2(\r\n        ( minBounds.minX + maxBounds.minX ) / 2,\r\n        ( minBounds.minY + maxBounds.minY ) / 2,\r\n        ( minBounds.maxX + maxBounds.maxX ) / 2,\r\n        ( minBounds.maxY + maxBounds.maxY ) / 2\r\n      );\r\n      \r\n      // extra data about our bounds\r\n      result.minBounds = minBounds;\r\n      result.maxBounds = maxBounds;\r\n      result.isConsistent = maxBounds.containsBounds( minBounds );\r\n      result.precision = Math.max(\r\n        Math.abs( minBounds.minX - maxBounds.minX ),\r\n        Math.abs( minBounds.minY - maxBounds.minY ),\r\n        Math.abs( minBounds.maxX - maxBounds.maxX ),\r\n        Math.abs( minBounds.maxY - maxBounds.maxY )\r\n      );\r\n      \r\n      // return the average\r\n      return result;\r\n    }\r\n  };\r\n  var Util = scenery.Util;\r\n  \r\n  return Util;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * The main 'kite' namespace object for the exported (non-Require.js) API. Used internally\r\n * since it prevents Require.js issues with circular dependencies.\r\n *\r\n * The returned kite object namespace may be incomplete if not all modules are listed as\r\n * dependencies. Please use the 'main' module for that purpose if all of Kite is desired.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/kite',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  // will be filled in by other modules\r\n  return {};\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * A segment represents a specific curve with a start and end.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/Segment',['require','ASSERT/assert','KITE/kite','DOT/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var DotUtil = require( 'DOT/Util' );\r\n  \r\n  /*\r\n   * Will contain (for segments):\r\n   * properties:\r\n   * start        - start point of this segment\r\n   * end          - end point of this segment\r\n   * startTangent - the tangent vector (normalized) to the segment at the start, pointing in the direction of motion (from start to end)\r\n   * endTangent   - the tangent vector (normalized) to the segment at the end, pointing in the direction of motion (from start to end)\r\n   * bounds       - the bounding box for the segment\r\n   *\r\n   * methods:\r\n   * positionAt( t )          - returns the position parametrically, with 0 <= t <= 1. this does NOT guarantee a constant magnitude tangent... don't feel like adding elliptical functions yet!\r\n   * tangentAt( t )           - returns the non-normalized tangent (dx/dt, dy/dt) parametrically, with 0 <= t <= 1.\r\n   * curvatureAt( t )         - returns the signed curvature (positive for visual clockwise - mathematical counterclockwise)\r\n   * subdivided( t, skip )    - returns an array with 2 sub-segments, split at the parametric t value. if skip is passed, expensive operations are not performed\r\n   * getSVGPathFragment()     - returns a string containing the SVG path. assumes that the start point is already provided, so anything that calls this needs to put the M calls first\r\n   * strokeLeft( lineWidth )  - returns an array of segments that will draw an offset curve on the logical left side\r\n   * strokeRight( lineWidth ) - returns an array of segments that will draw an offset curve on the logical right side\r\n   * intersectsBounds         - whether this segment intersects the specified bounding box (not just the segment's bounding box, but the actual segment)\r\n   * windingIntersection      - returns the winding number for intersection with a ray\r\n   *\r\n   * writeToContext( context ) - draws the segment to the 2D Canvas context, assuming the context's current location is already at the start point\r\n   * transformed( matrix )     - returns a new segment that represents this segment after transformation by the matrix\r\n   */\r\n  kite.Segment = function Segment(){}; // no common construction for now\r\n  var Segment = kite.Segment;\r\n  \r\n  Segment.prototype = {\r\n    constructor: Segment,\r\n    \r\n    // tList should be a list of sorted t values from 0 <= t <= 1\r\n    subdivisions: function( tList, skipComputation ) {\r\n      // this could be solved by recursion, but we don't plan on the JS engine doing tail-call optimization\r\n      var right = this;\r\n      var result = [];\r\n      for ( var i = 0; i < tList.length; i++ ) {\r\n        // assume binary subdivision\r\n        var t = tList[i];\r\n        var arr = right.subdivided( t, skipComputation );\r\n        assert && assert( arr.length === 2 );\r\n        result.push( arr[0] );\r\n        right = arr[1];\r\n        \r\n        // scale up the remaining t values\r\n        for ( var j = i + 1; j < tList.length; j++ ) {\r\n          tList[j] = DotUtil.linear( t, 1, 0, 1, tList[j] );\r\n        }\r\n      }\r\n      result.push( right );\r\n      return result;\r\n    },\r\n    \r\n    // return an array of segments from breaking this segment into monotone pieces\r\n    subdividedIntoMonotone: function() {\r\n      return this.subdivisions( this.getInteriorExtremaTs() );\r\n    },\r\n  };\r\n  \r\n  return Segment;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Linear segment\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/Line',['require','ASSERT/assert','KITE/kite','PHET_CORE/inherit','DOT/Bounds2','DOT/Util','KITE/segments/Segment'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;\r\n  \r\n  var Segment = require( 'KITE/segments/Segment' );\r\n\r\n  Segment.Line = function Line( start, end ) {\r\n    this.start = start;\r\n    this.end = end;\r\n    \r\n    if ( start.equals( end, 0 ) ) {\r\n      this.invalid = true;\r\n      return;\r\n    }\r\n    \r\n    this.startTangent = end.minus( start ).normalized();\r\n    this.endTangent = this.startTangent;\r\n    \r\n    // acceleration for intersection\r\n    this.bounds = Bounds2.NOTHING.withPoint( start ).withPoint( end );\r\n  };\r\n  inherit( Segment, Segment.Line, {\r\n    \r\n    positionAt: function( t ) {\r\n      return this.start.plus( this.end.minus( this.start ).times( t ) );\r\n    },\r\n    \r\n    tangentAt: function( t ) {\r\n      // tangent always the same, just use the start tanget\r\n      return this.startTangent;\r\n    },\r\n    \r\n    curvatureAt: function( t ) {\r\n      return 0; // no curvature on a straight line segment\r\n    },\r\n    \r\n    getSVGPathFragment: function() {\r\n      return 'L ' + this.end.x + ' ' + this.end.y;\r\n    },\r\n    \r\n    strokeLeft: function( lineWidth ) {\r\n      var offset = this.endTangent.perpendicular().negated().times( lineWidth / 2 );\r\n      return [new Segment.Line( this.start.plus( offset ), this.end.plus( offset ) )];\r\n    },\r\n    \r\n    strokeRight: function( lineWidth ) {\r\n      var offset = this.startTangent.perpendicular().times( lineWidth / 2 );\r\n      return [new Segment.Line( this.end.plus( offset ), this.start.plus( offset ) )];\r\n    },\r\n    \r\n    // lines are already monotone\r\n    getInteriorExtremaTs: function() { return []; },\r\n    \r\n    subdivided: function( t ) {\r\n      var pt = this.positionAt( t );\r\n      return [\r\n        new Segment.Line( this.start, pt ),\r\n        new Segment.Line( pt, this.end )\r\n      ];\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.Line.intersectsBounds unimplemented' ); // TODO: implement\r\n    },\r\n    \r\n    intersection: function( ray ) {\r\n      var result = [];\r\n      \r\n      var start = this.start;\r\n      var end = this.end;\r\n      \r\n      var intersection = lineLineIntersection( start, end, ray.pos, ray.pos.plus( ray.dir ) );\r\n      \r\n      if ( !isFinite( intersection.x ) || !isFinite( intersection.y ) ) {\r\n        // lines must be parallel\r\n        return result;\r\n      }\r\n      \r\n      // check to make sure our point is in our line segment (specifically, in the bounds (start,end], not including the start point so we don't double-count intersections)\r\n      if ( start.x !== end.x && ( start.x > end.x ? ( intersection.x >= start.x || intersection.x < end.x ) : ( intersection.x <= start.x || intersection.x > end.x ) ) ) {\r\n        return result;\r\n      }\r\n      if ( start.y !== end.y && ( start.y > end.y ? ( intersection.y >= start.y || intersection.y < end.y ) : ( intersection.y <= start.y || intersection.y > end.y ) ) ) {\r\n        return result;\r\n      }\r\n      \r\n      // make sure the intersection is not behind the ray\r\n      var t = intersection.minus( ray.pos ).dot( ray.dir );\r\n      if ( t < 0 ) {\r\n        return result;\r\n      }\r\n      \r\n      // return the proper winding direction depending on what way our line intersection is \"pointed\"\r\n      var diff = end.minus( start );\r\n      var perp = diff.perpendicular();\r\n      result.push( {\r\n        distance: t,\r\n        point: ray.pointAtDistance( t ),\r\n        normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,\r\n        wind: ray.dir.perpendicular().dot( diff ) < 0 ? 1 : -1\r\n      } );\r\n      return result;\r\n    },\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    windingIntersection: function( ray ) {\r\n      var hits = this.intersection( ray );\r\n      if ( hits.length ) {\r\n        return hits[0].wind;\r\n      } else {\r\n        return 0;\r\n      }\r\n    },\r\n    \r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      context.lineTo( this.end.x, this.end.y );\r\n    },\r\n    \r\n    transformed: function( matrix ) {\r\n      return new Segment.Line( matrix.timesVector2( this.start ), matrix.timesVector2( this.end ) );\r\n    }\r\n  } );\r\n  \r\n  return Segment.Line;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Arc segment\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/Arc',['require','ASSERT/assert','KITE/kite','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Util','KITE/segments/Segment'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var DotUtil = require( 'DOT/Util' );\r\n\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n\r\n  Segment.Arc = function Arc( center, radius, startAngle, endAngle, anticlockwise ) {\r\n    if ( radius < 0 ) {\r\n      // support this case since we might actually need to handle it inside of strokes?\r\n      radius = -radius;\r\n      startAngle += Math.PI;\r\n      endAngle += Math.PI;\r\n    }\r\n    \r\n    this.center = center;\r\n    this.radius = radius;\r\n    this.startAngle = startAngle;\r\n    this.endAngle = endAngle;\r\n    this.anticlockwise = anticlockwise;\r\n    \r\n    this.start = this.positionAtAngle( startAngle );\r\n    this.end = this.positionAtAngle( endAngle );\r\n    this.startTangent = this.tangentAtAngle( startAngle );\r\n    this.endTangent = this.tangentAtAngle( endAngle );\r\n    \r\n    if ( radius <= 0 || startAngle === endAngle ) {\r\n      this.invalid = true;\r\n      return;\r\n    }\r\n    \r\n    // compute an actual end angle so that we can smoothly go from this.startAngle to this.actualEndAngle\r\n    if ( this.anticlockwise ) {\r\n      // angle is 'decreasing'\r\n      // -2pi <= end - start < 2pi\r\n      if ( this.startAngle > this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle;\r\n      } else if ( this.startAngle < this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle - 2 * Math.PI;\r\n      } else {\r\n        // equal\r\n        this.actualEndAngle = this.startAngle;\r\n      }\r\n    } else {\r\n      // angle is 'increasing'\r\n      // -2pi < end - start <= 2pi\r\n      if ( this.startAngle < this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle;\r\n      } else if ( this.startAngle > this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle + Math.PI * 2;\r\n      } else {\r\n        // equal\r\n        this.actualEndAngle = this.startAngle;\r\n      }\r\n    }\r\n    \r\n    // constraints\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle <= -Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle <= -Math.PI * 2 ) ), 'Not handling arcs with start/end angles that show differences in-between browser handling' );\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle > Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle > Math.PI * 2 ) ), 'Not handling arcs with start/end angles that show differences in-between browser handling' );\r\n    \r\n    var isFullPerimeter = ( !anticlockwise && endAngle - startAngle >= Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle >= Math.PI * 2 );\r\n    \r\n    // compute an angle difference that represents how \"much\" of the circle our arc covers\r\n    this.angleDifference = this.anticlockwise ? this.startAngle - this.endAngle : this.endAngle - this.startAngle;\r\n    if ( this.angleDifference < 0 ) {\r\n      this.angleDifference += Math.PI * 2;\r\n    }\r\n    assert && assert( this.angleDifference >= 0 ); // now it should always be zero or positive\r\n    \r\n    // acceleration for intersection\r\n    this.bounds = Bounds2.NOTHING;\r\n    this.bounds = this.bounds.withPoint( this.start );\r\n    this.bounds = this.bounds.withPoint( this.end );\r\n    \r\n    // for bounds computations\r\n    var that = this;\r\n    function boundsAtAngle( angle ) {\r\n      if ( that.containsAngle( angle ) ) {\r\n        // the boundary point is in the arc\r\n        that.bounds = that.bounds.withPoint( center.plus( Vector2.createPolar( radius, angle ) ) );\r\n      }\r\n    }\r\n    \r\n    // if the angles are different, check extrema points\r\n    if ( startAngle !== endAngle ) {\r\n      // check all of the extrema points\r\n      boundsAtAngle( 0 );\r\n      boundsAtAngle( Math.PI / 2 );\r\n      boundsAtAngle( Math.PI );\r\n      boundsAtAngle( 3 * Math.PI / 2 );\r\n    }\r\n  };\r\n  inherit( Segment, Segment.Arc, {\r\n    \r\n    // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.\r\n    mapAngle: function( angle ) {\r\n      // consider an assert that we contain that angle?\r\n      return ( this.startAngle > this.actualEndAngle ) ?\r\n             DotUtil.moduloBetweenUp( angle, this.startAngle - 2 * Math.PI, this.startAngle ) :\r\n             DotUtil.moduloBetweenDown( angle, this.startAngle, this.startAngle + 2 * Math.PI );\r\n    },\r\n    \r\n    tAtAngle: function( angle ) {\r\n      return ( this.mapAngle( angle ) - this.startAngle ) / ( this.actualEndAngle - this.startAngle );\r\n    },\r\n    \r\n    angleAt: function( t ) {\r\n      return this.startAngle + ( this.actualEndAngle - this.startAngle ) * t;\r\n    },\r\n    \r\n    positionAt: function( t ) {\r\n      return this.positionAtAngle( this.angleAt( t ) );\r\n    },\r\n    \r\n    tangentAt: function( t ) {\r\n      return this.tangentAtAngle( this.angleAt( t ) );\r\n    },\r\n    \r\n    curvatureAt: function( t ) {\r\n      return ( this.anticlockwise ? -1 : 1 ) / this.radius;\r\n    },\r\n    \r\n    positionAtAngle: function( angle ) {\r\n      return this.center.plus( Vector2.createPolar( this.radius, angle ) );\r\n    },\r\n    \r\n    tangentAtAngle: function( angle ) {\r\n      var normal = Vector2.createPolar( 1, angle );\r\n      \r\n      return this.anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();\r\n    },\r\n    \r\n    // TODO: refactor? shared with Segment.EllipticalArc (use this improved version)\r\n    containsAngle: function( angle ) {\r\n      // transform the angle into the appropriate coordinate form\r\n      // TODO: check anticlockwise version!\r\n      var normalizedAngle = this.anticlockwise ? angle - this.endAngle : angle - this.startAngle;\r\n      \r\n      // get the angle between 0 and 2pi\r\n      var positiveMinAngle = DotUtil.moduloBetweenDown( normalizedAngle, 0, Math.PI * 2 );\r\n      \r\n      return positiveMinAngle <= this.angleDifference;\r\n    },\r\n    \r\n    getSVGPathFragment: function() {\r\n      // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info\r\n      // rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n      \r\n      var epsilon = 0.01; // allow some leeway to render things as 'almost circles'\r\n      var sweepFlag = this.anticlockwise ? '0' : '1';\r\n      var largeArcFlag;\r\n      if ( this.angleDifference < Math.PI * 2 - epsilon ) {\r\n        largeArcFlag = this.angleDifference < Math.PI ? '0' : '1';\r\n        return 'A ' + this.radius + ' ' + this.radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;\r\n      } else {\r\n        // circle (or almost-circle) case needs to be handled differently\r\n        // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs\r\n        \r\n        // get the angle that is between and opposite of both of the points\r\n        var splitOppositeAngle = ( this.startAngle + this.endAngle ) / 2; // this _should_ work for the modular case?\r\n        var splitPoint = this.center.plus( Vector2.createPolar( this.radius, splitOppositeAngle ) );\r\n        \r\n        largeArcFlag = '0'; // since we split it in 2, it's always the small arc\r\n        \r\n        var firstArc = 'A ' + this.radius + ' ' + this.radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + splitPoint.x + ' ' + splitPoint.y;\r\n        var secondArc = 'A ' + this.radius + ' ' + this.radius + ' 0 ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;\r\n        \r\n        return firstArc + ' ' + secondArc;\r\n      }\r\n    },\r\n    \r\n    strokeLeft: function( lineWidth ) {\r\n      return [new Segment.Arc( this.center, this.radius + ( this.anticlockwise ? 1 : -1 ) * lineWidth / 2, this.startAngle, this.endAngle, this.anticlockwise )];\r\n    },\r\n    \r\n    strokeRight: function( lineWidth ) {\r\n      return [new Segment.Arc( this.center, this.radius + ( this.anticlockwise ? -1 : 1 ) * lineWidth / 2, this.endAngle, this.startAngle, !this.anticlockwise )];\r\n    },\r\n    \r\n    // not including 0 and 1\r\n    getInteriorExtremaTs: function() {\r\n      var that = this;\r\n      var result = [];\r\n      _.each( [ 0, Math.PI / 2, Math.PI, 3 * Math.PI / 2 ], function( angle ) {\r\n        if ( that.containsAngle( angle ) ) {\r\n          var t = that.tAtAngle( angle );\r\n          var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n          if ( t > epsilon && t < 1 - epsilon ) {\r\n            result.push( t );\r\n          }\r\n        }\r\n      } );\r\n      return result.sort(); // modifies original, which is OK\r\n    },\r\n    \r\n    subdivided: function( t ) {\r\n      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles\r\n      var angle0 = this.angleAt( 0 );\r\n      var angleT = this.angleAt( t );\r\n      var angle1 = this.angleAt( 1 );\r\n      return [\r\n        new Segment.Arc( this.center, this.radius, angle0, angleT, this.anticlockwise ),\r\n        new Segment.Arc( this.center, this.radius, angleT, angle1, this.anticlockwise )\r\n      ];\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.intersectsBounds unimplemented!' );\r\n    },\r\n    \r\n    intersection: function( ray ) {\r\n      var result = []; // hits in order\r\n      \r\n      // left here, if in the future we want to better-handle boundary points\r\n      var epsilon = 0;\r\n      \r\n      // Run a general circle-intersection routine, then we can test the angles later.\r\n      // Solves for the two solutions t such that ray.pos + ray.dir * t is on the circle.\r\n      // Then we check whether the angle at each possible hit point is in our arc.\r\n      var centerToRay = ray.pos.minus( this.center );\r\n      var tmp = ray.dir.dot( centerToRay );\r\n      var centerToRayDistSq = centerToRay.magnitudeSquared();\r\n      var discriminant = 4 * tmp * tmp - 4 * ( centerToRayDistSq - this.radius * this.radius );\r\n      if ( discriminant < epsilon ) {\r\n        // ray misses circle entirely\r\n        return result;\r\n      }\r\n      var base = ray.dir.dot( this.center ) - ray.dir.dot( ray.pos );\r\n      var sqt = Math.sqrt( discriminant ) / 2;\r\n      var ta = base - sqt;\r\n      var tb = base + sqt;\r\n      \r\n      if ( tb < epsilon ) {\r\n        // circle is behind ray\r\n        return result;\r\n      }\r\n      \r\n      var pointB = ray.pointAtDistance( tb );\r\n      var normalB = pointB.minus( this.center ).normalized();\r\n      \r\n      if ( ta < epsilon ) {\r\n        // we are inside the circle, so only one intersection is possible\r\n        if ( this.containsAngle( normalB.angle() ) ) {\r\n          result.push( {\r\n            distance: tb,\r\n            point: pointB,\r\n            normal: normalB.negated(), // normal is towards the ray\r\n            wind: this.anticlockwise ? -1 : 1 // since we are inside, wind this way\r\n          } );\r\n        }\r\n      }\r\n      else {\r\n        // two possible hits (outside circle)\r\n        var pointA = ray.pointAtDistance( ta );\r\n        var normalA = pointA.minus( this.center ).normalized();\r\n        \r\n        if ( this.containsAngle( normalA.angle() ) ) {\r\n          result.push( {\r\n            distance: ta,\r\n            point: pointA,\r\n            normal: normalA,\r\n            wind: this.anticlockwise ? 1 : -1 // hit from outside\r\n          } );\r\n        }\r\n        if ( this.containsAngle( normalB.angle() ) ) {\r\n          result.push( {\r\n            distance: tb,\r\n            point: pointB,\r\n            normal: normalB.negated(),\r\n            wind: this.anticlockwise ? -1 : 1 // this is the far hit, which winds the opposite way\r\n          } );\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    },\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      var hits = this.intersection( ray );\r\n      _.each( hits, function( hit ) {\r\n        wind += hit.wind;\r\n      } );\r\n      return wind;\r\n    },\r\n    \r\n    writeToContext: function( context ) {\r\n      context.arc( this.center.x, this.center.y, this.radius, this.startAngle, this.endAngle, this.anticlockwise );\r\n    },\r\n    \r\n    // TODO: test various transform types, especially rotations, scaling, shears, etc.\r\n    transformed: function( matrix ) {\r\n      // so we can handle reflections in the transform, we do the general case handling for start/end angles\r\n      var startAngle = matrix.timesVector2( Vector2.createPolar( 1, this.startAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();\r\n      var endAngle = matrix.timesVector2( Vector2.createPolar( 1, this.endAngle ) ).minus( matrix.timesVector2( Vector2.ZERO ) ).angle();\r\n      \r\n      // reverse the 'clockwiseness' if our transform includes a reflection\r\n      var anticlockwise = matrix.getDeterminant() >= 0 ? this.anticlockwise : !this.anticlockwise;\r\n\r\n      var scaleVector = matrix.getScaleVector();\r\n      if ( scaleVector.x !== scaleVector.y ) {\r\n        var radiusX = scaleVector.x * this.radius;\r\n        var radiusY = scaleVector.y * this.radius;\r\n        return new Segment.EllipticalArc( matrix.timesVector2( this.center ), radiusX, radiusY, 0, startAngle, endAngle, anticlockwise );\r\n      } else {\r\n        var radius = scaleVector.x * this.radius;\r\n        return new Segment.Arc( matrix.timesVector2( this.center ), radius, startAngle, endAngle, anticlockwise );\r\n      }\r\n    }\r\n  } );\r\n  \r\n  return Segment.Arc;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * A Canvas-style stateful (mutable) subpath, which tracks segments in addition to the points.\r\n *\r\n * See http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#concept-path\r\n * for the path / subpath Canvas concept.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/util/Subpath',['require','ASSERT/assert','DOT/Vector2','DOT/Bounds2','DOT/Util','KITE/kite','KITE/segments/Line','KITE/segments/Arc'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n  \r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;\r\n  \r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  require( 'KITE/segments/Line' );\r\n  require( 'KITE/segments/Arc' );\r\n  \r\n  // all arguments optional (they are for the copy() method)\r\n  kite.Subpath = function Subpath( segments, points, closed ) {\r\n    this.segments = segments || [];\r\n    \r\n    // recombine points if necessary, based off of start points of segments + the end point of the last segment\r\n    this.points = points || ( ( segments && segments.length ) ? _.map( segments, function( segment ) { return segment.start; } ).concat( segments[segments.length-1].end ) : [] );\r\n    this.closed = !!closed;\r\n    \r\n    // cached stroked shape (so hit testing can be done quickly on stroked shapes)\r\n    this._strokedSubpaths = null;\r\n    this._strokedSubpathsComputed = false;\r\n    this._strokedStyles = null;\r\n  };\r\n  var Subpath = kite.Subpath;\r\n  Subpath.prototype = {\r\n    copy: function() {\r\n      return new Subpath( this.segments.slice( 0 ), this.points.slice( 0 ), this.closed );\r\n    },\r\n    \r\n    invalidate: function() {\r\n      this._strokedSubpathsComputed = false;\r\n    },\r\n    \r\n    addPoint: function( point ) {\r\n      this.points.push( point );\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    addSegment: function( segment ) {\r\n      if ( !segment.invalid ) {\r\n        assert && assert( segment.start.isFinite(), 'Segment start is infinite' );\r\n        assert && assert( segment.end.isFinite(), 'Segment end is infinite' );\r\n        assert && assert( segment.startTangent.isFinite(), 'Segment startTangent is infinite' );\r\n        assert && assert( segment.endTangent.isFinite(), 'Segment endTangent is infinite' );\r\n        assert && assert( segment.bounds.isEmpty() || segment.bounds.isFinite(), 'Segment bounds is infinite and non-empty' );\r\n        this.segments.push( segment );\r\n        this.invalidate();\r\n      }\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    close: function() {\r\n      this.closed = true;\r\n    },\r\n    \r\n    getLength: function() {\r\n      return this.points.length;\r\n    },\r\n    \r\n    getFirstPoint: function() {\r\n      return _.first( this.points );\r\n    },\r\n    \r\n    getLastPoint: function() {\r\n      return _.last( this.points );\r\n    },\r\n    \r\n    getFirstSegment: function() {\r\n      return _.first( this.segments );\r\n    },\r\n    \r\n    getLastSegment: function() {\r\n      return _.last( this.segments );\r\n    },\r\n    \r\n    isDrawable: function() {\r\n      return this.segments.length > 0;\r\n    },\r\n    \r\n    isClosed: function() {\r\n      return this.closed;\r\n    },\r\n    \r\n    hasClosingSegment: function() {\r\n      return !this.getFirstPoint().equalsEpsilon( this.getLastPoint(), 0.000000001 );\r\n    },\r\n    \r\n    getClosingSegment: function() {\r\n      assert && assert( this.hasClosingSegment(), 'Implicit closing segment unnecessary on a fully closed path' );\r\n      return new kite.Segment.Line( this.getLastPoint(), this.getFirstPoint() );\r\n    },\r\n    \r\n    writeToContext: function( context ) {\r\n      if ( this.isDrawable() ) {\r\n        var startPoint = this.getFirstSegment().start;\r\n        context.moveTo( startPoint.x, startPoint.y ); // the segments assume the current context position is at their start\r\n        \r\n        _.each( this.segments, function( segment ) {\r\n          segment.writeToContext( context );\r\n        } );\r\n        \r\n        if ( this.closed ) {\r\n          context.closePath();\r\n        }\r\n      }\r\n    },\r\n    \r\n    transformed: function( matrix ) {\r\n      return new Subpath(\r\n        _.map( this.segments, function( segment ) { return segment.transformed( matrix ); } ),\r\n        _.map( this.points, function( point ) { return matrix.timesVector2( point ); } ),\r\n        this.closed\r\n      );\r\n    },\r\n    \r\n    computeBounds: function() {\r\n      return _.reduce( this.segments, function( bounds, segment ) {\r\n        return bounds.union( segment.bounds );\r\n      }, Bounds2.NOTHING );\r\n    },\r\n    \r\n    // returns an array of subpaths (one if open, two if closed) that represent a stroked copy of this subpath.\r\n    stroked: function( lineStyles ) {\r\n      // non-drawable subpaths convert to empty subpaths\r\n      if ( !this.isDrawable() ) {\r\n        return new Subpath();\r\n      }\r\n      \r\n      if ( lineStyles === undefined ) {\r\n        lineStyles = new kite.LineStyles();\r\n      }\r\n      \r\n      // return a cached version if possible\r\n      if ( this._strokedSubpathsComputed && this._strokedStyles.equals( lineStyles ) ) {\r\n        return this._strokedSubpaths;\r\n      }\r\n      \r\n      var lineWidth = lineStyles.lineWidth;\r\n      \r\n      // joins two segments together on the logical \"left\" side, at 'center' (where they meet), and normalized tangent vectors in the direction of the stroking\r\n      // to join on the \"right\" side, switch the tangent order and negate them\r\n      function join( center, fromTangent, toTangent ) {\r\n        // where our join path starts and ends\r\n        var fromPoint = center.plus( fromTangent.perpendicular().negated().times( lineWidth / 2 ) );\r\n        var toPoint = center.plus( toTangent.perpendicular().negated().times( lineWidth / 2 ) );\r\n        \r\n        var bevel = ( fromPoint.equals( toPoint ) ? [] : [new kite.Segment.Line( fromPoint, toPoint )] );\r\n        \r\n        // only insert a join on the non-acute-angle side\r\n        if ( fromTangent.perpendicular().dot( toTangent ) > 0 ) {\r\n          switch( lineStyles.lineJoin ) {\r\n            case 'round':\r\n              var fromAngle = fromTangent.angle() + Math.PI / 2;\r\n              var toAngle = toTangent.angle() + Math.PI / 2;\r\n              return [new kite.Segment.Arc( center, lineWidth / 2, fromAngle, toAngle, true )];\r\n            case 'miter':\r\n              var theta = fromTangent.angleBetween( toTangent.negated() );\r\n              var notStraight = theta < Math.PI - 0.00001; // if fromTangent is approximately equal to toTangent, just bevel. it will be indistinguishable\r\n              if ( 1 / Math.sin( theta / 2 ) <= lineStyles.miterLimit && theta < Math.PI - 0.00001 ) {\r\n                // draw the miter\r\n                var miterPoint = lineLineIntersection( fromPoint, fromPoint.plus( fromTangent ), toPoint, toPoint.plus( toTangent ) );\r\n                return [\r\n                  new kite.Segment.Line( fromPoint, miterPoint ),\r\n                  new kite.Segment.Line( miterPoint, toPoint )\r\n                ];\r\n              } else {\r\n                // angle too steep, use bevel instead. same as below, but copied for linter\r\n                return bevel;\r\n              }\r\n              break;\r\n            case 'bevel':\r\n              return bevel;\r\n          }\r\n        } else {\r\n          // no join necessary here since we have the acute angle. just simple lineTo for now so that the next segment starts from the right place\r\n          // TODO: can we prevent self-intersection here?\r\n          return bevel;\r\n        }\r\n      }\r\n      \r\n      // draws the necessary line cap from the endpoint 'center' in the direction of the tangent\r\n      function cap( center, tangent ) {\r\n        var fromPoint = center.plus( tangent.perpendicular().times( -lineWidth / 2 ) );\r\n        var toPoint = center.plus( tangent.perpendicular().times( lineWidth / 2 ) );\r\n        \r\n        switch( lineStyles.lineCap ) {\r\n          case 'butt':\r\n            return [new kite.Segment.Line( fromPoint, toPoint )];\r\n          case 'round':\r\n            var tangentAngle = tangent.angle();\r\n            return [new kite.Segment.Arc( center, lineWidth / 2, tangentAngle + Math.PI / 2, tangentAngle - Math.PI / 2, true )];\r\n          case 'square':\r\n            var toLeft = tangent.perpendicular().negated().times( lineWidth / 2 );\r\n            var toRight = tangent.perpendicular().times( lineWidth / 2 );\r\n            var toFront = tangent.times( lineWidth / 2 );\r\n            \r\n            var left = center.plus( toLeft ).plus( toFront );\r\n            var right = center.plus( toRight ).plus( toFront );\r\n            return [\r\n              new kite.Segment.Line( fromPoint, left ),\r\n              new kite.Segment.Line( left, right ),\r\n              new kite.Segment.Line( right, toPoint )\r\n            ];\r\n        }\r\n      }\r\n      \r\n      var i;\r\n      var leftSegments = [];\r\n      var rightSegments = [];\r\n      var firstSegment = this.getFirstSegment();\r\n      var lastSegment = this.getLastSegment();\r\n      \r\n      function addLeftSegments( segments ) {\r\n        _.each( segments, function( segment ) { leftSegments.push( segment ); } );\r\n      }\r\n      function addRightSegments( segments ) {\r\n        _.each( segments, function( segment ) { rightSegments.push( segment ); } );\r\n      }\r\n      \r\n      // we don't need to insert an implicit closing segment if the start and end points are the same\r\n      var alreadyClosed = lastSegment.end.equals( firstSegment.start );\r\n      // if there is an implicit closing segment\r\n      var closingSegment = alreadyClosed ? null : new kite.Segment.Line( this.segments[this.segments.length-1].end, this.segments[0].start );\r\n      \r\n      // stroke the logical \"left\" side of our path\r\n      for ( i = 0; i < this.segments.length; i++ ) {\r\n        if ( i > 0 ) {\r\n          addLeftSegments( join( this.segments[i].start, this.segments[i-1].endTangent, this.segments[i].startTangent, true ) );\r\n        }\r\n        addLeftSegments( this.segments[i].strokeLeft( lineWidth ) );\r\n      }\r\n      \r\n      // stroke the logical \"right\" side of our path\r\n      for ( i = this.segments.length - 1; i >= 0; i-- ) {\r\n        if ( i < this.segments.length - 1 ) {\r\n          addRightSegments( join( this.segments[i].end, this.segments[i+1].startTangent.negated(), this.segments[i].endTangent.negated(), false ) );\r\n        }\r\n        addRightSegments( this.segments[i].strokeRight( lineWidth ) );\r\n      }\r\n      \r\n      var subpaths;\r\n      if ( this.closed ) {\r\n        if ( alreadyClosed ) {\r\n          // add the joins between the start and end\r\n          addLeftSegments( join( lastSegment.end, lastSegment.endTangent, firstSegment.startTangent ) );\r\n          addRightSegments( join( lastSegment.end, firstSegment.startTangent.negated(), lastSegment.endTangent.negated() ) );\r\n        } else {\r\n          // logical \"left\" stroke on the implicit closing segment\r\n          addLeftSegments( join( closingSegment.start, lastSegment.endTangent, closingSegment.startTangent ) );\r\n          addLeftSegments( closingSegment.strokeLeft( lineWidth ) );\r\n          addLeftSegments( join( closingSegment.end, closingSegment.endTangent, firstSegment.startTangent ) );\r\n          \r\n          // logical \"right\" stroke on the implicit closing segment\r\n          addRightSegments( join( closingSegment.end, firstSegment.startTangent.negated(), closingSegment.endTangent.negated() ) );\r\n          addRightSegments( closingSegment.strokeRight( lineWidth ) );\r\n          addRightSegments( join( closingSegment.start, closingSegment.startTangent.negated(), lastSegment.endTangent.negated() ) );\r\n        }\r\n        subpaths = [\r\n          new Subpath( leftSegments, null, true ),\r\n          new Subpath( rightSegments, null, true )\r\n        ];\r\n      } else {\r\n        subpaths = [\r\n          new Subpath( leftSegments\r\n                         .concat( cap( lastSegment.end, lastSegment.endTangent ) )\r\n                         .concat( rightSegments )\r\n                         .concat( cap( firstSegment.start, firstSegment.startTangent.negated() ) ),\r\n                       null, true )\r\n        ];\r\n      }\r\n      \r\n      this._strokedSubpaths = subpaths;\r\n      this._strokedSubpathsComputed = true;\r\n      this._strokedStyles = new kite.LineStyles( lineStyles ); // shallow copy, since we consider linestyles to be mutable\r\n      \r\n      return subpaths;\r\n    }\r\n  };\r\n  \r\n  // TODO: performance / cleanliness to have these as methods instead?\r\n  function segmentStartLeft( segment, lineWidth ) {\r\n    assert && assert( lineWidth !== undefined );\r\n    return segment.start.plus( segment.startTangent.perpendicular().negated().times( lineWidth / 2 ) );\r\n  }\r\n  \r\n  function segmentEndLeft( segment, lineWidth ) {\r\n    assert && assert( lineWidth !== undefined );\r\n    return segment.end.plus( segment.endTangent.perpendicular().negated().times( lineWidth / 2 ) );\r\n  }\r\n  \r\n  function segmentStartRight( segment, lineWidth ) {\r\n    assert && assert( lineWidth !== undefined );\r\n    return segment.start.plus( segment.startTangent.perpendicular().times( lineWidth / 2 ) );\r\n  }\r\n  \r\n  function segmentEndRight( segment, lineWidth ) {\r\n    assert && assert( lineWidth !== undefined );\r\n    return segment.end.plus( segment.endTangent.perpendicular().times( lineWidth / 2 ) );\r\n  }\r\n  \r\n  return kite.Subpath;\r\n} );\r\n","\n// generated from svgPath.pegjs, with added kite namespace and require.js compatibility\r\n\r\ndefine( 'KITE/../parser/svgPath',['require','KITE/kite'],function( require ) {\r\n  \r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  /*\r\n   * Generated by PEG.js 0.7.0.\r\n   *\r\n   * http://pegjs.majda.cz/\r\n   */\r\n  \r\n  function quote(s) {\r\n    /*\r\n     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\r\n     * string literal except for the closing quote character, backslash,\r\n     * carriage return, line separator, paragraph separator, and line feed.\r\n     * Any character may appear in the form of an escape sequence.\r\n     *\r\n     * For portability, we also escape escape all control and non-ASCII\r\n     * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\r\n     * because JSHint does not like the first and IE the second.\r\n     */\r\n     return '\"' + s\r\n      .replace(/\\\\/g, '\\\\\\\\')  // backslash\r\n      .replace(/\"/g, '\\\\\"')    // closing quote character\r\n      .replace(/\\x08/g, '\\\\b') // backspace\r\n      .replace(/\\t/g, '\\\\t')   // horizontal tab\r\n      .replace(/\\n/g, '\\\\n')   // line feed\r\n      .replace(/\\f/g, '\\\\f')   // form feed\r\n      .replace(/\\r/g, '\\\\r')   // carriage return\r\n      .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape)\r\n      + '\"';\r\n  }\r\n  \r\n  kite.svgPath = {\r\n    /*\r\n     * Parses the input with a generated parser. If the parsing is successfull,\r\n     * returns a value explicitly or implicitly specified by the grammar from\r\n     * which the parser was generated (see |PEG.buildParser|). If the parsing is\r\n     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\r\n     */\r\n    parse: function(input, startRule) {\r\n      var parseFunctions = {\r\n        \"svgPath\": parse_svgPath,\r\n        \"movetoDrawtoCommandGroups\": parse_movetoDrawtoCommandGroups,\r\n        \"movetoDrawtoCommandGroup\": parse_movetoDrawtoCommandGroup,\r\n        \"drawtoCommands\": parse_drawtoCommands,\r\n        \"drawtoCommand\": parse_drawtoCommand,\r\n        \"moveto\": parse_moveto,\r\n        \"movetoArgumentSequence\": parse_movetoArgumentSequence,\r\n        \"closepath\": parse_closepath,\r\n        \"lineto\": parse_lineto,\r\n        \"linetoArgumentSequence\": parse_linetoArgumentSequence,\r\n        \"horizontalLineto\": parse_horizontalLineto,\r\n        \"horizontalLinetoArgumentSequence\": parse_horizontalLinetoArgumentSequence,\r\n        \"verticalLineto\": parse_verticalLineto,\r\n        \"verticalLinetoArgumentSequence\": parse_verticalLinetoArgumentSequence,\r\n        \"curveto\": parse_curveto,\r\n        \"curvetoArgumentSequence\": parse_curvetoArgumentSequence,\r\n        \"curvetoArgument\": parse_curvetoArgument,\r\n        \"smoothCurveto\": parse_smoothCurveto,\r\n        \"smoothCurvetoArgumentSequence\": parse_smoothCurvetoArgumentSequence,\r\n        \"smoothCurvetoArgument\": parse_smoothCurvetoArgument,\r\n        \"quadraticBezierCurveto\": parse_quadraticBezierCurveto,\r\n        \"quadraticBezierCurvetoArgumentSequence\": parse_quadraticBezierCurvetoArgumentSequence,\r\n        \"quadraticBezierCurvetoArgument\": parse_quadraticBezierCurvetoArgument,\r\n        \"smoothQuadraticBezierCurveto\": parse_smoothQuadraticBezierCurveto,\r\n        \"smoothQuadraticBezierCurvetoArgumentSequence\": parse_smoothQuadraticBezierCurvetoArgumentSequence,\r\n        \"ellipticalArc\": parse_ellipticalArc,\r\n        \"ellipticalArcArgumentSequence\": parse_ellipticalArcArgumentSequence,\r\n        \"ellipticalArcArgument\": parse_ellipticalArcArgument,\r\n        \"coordinatePair\": parse_coordinatePair,\r\n        \"nonnegativeNumber\": parse_nonnegativeNumber,\r\n        \"number\": parse_number,\r\n        \"flag\": parse_flag,\r\n        \"commaWsp\": parse_commaWsp,\r\n        \"comma\": parse_comma,\r\n        \"floatingPointConstant\": parse_floatingPointConstant,\r\n        \"fractionalConstant\": parse_fractionalConstant,\r\n        \"exponent\": parse_exponent,\r\n        \"sign\": parse_sign,\r\n        \"digitSequence\": parse_digitSequence,\r\n        \"digit\": parse_digit,\r\n        \"wsp\": parse_wsp\r\n      };\r\n      \r\n      if (startRule !== undefined) {\r\n        if (parseFunctions[startRule] === undefined) {\r\n          throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\r\n        }\r\n      } else {\r\n        startRule = \"svgPath\";\r\n      }\r\n      \r\n      var pos = 0;\r\n      var reportFailures = 0;\r\n      var rightmostFailuresPos = 0;\r\n      var rightmostFailuresExpected = [];\r\n      \r\n      function padLeft(input, padding, length) {\r\n        var result = input;\r\n        \r\n        var padLength = length - input.length;\r\n        for (var i = 0; i < padLength; i++) {\r\n          result = padding + result;\r\n        }\r\n        \r\n        return result;\r\n      }\r\n      \r\n      function escape(ch) {\r\n        var charCode = ch.charCodeAt(0);\r\n        var escapeChar;\r\n        var length;\r\n        \r\n        if (charCode <= 0xFF) {\r\n          escapeChar = 'x';\r\n          length = 2;\r\n        } else {\r\n          escapeChar = 'u';\r\n          length = 4;\r\n        }\r\n        \r\n        return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\r\n      }\r\n      \r\n      function matchFailed(failure) {\r\n        if (pos < rightmostFailuresPos) {\r\n          return;\r\n        }\r\n        \r\n        if (pos > rightmostFailuresPos) {\r\n          rightmostFailuresPos = pos;\r\n          rightmostFailuresExpected = [];\r\n        }\r\n        \r\n        rightmostFailuresExpected.push(failure);\r\n      }\r\n      \r\n      function parse_svgPath() {\r\n        var result0, result1, result2, result3;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = [];\r\n        result1 = parse_wsp();\r\n        while (result1 !== null) {\r\n          result0.push(result1);\r\n          result1 = parse_wsp();\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = parse_movetoDrawtoCommandGroups();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = [];\r\n            result3 = parse_wsp();\r\n            while (result3 !== null) {\r\n              result2.push(result3);\r\n              result3 = parse_wsp();\r\n            }\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, path) { return path ? path : []; })(pos0, result0[1]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_movetoDrawtoCommandGroups() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_movetoDrawtoCommandGroup();\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_movetoDrawtoCommandGroups();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return a.concat( b ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_movetoDrawtoCommandGroup();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return a; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_movetoDrawtoCommandGroup() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_moveto();\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_drawtoCommands();\r\n            result2 = result2 !== null ? result2 : \"\";\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, m, c) { return c.length ? m.concat( c ) : m; })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_drawtoCommands() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_drawtoCommand();\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_drawtoCommands();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, cmd, cmds) { return cmd.concat( cmds ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_drawtoCommand();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, cmd) { return cmd; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_drawtoCommand() {\r\n        var result0;\r\n        \r\n        result0 = parse_closepath();\r\n        if (result0 === null) {\r\n          result0 = parse_lineto();\r\n          if (result0 === null) {\r\n            result0 = parse_horizontalLineto();\r\n            if (result0 === null) {\r\n              result0 = parse_verticalLineto();\r\n              if (result0 === null) {\r\n                result0 = parse_curveto();\r\n                if (result0 === null) {\r\n                  result0 = parse_smoothCurveto();\r\n                  if (result0 === null) {\r\n                    result0 = parse_quadraticBezierCurveto();\r\n                    if (result0 === null) {\r\n                      result0 = parse_smoothQuadraticBezierCurveto();\r\n                      if (result0 === null) {\r\n                        result0 = parse_ellipticalArc();\r\n                      }\r\n                    }\r\n                  }\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_moveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 77) {\r\n          result0 = \"M\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"M\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_movetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return createMoveTo( args, false ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 109) {\r\n            result0 = \"m\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"m\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_movetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return createMoveTo( args, true ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_movetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_linetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, pair, list) { return [pair].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_coordinatePair();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, pair) { return [pair]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_closepath() {\r\n        var result0;\r\n        var pos0;\r\n        \r\n        pos0 = pos;\r\n        if (input.charCodeAt(pos) === 90) {\r\n          result0 = \"Z\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"Z\\\"\");\r\n          }\r\n        }\r\n        if (result0 === null) {\r\n          if (input.charCodeAt(pos) === 122) {\r\n            result0 = \"z\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"z\\\"\");\r\n            }\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, command) { return { cmd: 'close' }; })(pos0, result0);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_lineto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 76) {\r\n          result0 = \"L\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"L\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_linetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'lineTo', args: [ arg.x, arg.y ] }; } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 108) {\r\n            result0 = \"l\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"l\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_linetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'lineToRelative', args: [ arg.x, arg.y ] }; } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_linetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_linetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return [a].concat( b ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_coordinatePair();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_horizontalLineto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 72) {\r\n          result0 = \"H\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"H\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_horizontalLinetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'horizontalLineTo', args: [ arg ] } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 104) {\r\n            result0 = \"h\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"h\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_horizontalLinetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'horizontalLineToRelative', args: [ arg ] } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_horizontalLinetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_number();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_horizontalLinetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return [a].concat( b ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_number();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_verticalLineto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 86) {\r\n          result0 = \"V\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"V\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_verticalLinetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'verticalLineTo', args: [ arg ] } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 118) {\r\n            result0 = \"v\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"v\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_verticalLinetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'verticalLineToRelative', args: [ arg ] } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_verticalLinetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_number();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_verticalLinetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return [a].concat( b ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_number();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_curveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 67) {\r\n          result0 = \"C\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"C\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_curvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'cubicCurveTo', args: arg } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 99) {\r\n            result0 = \"c\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"c\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_curvetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'cubicCurveToRelative', args: arg } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_curvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_curvetoArgument();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_curvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_curvetoArgument();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_curvetoArgument() {\r\n        var result0, result1, result2, result3, result4;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_coordinatePair();\r\n            if (result2 !== null) {\r\n              result3 = parse_commaWsp();\r\n              result3 = result3 !== null ? result3 : \"\";\r\n              if (result3 !== null) {\r\n                result4 = parse_coordinatePair();\r\n                if (result4 !== null) {\r\n                  result0 = [result0, result1, result2, result3, result4];\r\n                } else {\r\n                  result0 = null;\r\n                  pos = pos1;\r\n                }\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b, c) { return [ a.x, a.y, b.x, b.y, c.x, c.y ]; })(pos0, result0[0], result0[2], result0[4]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_smoothCurveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 83) {\r\n          result0 = \"S\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"S\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_smoothCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothCubicCurveTo', args: arg } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 115) {\r\n            result0 = \"s\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"s\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_smoothCurvetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothCubicCurveToRelative', args: arg } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_smoothCurvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_smoothCurvetoArgument();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_smoothCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_smoothCurvetoArgument();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_smoothCurvetoArgument() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_coordinatePair();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return [ a.x, a.y, b.x, b.y ]; })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_quadraticBezierCurveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 81) {\r\n          result0 = \"Q\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"Q\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_quadraticBezierCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'quadraticCurveTo', args: arg } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 113) {\r\n            result0 = \"q\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"q\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_quadraticBezierCurvetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'quadraticCurveToRelative', args: arg } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_quadraticBezierCurvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_quadraticBezierCurvetoArgument();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_quadraticBezierCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_quadraticBezierCurvetoArgument();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_quadraticBezierCurvetoArgument() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_coordinatePair();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return [ a.x, a.y, b.x, b.y ]; })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_smoothQuadraticBezierCurveto() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 84) {\r\n          result0 = \"T\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"T\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothQuadraticCurveTo', args: [ arg.x, arg.y ] } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 116) {\r\n            result0 = \"t\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"t\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'smoothQuadraticCurveToRelative', args: [ arg.x, arg.y ] } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_smoothQuadraticBezierCurvetoArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_coordinatePair();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_smoothQuadraticBezierCurvetoArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_coordinatePair();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_ellipticalArc() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 65) {\r\n          result0 = \"A\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"A\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = [];\r\n          result2 = parse_wsp();\r\n          while (result2 !== null) {\r\n            result1.push(result2);\r\n            result2 = parse_wsp();\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_ellipticalArcArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'ellipticalArcTo', args: arg } } ); })(pos0, result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          if (input.charCodeAt(pos) === 97) {\r\n            result0 = \"a\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"a\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result2 = parse_ellipticalArcArgumentSequence();\r\n              if (result2 !== null) {\r\n                result0 = [result0, result1, result2];\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, args) { return args.map( function( arg ) { return { cmd: 'ellipticalArcToRelative', args: arg } } ); })(pos0, result0[2]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_ellipticalArcArgumentSequence() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_ellipticalArcArgument();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_ellipticalArcArgumentSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, list) { return [a].concat( list ); })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_ellipticalArcArgument();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return [a]; })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_ellipticalArcArgument() {\r\n        var result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_nonnegativeNumber();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_nonnegativeNumber();\r\n            if (result2 !== null) {\r\n              result3 = parse_commaWsp();\r\n              result3 = result3 !== null ? result3 : \"\";\r\n              if (result3 !== null) {\r\n                result4 = parse_number();\r\n                if (result4 !== null) {\r\n                  result5 = parse_commaWsp();\r\n                  if (result5 !== null) {\r\n                    result6 = parse_flag();\r\n                    if (result6 !== null) {\r\n                      result7 = parse_commaWsp();\r\n                      result7 = result7 !== null ? result7 : \"\";\r\n                      if (result7 !== null) {\r\n                        result8 = parse_flag();\r\n                        if (result8 !== null) {\r\n                          result9 = parse_commaWsp();\r\n                          result9 = result9 !== null ? result9 : \"\";\r\n                          if (result9 !== null) {\r\n                            result10 = parse_coordinatePair();\r\n                            if (result10 !== null) {\r\n                              result0 = [result0, result1, result2, result3, result4, result5, result6, result7, result8, result9, result10];\r\n                            } else {\r\n                              result0 = null;\r\n                              pos = pos1;\r\n                            }\r\n                          } else {\r\n                            result0 = null;\r\n                            pos = pos1;\r\n                          }\r\n                        } else {\r\n                          result0 = null;\r\n                          pos = pos1;\r\n                        }\r\n                      } else {\r\n                        result0 = null;\r\n                        pos = pos1;\r\n                      }\r\n                    } else {\r\n                      result0 = null;\r\n                      pos = pos1;\r\n                    }\r\n                  } else {\r\n                    result0 = null;\r\n                    pos = pos1;\r\n                  }\r\n                } else {\r\n                  result0 = null;\r\n                  pos = pos1;\r\n                }\r\n              } else {\r\n                result0 = null;\r\n                pos = pos1;\r\n              }\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, rx, ry, rot, largeArc, sweep, to) { return [ rx, ry, rot, largeArc, sweep, to.x, to.y ] })(pos0, result0[0], result0[2], result0[4], result0[6], result0[8], result0[10]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_coordinatePair() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_number();\r\n        if (result0 !== null) {\r\n          result1 = parse_commaWsp();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_number();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return { x: a, y: b }; })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_nonnegativeNumber() {\r\n        var result0;\r\n        var pos0;\r\n        \r\n        pos0 = pos;\r\n        result0 = parse_floatingPointConstant();\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, number) { return parseFloat( number, 10 ); })(pos0, result0);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_digitSequence();\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, number) { return parseInt( number, 10 ); })(pos0, result0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_number() {\r\n        var result0, result1;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_sign();\r\n        result0 = result0 !== null ? result0 : \"\";\r\n        if (result0 !== null) {\r\n          result1 = parse_floatingPointConstant();\r\n          if (result1 !== null) {\r\n            result0 = [result0, result1];\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, sign, number) { return parseFloat( sign + number, 10 ); })(pos0, result0[0], result0[1]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = parse_sign();\r\n          result0 = result0 !== null ? result0 : \"\";\r\n          if (result0 !== null) {\r\n            result1 = parse_digitSequence();\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, sign, number) { return parseInt( sign + number, 10 ); })(pos0, result0[0], result0[1]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_flag() {\r\n        var result0;\r\n        var pos0;\r\n        \r\n        pos0 = pos;\r\n        if (input.charCodeAt(pos) === 48) {\r\n          result0 = \"0\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"0\\\"\");\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset) { return false; })(pos0);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          if (input.charCodeAt(pos) === 49) {\r\n            result0 = \"1\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"1\\\"\");\r\n            }\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset) { return true; })(pos0);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_commaWsp() {\r\n        var result0, result1, result2, result3;\r\n        var pos0;\r\n        \r\n        pos0 = pos;\r\n        result1 = parse_wsp();\r\n        if (result1 !== null) {\r\n          result0 = [];\r\n          while (result1 !== null) {\r\n            result0.push(result1);\r\n            result1 = parse_wsp();\r\n          }\r\n        } else {\r\n          result0 = null;\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = parse_comma();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = [];\r\n            result3 = parse_wsp();\r\n            while (result3 !== null) {\r\n              result2.push(result3);\r\n              result3 = parse_wsp();\r\n            }\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos0;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos0;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          result0 = parse_comma();\r\n          if (result0 !== null) {\r\n            result1 = [];\r\n            result2 = parse_wsp();\r\n            while (result2 !== null) {\r\n              result1.push(result2);\r\n              result2 = parse_wsp();\r\n            }\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos0;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_comma() {\r\n        var result0;\r\n        \r\n        if (input.charCodeAt(pos) === 44) {\r\n          result0 = \",\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\",\\\"\");\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_floatingPointConstant() {\r\n        var result0, result1;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_fractionalConstant();\r\n        if (result0 !== null) {\r\n          result1 = parse_exponent();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result0 = [result0, result1];\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return a + b; })(pos0, result0[0], result0[1]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = parse_digitSequence();\r\n          if (result0 !== null) {\r\n            result1 = parse_exponent();\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a, b) { return a + b; })(pos0, result0[0], result0[1]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_fractionalConstant() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_digitSequence();\r\n        result0 = result0 !== null ? result0 : \"\";\r\n        if (result0 !== null) {\r\n          if (input.charCodeAt(pos) === 46) {\r\n            result1 = \".\";\r\n            pos++;\r\n          } else {\r\n            result1 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\".\\\"\");\r\n            }\r\n          }\r\n          if (result1 !== null) {\r\n            result2 = parse_digitSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return a + '.' + b; })(pos0, result0[0], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          pos0 = pos;\r\n          pos1 = pos;\r\n          result0 = parse_digitSequence();\r\n          if (result0 !== null) {\r\n            if (input.charCodeAt(pos) === 46) {\r\n              result1 = \".\";\r\n              pos++;\r\n            } else {\r\n              result1 = null;\r\n              if (reportFailures === 0) {\r\n                matchFailed(\"\\\".\\\"\");\r\n              }\r\n            }\r\n            if (result1 !== null) {\r\n              result0 = [result0, result1];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n          if (result0 !== null) {\r\n            result0 = (function(offset, a) { return a })(pos0, result0[0]);\r\n          }\r\n          if (result0 === null) {\r\n            pos = pos0;\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_exponent() {\r\n        var result0, result1, result2;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        if (input.charCodeAt(pos) === 101) {\r\n          result0 = \"e\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"e\\\"\");\r\n          }\r\n        }\r\n        if (result0 === null) {\r\n          if (input.charCodeAt(pos) === 69) {\r\n            result0 = \"E\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"E\\\"\");\r\n            }\r\n          }\r\n        }\r\n        if (result0 !== null) {\r\n          result1 = parse_sign();\r\n          result1 = result1 !== null ? result1 : \"\";\r\n          if (result1 !== null) {\r\n            result2 = parse_digitSequence();\r\n            if (result2 !== null) {\r\n              result0 = [result0, result1, result2];\r\n            } else {\r\n              result0 = null;\r\n              pos = pos1;\r\n            }\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b, c) { return a + b + c; })(pos0, result0[0], result0[1], result0[2]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_sign() {\r\n        var result0;\r\n        \r\n        if (input.charCodeAt(pos) === 43) {\r\n          result0 = \"+\";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\"+\\\"\");\r\n          }\r\n        }\r\n        if (result0 === null) {\r\n          if (input.charCodeAt(pos) === 45) {\r\n            result0 = \"-\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"-\\\"\");\r\n            }\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_digitSequence() {\r\n        var result0, result1;\r\n        var pos0, pos1;\r\n        \r\n        pos0 = pos;\r\n        pos1 = pos;\r\n        result0 = parse_digit();\r\n        if (result0 !== null) {\r\n          result1 = parse_digitSequence();\r\n          if (result1 !== null) {\r\n            result0 = [result0, result1];\r\n          } else {\r\n            result0 = null;\r\n            pos = pos1;\r\n          }\r\n        } else {\r\n          result0 = null;\r\n          pos = pos1;\r\n        }\r\n        if (result0 !== null) {\r\n          result0 = (function(offset, a, b) { return a + b; })(pos0, result0[0], result0[1]);\r\n        }\r\n        if (result0 === null) {\r\n          pos = pos0;\r\n        }\r\n        if (result0 === null) {\r\n          result0 = parse_digit();\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_digit() {\r\n        var result0;\r\n        \r\n        if (/^[0-9]/.test(input.charAt(pos))) {\r\n          result0 = input.charAt(pos);\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"[0-9]\");\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      function parse_wsp() {\r\n        var result0;\r\n        \r\n        if (input.charCodeAt(pos) === 32) {\r\n          result0 = \" \";\r\n          pos++;\r\n        } else {\r\n          result0 = null;\r\n          if (reportFailures === 0) {\r\n            matchFailed(\"\\\" \\\"\");\r\n          }\r\n        }\r\n        if (result0 === null) {\r\n          if (input.charCodeAt(pos) === 9) {\r\n            result0 = \"\\t\";\r\n            pos++;\r\n          } else {\r\n            result0 = null;\r\n            if (reportFailures === 0) {\r\n              matchFailed(\"\\\"\\\\t\\\"\");\r\n            }\r\n          }\r\n          if (result0 === null) {\r\n            if (input.charCodeAt(pos) === 13) {\r\n              result0 = \"\\r\";\r\n              pos++;\r\n            } else {\r\n              result0 = null;\r\n              if (reportFailures === 0) {\r\n                matchFailed(\"\\\"\\\\r\\\"\");\r\n              }\r\n            }\r\n            if (result0 === null) {\r\n              if (input.charCodeAt(pos) === 10) {\r\n                result0 = \"\\n\";\r\n                pos++;\r\n              } else {\r\n                result0 = null;\r\n                if (reportFailures === 0) {\r\n                  matchFailed(\"\\\"\\\\n\\\"\");\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n        return result0;\r\n      }\r\n      \r\n      \r\n      function cleanupExpected(expected) {\r\n        expected.sort();\r\n        \r\n        var lastExpected = null;\r\n        var cleanExpected = [];\r\n        for (var i = 0; i < expected.length; i++) {\r\n          if (expected[i] !== lastExpected) {\r\n            cleanExpected.push(expected[i]);\r\n            lastExpected = expected[i];\r\n          }\r\n        }\r\n        return cleanExpected;\r\n      }\r\n      \r\n      function computeErrorPosition() {\r\n        /*\r\n         * The first idea was to use |String.split| to break the input up to the\r\n         * error position along newlines and derive the line and column from\r\n         * there. However IE's |split| implementation is so broken that it was\r\n         * enough to prevent it.\r\n         */\r\n        \r\n        var line = 1;\r\n        var column = 1;\r\n        var seenCR = false;\r\n        \r\n        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {\r\n          var ch = input.charAt(i);\r\n          if (ch === \"\\n\") {\r\n            if (!seenCR) { line++; }\r\n            column = 1;\r\n            seenCR = false;\r\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\r\n            line++;\r\n            column = 1;\r\n            seenCR = true;\r\n          } else {\r\n            column++;\r\n            seenCR = false;\r\n          }\r\n        }\r\n        \r\n        return { line: line, column: column };\r\n      }\r\n      \r\n      \r\n        function createMoveTo( args, isRelative ) {\r\n          var result = [ {\r\n            cmd: isRelative ? 'moveToRelative' : 'moveTo',\r\n            args: [ args[0].x, args[0].y ]\r\n          } ];\r\n          \r\n          // any other coordinate pairs are implicit lineTos\r\n          if ( args.length > 1 ) {\r\n            for ( var i = 1; i < args.length; i++ ) {\r\n              result.push( {\r\n                cmd: isRelative ? 'lineToRelative' : 'lineTo',\r\n                args: [ args[i].x, args[i].y ]\r\n              } );\r\n            }\r\n          }\r\n          return result;\r\n        }\r\n      \r\n      \r\n      var result = parseFunctions[startRule]();\r\n      \r\n      /*\r\n       * The parser is now in one of the following three states:\r\n       *\r\n       * 1. The parser successfully parsed the whole input.\r\n       *\r\n       *    - |result !== null|\r\n       *    - |pos === input.length|\r\n       *    - |rightmostFailuresExpected| may or may not contain something\r\n       *\r\n       * 2. The parser successfully parsed only a part of the input.\r\n       *\r\n       *    - |result !== null|\r\n       *    - |pos < input.length|\r\n       *    - |rightmostFailuresExpected| may or may not contain something\r\n       *\r\n       * 3. The parser did not successfully parse any part of the input.\r\n       *\r\n       *   - |result === null|\r\n       *   - |pos === 0|\r\n       *   - |rightmostFailuresExpected| contains at least one failure\r\n       *\r\n       * All code following this comment (including called functions) must\r\n       * handle these states.\r\n       */\r\n      if (result === null || pos !== input.length) {\r\n        var offset = Math.max(pos, rightmostFailuresPos);\r\n        var found = offset < input.length ? input.charAt(offset) : null;\r\n        var errorPosition = computeErrorPosition();\r\n        \r\n        throw new this.SyntaxError(\r\n          cleanupExpected(rightmostFailuresExpected),\r\n          found,\r\n          offset,\r\n          errorPosition.line,\r\n          errorPosition.column\r\n        );\r\n      }\r\n      \r\n      return result;\r\n    },\r\n    \r\n    /* Returns the parser source code. */\r\n    toSource: function() { return this._source; }\r\n  };\r\n  var result = kite.svgPath;\r\n  \r\n  /* Thrown when a parser encounters a syntax error. */\r\n  \r\n  result.SyntaxError = function(expected, found, offset, line, column) {\r\n    function buildMessage(expected, found) {\r\n      var expectedHumanized, foundHumanized;\r\n      \r\n      switch (expected.length) {\r\n        case 0:\r\n          expectedHumanized = \"end of input\";\r\n          break;\r\n        case 1:\r\n          expectedHumanized = expected[0];\r\n          break;\r\n        default:\r\n          expectedHumanized = expected.slice(0, expected.length - 1).join(\", \")\r\n            + \" or \"\r\n            + expected[expected.length - 1];\r\n      }\r\n      \r\n      foundHumanized = found ? quote(found) : \"end of input\";\r\n      \r\n      return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\r\n    }\r\n    \r\n    this.name = \"SyntaxError\";\r\n    this.expected = expected;\r\n    this.found = found;\r\n    this.message = buildMessage(expected, found);\r\n    this.offset = offset;\r\n    this.line = line;\r\n    this.column = column;\r\n  };\r\n  \r\n  result.SyntaxError.prototype = Error.prototype;\r\n  \r\n  return result;\r\n});\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Styles needed to determine a stroked line shape.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/util/LineStyles',['require','ASSERT/assert','KITE/kite'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n  \r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  kite.LineStyles = function( args ) {\r\n    if ( args === undefined ) {\r\n      args = {};\r\n    }\r\n    this.lineWidth = args.lineWidth !== undefined ? args.lineWidth : 1;\r\n    this.lineCap = args.lineCap !== undefined ? args.lineCap : 'butt'; // butt, round, square\r\n    this.lineJoin = args.lineJoin !== undefined ? args.lineJoin : 'miter'; // miter, round, bevel\r\n    this.lineDash = args.lineDash !== undefined ? args.lineDash : null; // null is default, otherwise an array of numbers\r\n    this.lineDashOffset = args.lineDashOffset !== undefined ? args.lineDashOffset : 0; // 0 default, any number\r\n    this.miterLimit = args.miterLimit !== undefined ? args.miterLimit : 10; // see https://svgwg.org/svg2-draft/painting.html for miterLimit computations\r\n  };\r\n  var LineStyles = kite.LineStyles;\r\n  LineStyles.prototype = {\r\n    constructor: LineStyles,\r\n    \r\n    equals: function( other ) {\r\n      var typical = this.lineWidth === other.lineWidth &&\r\n                    this.lineCap === other.lineCap &&\r\n                    this.lineJoin === other.lineJoin &&\r\n                    this.miterLimit === other.miterLimit &&\r\n                    this.lineDashOffset === other.lineDashOffset;\r\n      if ( !typical ) {\r\n        return false;\r\n      }\r\n      \r\n      // now we need to compare the line dashes\r\n      /* jshint -W018 */\r\n      //jshint -W018\r\n      if ( !this.lineDash !== !other.lineDash ) {\r\n        // one is defined, the other is not\r\n        return false;\r\n      }\r\n      \r\n      if ( this.lineDash ) {\r\n        if ( this.lineDash.length !== other.lineDash.length ) {\r\n          return false;\r\n        }\r\n        for ( var i = 0; i < this.lineDash.length; i++ ) {\r\n          if ( this.lineDash[i] !== other.lineDash[i] ) {\r\n            return false;\r\n          }\r\n        }\r\n        return true;\r\n      } else {\r\n        // both have no line dash, so they are equal\r\n        return true;\r\n      }\r\n    }\r\n  };\r\n  \r\n  return kite.LineStyles;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Quadratic Bezier segment\r\n *\r\n * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/Quadratic',['require','ASSERT/assert','KITE/kite','PHET_CORE/inherit','DOT/Bounds2','DOT/Matrix3','DOT/Util','KITE/segments/Segment'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;\r\n\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n\r\n  Segment.Quadratic = function Quadratic( start, control, end, skipComputations ) {\r\n    this.start = start;\r\n    this.control = control;\r\n    this.end = end;\r\n    \r\n    if ( start.equals( end ) && start.equals( control ) ) {\r\n      this.invalid = true;\r\n      return;\r\n    }\r\n    \r\n    var t;\r\n    \r\n    // allows us to skip unnecessary computation in the subdivision steps\r\n    if ( skipComputations ) {\r\n      return;\r\n    }\r\n    \r\n    var controlIsStart = start.equals( control );\r\n    var controlIsEnd = end.equals( control );\r\n    // ensure the points are distinct\r\n    assert && assert( !controlIsStart || !controlIsEnd );\r\n    \r\n    // allow either the start or end point to be the same as the control point (necessary if you do a quadraticCurveTo on an empty path)\r\n    // tangents go through the control point, which simplifies things\r\n    this.startTangent = controlIsStart ? end.minus( start ).normalized() : control.minus( start ).normalized();\r\n    this.endTangent = controlIsEnd ? end.minus( start ).normalized() : end.minus( control ).normalized();\r\n    \r\n    // calculate our temporary guaranteed lower bounds based on the end points\r\n    this.bounds = new Bounds2( Math.min( start.x, end.x ), Math.min( start.y, end.y ), Math.max( start.x, end.x ), Math.max( start.y, end.y ) );\r\n    \r\n    // compute x and y where the derivative is 0, so we can include this in the bounds\r\n    var divisorX = 2 * ( end.x - 2 * control.x + start.x );\r\n    if ( divisorX !== 0 ) {\r\n      this.tCriticalX = -2 * ( control.x - start.x ) / divisorX;\r\n      \r\n      if ( t > 0 && t < 1 ) {\r\n        this.bounds = this.bounds.withPoint( this.positionAt( this.tCriticalX ) );\r\n      }\r\n    }\r\n    var divisorY = 2 * ( end.y - 2 * control.y + start.y );\r\n    if ( divisorY !== 0 ) {\r\n      this.tCriticalY = -2 * ( control.y - start.y ) / divisorY;\r\n      \r\n      if ( t > 0 && t < 1 ) {\r\n        this.bounds = this.bounds.withPoint( this.positionAt( this.tCriticalY ) );\r\n      }\r\n    }\r\n  };\r\n  inherit( Segment, Segment.Quadratic, {\r\n    \r\n    degree: 2,\r\n    \r\n    // can be described from t=[0,1] as: (1-t)^2 start + 2(1-t)t control + t^2 end\r\n    positionAt: function( t ) {\r\n      var mt = 1 - t;\r\n      return this.start.times( mt * mt ).plus( this.control.times( 2 * mt * t ) ).plus( this.end.times( t * t ) );\r\n    },\r\n    \r\n    // derivative: 2(1-t)( control - start ) + 2t( end - control )\r\n    tangentAt: function( t ) {\r\n      return this.control.minus( this.start ).times( 2 * ( 1 - t ) ).plus( this.end.minus( this.control ).times( 2 * t ) );\r\n    },\r\n    \r\n    curvatureAt: function( t ) {\r\n      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31\r\n      // TODO: remove code duplication with Cubic\r\n      var epsilon = 0.0000001;\r\n      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {\r\n        var isZero = t < 0.5;\r\n        var p0 = isZero ? this.start : this.end;\r\n        var p1 = this.control;\r\n        var p2 = isZero ? this.end : this.start;\r\n        var d10 = p1.minus( p0 );\r\n        var a = d10.magnitude();\r\n        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );\r\n        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );\r\n      } else {\r\n        return this.subdivided( t, true )[0].curvatureAt( 1 );\r\n      }\r\n    },\r\n    \r\n    // see http://www.visgraf.impa.br/sibgrapi96/trabs/pdf/a14.pdf\r\n    // and http://math.stackexchange.com/questions/12186/arc-length-of-bezier-curves for curvature / arc length\r\n    \r\n    offsetTo: function( r, reverse ) {\r\n      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html\r\n      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n      var curves = [this];\r\n      \r\n      // subdivide this curve\r\n      var depth = 5; // generates 2^depth curves\r\n      for ( var i = 0; i < depth; i++ ) {\r\n        curves = _.flatten( _.map( curves, function( curve ) {\r\n          return curve.subdivided( 0.5, true );\r\n        } ));\r\n      }\r\n      \r\n      var offsetCurves = _.map( curves, function( curve ) { return curve.approximateOffset( r ); } );\r\n      \r\n      if ( reverse ) {\r\n        offsetCurves.reverse();\r\n        offsetCurves = _.map( offsetCurves, function( curve ) { return curve.reversed( true ); } );\r\n      }\r\n      \r\n      return offsetCurves;\r\n    },\r\n    \r\n    subdivided: function( t, skipComputations ) {\r\n      // de Casteljau method\r\n      var leftMid = this.start.blend( this.control, t );\r\n      var rightMid = this.control.blend( this.end, t );\r\n      var mid = leftMid.blend( rightMid, t );\r\n      return [\r\n        new Segment.Quadratic( this.start, leftMid, mid, skipComputations ),\r\n        new Segment.Quadratic( mid, rightMid, this.end, skipComputations )\r\n      ];\r\n    },\r\n    \r\n    reversed: function( skipComputations ) {\r\n      return new Segment.Quadratic( this.end, this.control, this.start );\r\n    },\r\n    \r\n    approximateOffset: function( r ) {\r\n      return new Segment.Quadratic(\r\n        this.start.plus( ( this.start.equals( this.control ) ? this.end.minus( this.start ) : this.control.minus( this.start ) ).perpendicular().normalized().times( r ) ),\r\n        this.control.plus( this.end.minus( this.start ).perpendicular().normalized().times( r ) ),\r\n        this.end.plus( ( this.end.equals( this.control ) ? this.end.minus( this.start ) : this.end.minus( this.control ) ).perpendicular().normalized().times( r ) )\r\n      );\r\n    },\r\n    \r\n    getSVGPathFragment: function() {\r\n      return 'Q ' + this.control.x + ' ' + this.control.y + ' ' + this.end.x + ' ' + this.end.y;\r\n    },\r\n    \r\n    strokeLeft: function( lineWidth ) {\r\n      return this.offsetTo( -lineWidth / 2, false );\r\n    },\r\n    \r\n    strokeRight: function( lineWidth ) {\r\n      return this.offsetTo( lineWidth / 2, true );\r\n    },\r\n    \r\n    getInteriorExtremaTs: function() {\r\n      var result = [];\r\n      var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n      if ( this.tCriticalX !== undefined && this.tCriticalX > epsilon && this.tCriticalX < 1 - epsilon ) {\r\n        result.push( this.tCriticalX );\r\n      }\r\n      if ( this.tCriticalY !== undefined && this.tCriticalY > epsilon && this.tCriticalY < 1 - epsilon ) {\r\n        result.push( this.tCriticalY );\r\n      }\r\n      return result.sort();\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.Quadratic.intersectsBounds unimplemented' ); // TODO: implement\r\n    },\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    intersection: function( ray ) {\r\n      var self = this;\r\n      var result = [];\r\n      \r\n      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections\r\n      var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() ).timesMatrix( Matrix3.translation( -ray.pos.x, -ray.pos.y ) );\r\n      \r\n      var p0 = inverseMatrix.timesVector2( this.start );\r\n      var p1 = inverseMatrix.timesVector2( this.control );\r\n      var p2 = inverseMatrix.timesVector2( this.end );\r\n      \r\n      //(1-t)^2 start + 2(1-t)t control + t^2 end\r\n      var a = p0.y - 2 * p1.y + p2.y;\r\n      var b = -2 * p0.y + 2 * p1.y;\r\n      var c = p0.y;\r\n      \r\n      var ts = solveQuadraticRootsReal( a, b, c );\r\n      \r\n      _.each( ts, function( t ) {\r\n        if ( t >= 0 && t <= 1 ) {\r\n          var hitPoint = self.positionAt( t );\r\n          var unitTangent = self.tangentAt( t ).normalized();\r\n          var perp = unitTangent.perpendicular();\r\n          var toHit = hitPoint.minus( ray.pos );\r\n          \r\n          // make sure it's not behind the ray\r\n          if ( toHit.dot( ray.dir ) > 0 ) {\r\n            result.push( {\r\n              distance: toHit.magnitude(),\r\n              point: hitPoint,\r\n              normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,\r\n              wind: ray.dir.perpendicular().dot( unitTangent ) < 0 ? 1 : -1\r\n            } );\r\n          }\r\n        }\r\n      } );\r\n      return result;\r\n    },\r\n    \r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      var hits = this.intersection( ray );\r\n      _.each( hits, function( hit ) {\r\n        wind += hit.wind;\r\n      } );\r\n      return wind;\r\n    },\r\n    \r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      context.quadraticCurveTo( this.control.x, this.control.y, this.end.x, this.end.y );\r\n    },\r\n    \r\n    transformed: function( matrix ) {\r\n      return new Segment.Quadratic( matrix.timesVector2( this.start ), matrix.timesVector2( this.control ), matrix.timesVector2( this.end ) );\r\n    }\r\n  } );\r\n  \r\n  return Segment.Quadratic;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Cubic Bezier segment.\r\n *\r\n * See http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf for info\r\n *\r\n * Good reference: http://cagd.cs.byu.edu/~557/text/ch2.pdf\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/Cubic',['require','ASSERT/assert','KITE/kite','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','DOT/Util','DOT/Util','KITE/segments/Segment','KITE/segments/Quadratic'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var solveQuadraticRootsReal = require( 'DOT/Util' ).solveQuadraticRootsReal;\r\n  var solveCubicRootsReal = require( 'DOT/Util' ).solveCubicRootsReal;\r\n  \r\n  var Segment = require( 'KITE/segments/Segment' );\r\n  require( 'KITE/segments/Quadratic' );\r\n\r\n  Segment.Cubic = function Cubic( start, control1, control2, end, skipComputations ) {\r\n    this.start = start;\r\n    this.control1 = control1;\r\n    this.control2 = control2;\r\n    this.end = end;\r\n    \r\n    // allows us to skip unnecessary computation in the subdivision steps\r\n    if ( skipComputations ) {\r\n      return;\r\n    }\r\n    \r\n    if ( start.equals( end, 0 ) && start.equals( control1, 0 ) && start.equals( control2, 0 ) ) {\r\n      this.invalid = true;\r\n      return;\r\n    }\r\n    \r\n    this.startTangent = this.tangentAt( 0 ).normalized();\r\n    this.endTangent = this.tangentAt( 1 ).normalized();\r\n    \r\n    // from http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n    this.r = control1.minus( start ).normalized();\r\n    this.s = this.r.perpendicular();\r\n    \r\n    var a = start.times( -1 ).plus( control1.times( 3 ) ).plus( control2.times( -3 ) ).plus( end );\r\n    var b = start.times( 3 ).plus( control1.times( -6 ) ).plus( control2.times( 3 ) );\r\n    var c = start.times( -3 ).plus( control1.times( 3 ) );\r\n    var d = start;\r\n    \r\n    var aPerp = a.perpendicular();\r\n    var bPerp = b.perpendicular();\r\n    var aPerpDotB = aPerp.dot( b );\r\n    \r\n    this.tCusp = -0.5 * ( aPerp.dot( c ) / aPerpDotB );\r\n    this.tDeterminant = this.tCusp * this.tCusp - ( 1 / 3 ) * ( bPerp.dot( c ) / aPerpDotB );\r\n    if ( this.tDeterminant >= 0 ) {\r\n      var sqrtDet = Math.sqrt( this.tDeterminant );\r\n      this.tInflection1 = this.tCusp - sqrtDet;\r\n      this.tInflection2 = this.tCusp + sqrtDet;\r\n    }\r\n    \r\n    if ( this.hasCusp() ) {\r\n      // if there is a cusp, we'll split at the cusp into two quadratic bezier curves.\r\n      // see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.94.8088&rep=rep1&type=pdf (Singularities of rational Bezier curves - J Monterde, 2001)\r\n      var subdividedAtCusp = this.subdivided( this.tCusp, true );\r\n      this.startQuadratic = new Segment.Quadratic( subdividedAtCusp[0].start, subdividedAtCusp[0].control1, subdividedAtCusp[0].end, false );\r\n      this.endQuadratic = new Segment.Quadratic( subdividedAtCusp[1].start, subdividedAtCusp[1].control2, subdividedAtCusp[1].end, false );\r\n    }\r\n    \r\n    this.bounds = Bounds2.NOTHING;\r\n    this.bounds = this.bounds.withPoint( this.start );\r\n    this.bounds = this.bounds.withPoint( this.end );\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Bounds\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // finds what t values the cubic extrema are at (if any).\r\n    function extremaT( v0, v1, v2, v3 ) {\r\n      // coefficients of derivative\r\n      var a = -3 * v0 + 9 * v1 -9 * v2 + 3 * v3;\r\n      var b =  6 * v0 - 12 * v1 + 6 * v2;\r\n      var c = -3 * v0 + 3 * v1;\r\n      \r\n      return solveQuadraticRootsReal( a, b, c );\r\n    }\r\n    \r\n    var cubic = this;\r\n    this.xExtremaT = extremaT( this.start.x, this.control1.x, this.control2.x, this.end.x );\r\n    _.each( this.xExtremaT, function( t ) {\r\n      if ( t >= 0 && t <= 1 ) {\r\n        cubic.bounds = cubic.bounds.withPoint( cubic.positionAt( t ) );\r\n      }\r\n    } );\r\n    this.yExtremaT = extremaT( this.start.y, this.control1.y, this.control2.y, this.end.y );\r\n    _.each( this.yExtremaT, function( t ) {\r\n      if ( t >= 0 && t <= 1 ) {\r\n        cubic.bounds = cubic.bounds.withPoint( cubic.positionAt( t ) );\r\n      }\r\n    } );\r\n    \r\n    if ( this.hasCusp() ) {\r\n      this.bounds = this.bounds.withPoint( this.positionAt( this.tCusp ) );\r\n    }\r\n  };\r\n  inherit( Segment, Segment.Cubic, {\r\n    \r\n    degree: 3,\r\n    \r\n    hasCusp: function() {\r\n      var epsilon = 0.000001; // TODO: make this available to change?\r\n      return this.tangentAt( this.tCusp ).magnitude() < epsilon && this.tCusp >= 0 && this.tCusp <= 1;\r\n    },\r\n    \r\n    // position: (1 - t)^3*start + 3*(1 - t)^2*t*control1 + 3*(1 - t) t^2*control2 + t^3*end\r\n    positionAt: function( t ) {\r\n      var mt = 1 - t;\r\n      return this.start.times( mt * mt * mt ).plus( this.control1.times( 3 * mt * mt * t ) ).plus( this.control2.times( 3 * mt * t * t ) ).plus( this.end.times( t * t * t ) );\r\n    },\r\n    \r\n    // derivative: -3 p0 (1 - t)^2 + 3 p1 (1 - t)^2 - 6 p1 (1 - t) t + 6 p2 (1 - t) t - 3 p2 t^2 + 3 p3 t^2\r\n    tangentAt: function( t ) {\r\n      var mt = 1 - t;\r\n      return this.start.times( -3 * mt * mt ).plus( this.control1.times( 3 * mt * mt - 6 * mt * t ) ).plus( this.control2.times( 6 * mt * t - 3 * t * t ) ).plus( this.end.times( 3 * t * t ) );\r\n    },\r\n    \r\n    curvatureAt: function( t ) {\r\n      // see http://cagd.cs.byu.edu/~557/text/ch2.pdf p31\r\n      // TODO: remove code duplication with Quadratic\r\n      var epsilon = 0.0000001;\r\n      if ( Math.abs( t - 0.5 ) > 0.5 - epsilon ) {\r\n        var isZero = t < 0.5;\r\n        var p0 = isZero ? this.start : this.end;\r\n        var p1 = isZero ? this.control1 : this.control2;\r\n        var p2 = isZero ? this.control2 : this.control1;\r\n        var d10 = p1.minus( p0 );\r\n        var a = d10.magnitude();\r\n        var h = ( isZero ? -1 : 1 ) * d10.perpendicular().normalized().dot( p2.minus( p1 ) );\r\n        return ( h * ( this.degree - 1 ) ) / ( this.degree * a * a );\r\n      } else {\r\n        return this.subdivided( t, true )[0].curvatureAt( 1 );\r\n      }\r\n    },\r\n    \r\n    toRS: function( point ) {\r\n      var firstVector = point.minus( this.start );\r\n      return new Vector2( firstVector.dot( this.r ), firstVector.dot( this.s ) );\r\n    },\r\n    \r\n    subdivided: function( t, skipComputations ) {\r\n      // de Casteljau method\r\n      // TODO: add a 'bisect' or 'between' method for vectors?\r\n      var left = this.start.blend( this.control1, t );\r\n      var right = this.control2.blend( this.end, t );\r\n      var middle = this.control1.blend( this.control2, t );\r\n      var leftMid = left.blend( middle, t );\r\n      var rightMid = middle.blend( right, t );\r\n      var mid = leftMid.blend( rightMid, t );\r\n      return [\r\n        new Segment.Cubic( this.start, left, leftMid, mid, skipComputations ),\r\n        new Segment.Cubic( mid, rightMid, right, this.end, skipComputations )\r\n      ];\r\n    },\r\n    \r\n    offsetTo: function( r, reverse ) {\r\n      // TODO: implement more accurate method at http://www.antigrain.com/research/adaptive_bezier/index.html\r\n      // TODO: or more recently (and relevantly): http://www.cis.usouthal.edu/~hain/general/Publications/Bezier/BezierFlattening.pdf\r\n      \r\n      // how many segments to create (possibly make this more adaptive?)\r\n      var quantity = 32;\r\n      \r\n      var points = [];\r\n      var result = [];\r\n      for ( var i = 0; i < quantity; i++ ) {\r\n        var t = i / ( quantity - 1 );\r\n        if ( reverse ) {\r\n          t = 1 - t;\r\n        }\r\n        \r\n        points.push( this.positionAt( t ).plus( this.tangentAt( t ).perpendicular().normalized().times( r ) ) );\r\n        if ( i > 0 ) {\r\n          result.push( new Segment.Line( points[i-1], points[i] ) );\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    },\r\n    \r\n    getSVGPathFragment: function() {\r\n      return 'C ' + this.control1.x + ' ' + this.control1.y + ' ' + this.control2.x + ' ' + this.control2.y + ' ' + this.end.x + ' ' + this.end.y;\r\n    },\r\n    \r\n    strokeLeft: function( lineWidth ) {\r\n      return this.offsetTo( -lineWidth / 2, false );\r\n    },\r\n    \r\n    strokeRight: function( lineWidth ) {\r\n      return this.offsetTo( lineWidth / 2, true );\r\n    },\r\n    \r\n    getInteriorExtremaTs: function() {\r\n      var ts = this.xExtremaT.concat( this.yExtremaT );\r\n      var result = [];\r\n      _.each( ts, function( t ) {\r\n        var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n        if ( t > epsilon && t < 1 - epsilon ) {\r\n          // don't add duplicate t values\r\n          if ( _.every( result, function( otherT ) { return Math.abs( t - otherT ) > epsilon; } ) ) {\r\n            result.push( t );\r\n          }\r\n        }\r\n      } );\r\n      return result.sort();\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.Cubic.intersectsBounds unimplemented' ); // TODO: implement\r\n    },\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    intersection: function( ray ) {\r\n      var self = this;\r\n      var result = [];\r\n      \r\n      // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections\r\n      var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() ).timesMatrix( Matrix3.translation( -ray.pos.x, -ray.pos.y ) );\r\n      \r\n      var p0 = inverseMatrix.timesVector2( this.start );\r\n      var p1 = inverseMatrix.timesVector2( this.control1 );\r\n      var p2 = inverseMatrix.timesVector2( this.control2 );\r\n      var p3 = inverseMatrix.timesVector2( this.end );\r\n      \r\n      // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3\r\n      var a = -p0.y + 3 * p1.y - 3 * p2.y + p3.y;\r\n      var b = 3 * p0.y - 6 * p1.y + 3 * p2.y;\r\n      var c = -3 * p0.y + 3 * p1.y;\r\n      var d = p0.y;\r\n      \r\n      var ts = solveCubicRootsReal( a, b, c, d );\r\n      \r\n      _.each( ts, function( t ) {\r\n        if ( t >= 0 && t <= 1 ) {\r\n          var hitPoint = self.positionAt( t );\r\n          var unitTangent = self.tangentAt( t ).normalized();\r\n          var perp = unitTangent.perpendicular();\r\n          var toHit = hitPoint.minus( ray.pos );\r\n          \r\n          // make sure it's not behind the ray\r\n          if ( toHit.dot( ray.dir ) > 0 ) {\r\n            result.push( {\r\n              distance: toHit.magnitude(),\r\n              point: hitPoint,\r\n              normal: perp.dot( ray.dir ) > 0 ? perp.negated() : perp,\r\n              wind: ray.dir.perpendicular().dot( unitTangent ) < 0 ? 1 : -1\r\n            } );\r\n          }\r\n        }\r\n      } );\r\n      return result;\r\n    },\r\n    \r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      var hits = this.intersection( ray );\r\n      _.each( hits, function( hit ) {\r\n        wind += hit.wind;\r\n      } );\r\n      return wind;\r\n    },\r\n    \r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      context.bezierCurveTo( this.control1.x, this.control1.y, this.control2.x, this.control2.y, this.end.x, this.end.y );\r\n    },\r\n    \r\n    transformed: function( matrix ) {\r\n      return new Segment.Cubic( matrix.timesVector2( this.start ), matrix.timesVector2( this.control1 ), matrix.timesVector2( this.control2 ), matrix.timesVector2( this.end ) );\r\n    }\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    // windingIntersection: function( ray ) {\r\n    //   // find the rotation that will put our ray in the direction of the x-axis so we can only solve for y=0 for intersections\r\n    //   var inverseMatrix = Matrix3.rotation2( -ray.dir.angle() );\r\n    //   assert && assert( inverseMatrix.timesVector2( ray.dir ).x > 0.99 ); // verify that we transform the unit vector to the x-unit\r\n      \r\n    //   var y0 = inverseMatrix.timesVector2( this.start ).y;\r\n    //   var y1 = inverseMatrix.timesVector2( this.control1 ).y;\r\n    //   var y2 = inverseMatrix.timesVector2( this.control2 ).y;\r\n    //   var y3 = inverseMatrix.timesVector2( this.end ).y;\r\n      \r\n    //   // polynomial form of cubic: start + (3 control1 - 3 start) t + (-6 control1 + 3 control2 + 3 start) t^2 + (3 control1 - 3 control2 + end - start) t^3\r\n    //   var a = -y0 + 3 * y1 - 3 * y2 + y3;\r\n    //   var b = 3 * y0 - 6 * y1 + 3 * y2;\r\n    //   var c = -3 * y0 + 3 * y1;\r\n    //   var d = y0;\r\n      \r\n    //   // solve cubic roots\r\n    //   var ts = solveCubicRootsReal( a, b, c, d );\r\n      \r\n    //   var result = 0;\r\n      \r\n    //   // for each hit\r\n    //   _.each( ts, function( t ) {\r\n    //     if ( t >= 0 && t <= 1 ) {\r\n    //       result += ray.dir.perpendicular().dot( this.tangentAt( t ) ) < 0 ? 1 : -1;\r\n    //     }\r\n    //   } );\r\n      \r\n    //   return result;\r\n    // }\r\n  } );\r\n  \r\n  return Segment.Cubic;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Elliptical arc segment\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/segments/EllipticalArc',['require','ASSERT/assert','KITE/kite','PHET_CORE/inherit','DOT/Vector2','DOT/Bounds2','DOT/Matrix3','DOT/Transform3','DOT/Util','DOT/Util','KITE/segments/Segment','KITE/util/Subpath'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n\r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  var toDegrees = require( 'DOT/Util' ).toDegrees;\r\n  var DotUtil = require( 'DOT/Util' );\r\n\r\n  var Segment = require( 'KITE/segments/Segment' );\r\n  require( 'KITE/util/Subpath' );\r\n\r\n  // TODO: notes at http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes\r\n  // Canvas notes at http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-ellipse\r\n  Segment.EllipticalArc = function EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {\r\n    if ( radiusX < 0 ) {\r\n      // support this case since we might actually need to handle it inside of strokes?\r\n      radiusX = -radiusX;\r\n      startAngle = Math.PI - startAngle;\r\n      endAngle = Math.PI - endAngle;\r\n      anticlockwise = !anticlockwise;\r\n    }\r\n    if ( radiusY < 0 ) {\r\n      // support this case since we might actually need to handle it inside of strokes?\r\n      radiusY = -radiusY;\r\n      startAngle = -startAngle;\r\n      endAngle = -endAngle;\r\n      anticlockwise = !anticlockwise;\r\n    }\r\n    if ( radiusX < radiusY ) {\r\n      // swap radiusX and radiusY internally for consistent Canvas / SVG output\r\n      rotation += Math.PI / 2;\r\n      startAngle -= Math.PI / 2;\r\n      endAngle -= Math.PI / 2;\r\n      \r\n      // swap radiusX and radiusY\r\n      var tmpR = radiusX;\r\n      radiusX = radiusY;\r\n      radiusY = tmpR;\r\n    }\r\n    \r\n    this.center = center;\r\n    this.radiusX = radiusX;\r\n    this.radiusY = radiusY;\r\n    this.rotation = rotation;\r\n    this.startAngle = startAngle;\r\n    this.endAngle = endAngle;\r\n    this.anticlockwise = anticlockwise;\r\n    \r\n    this.unitTransform = Segment.EllipticalArc.computeUnitTransform( center, radiusX, radiusY, rotation );\r\n    \r\n    this.start = this.positionAtAngle( startAngle );\r\n    this.end = this.positionAtAngle( endAngle );\r\n    this.startTangent = this.tangentAtAngle( startAngle ).normalized();\r\n    this.endTangent = this.tangentAtAngle( endAngle ).normalized();\r\n    \r\n    if ( radiusX === 0 || radiusY === 0 || startAngle === endAngle ) {\r\n      this.invalid = true;\r\n      return;\r\n    }\r\n    \r\n    if ( radiusX < radiusY ) {\r\n      // TODO: check this\r\n      throw new Error( 'Not verified to work if radiusX < radiusY' );\r\n    }\r\n    \r\n    // compute an actual end angle so that we can smoothly go from this.startAngle to this.actualEndAngle\r\n    if ( this.anticlockwise ) {\r\n      // angle is 'decreasing'\r\n      // -2pi <= end - start < 2pi\r\n      if ( this.startAngle > this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle;\r\n      } else if ( this.startAngle < this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle - 2 * Math.PI;\r\n      } else {\r\n        // equal\r\n        this.actualEndAngle = this.startAngle;\r\n      }\r\n    } else {\r\n      // angle is 'increasing'\r\n      // -2pi < end - start <= 2pi\r\n      if ( this.startAngle < this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle;\r\n      } else if ( this.startAngle > this.endAngle ) {\r\n        this.actualEndAngle = this.endAngle + Math.PI * 2;\r\n      } else {\r\n        // equal\r\n        this.actualEndAngle = this.startAngle;\r\n      }\r\n    }\r\n    \r\n    // constraints shared with Segment.Arc\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle <= -Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle <= -Math.PI * 2 ) ), 'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );\r\n    assert && assert( !( ( !anticlockwise && endAngle - startAngle > Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle > Math.PI * 2 ) ), 'Not handling elliptical arcs with start/end angles that show differences in-between browser handling' );\r\n    \r\n    var isFullPerimeter = ( !anticlockwise && endAngle - startAngle >= Math.PI * 2 ) || ( anticlockwise && startAngle - endAngle >= Math.PI * 2 );\r\n    \r\n    // compute an angle difference that represents how \"much\" of the circle our arc covers\r\n    this.angleDifference = this.anticlockwise ? this.startAngle - this.endAngle : this.endAngle - this.startAngle;\r\n    if ( this.angleDifference < 0 ) {\r\n      this.angleDifference += Math.PI * 2;\r\n    }\r\n    assert && assert( this.angleDifference >= 0 ); // now it should always be zero or positive\r\n    \r\n    // a unit arg segment that we can map to our ellipse. useful for hit testing and such.\r\n    this.unitArcSegment = new Segment.Arc( Vector2.ZERO, 1, startAngle, endAngle, anticlockwise );\r\n    \r\n    this.bounds = Bounds2.NOTHING;\r\n    this.bounds = this.bounds.withPoint( this.start );\r\n    this.bounds = this.bounds.withPoint( this.end );\r\n    \r\n    // for bounds computations\r\n    var that = this;\r\n    function boundsAtAngle( angle ) {\r\n      if ( that.containsAngle( angle ) ) {\r\n        // the boundary point is in the arc\r\n        that.bounds = that.bounds.withPoint( that.positionAtAngle( angle ) );\r\n      }\r\n    }\r\n    \r\n    // if the angles are different, check extrema points\r\n    if ( startAngle !== endAngle ) {\r\n      // solve the mapping from the unit circle, find locations where a coordinate of the gradient is zero.\r\n      // we find one extrema point for both x and y, since the other two are just rotated by pi from them.\r\n      var xAngle = Math.atan( -( radiusY / radiusX ) * Math.tan( rotation ) );\r\n      var yAngle = Math.atan( ( radiusY / radiusX ) / Math.tan( rotation ) );\r\n      \r\n      // check all of the extrema points\r\n      this.possibleExtremaAngles = [\r\n        xAngle,\r\n        xAngle + Math.PI,\r\n        yAngle,\r\n        yAngle + Math.PI\r\n      ];\r\n      \r\n      _.each( this.possibleExtremaAngles, boundsAtAngle );\r\n    }\r\n  };\r\n  inherit( Segment, Segment.EllipticalArc, {\r\n    \r\n    // maps a contained angle to between [startAngle,actualEndAngle), even if the end angle is lower.\r\n    mapAngle: function( angle ) {\r\n      // consider an assert that we contain that angle?\r\n      return ( this.startAngle > this.actualEndAngle ) ?\r\n             DotUtil.moduloBetweenUp( angle, this.startAngle - 2 * Math.PI, this.startAngle ) :\r\n             DotUtil.moduloBetweenDown( angle, this.startAngle, this.startAngle + 2 * Math.PI );\r\n    },\r\n    \r\n    tAtAngle: function( angle ) {\r\n      return ( this.mapAngle( angle ) - this.startAngle ) / ( this.actualEndAngle - this.startAngle );\r\n    },\r\n    \r\n    angleAt: function( t ) {\r\n      return this.startAngle + ( this.actualEndAngle - this.startAngle ) * t;\r\n    },\r\n    \r\n    positionAt: function( t ) {\r\n      return this.positionAtAngle( this.angleAt( t ) );\r\n    },\r\n    \r\n    tangentAt: function( t ) {\r\n      return this.tangentAtAngle( this.angleAt( t ) );\r\n    },\r\n    \r\n    curvatureAt: function( t ) {\r\n      // see http://mathworld.wolfram.com/Ellipse.html (59)\r\n      var angle = this.angleAt( t );\r\n      var aq = this.radiusX * Math.sin( angle );\r\n      var bq = this.radiusY * Math.cos( angle );\r\n      var denominator = Math.pow( bq * bq + aq * aq, 3/2 );\r\n      return ( this.anticlockwise ? -1 : 1 ) * this.radiusX * this.radiusY / denominator;\r\n    },\r\n    \r\n    positionAtAngle: function( angle ) {\r\n      return this.unitTransform.transformPosition2( Vector2.createPolar( 1, angle ) );\r\n    },\r\n    \r\n    tangentAtAngle: function( angle ) {\r\n      var normal = this.unitTransform.transformNormal2( Vector2.createPolar( 1, angle ) );\r\n      \r\n      return this.anticlockwise ? normal.perpendicular() : normal.perpendicular().negated();\r\n    },\r\n    \r\n    // TODO: refactor? exact same as Segment.Arc\r\n    containsAngle: function( angle ) {\r\n      // transform the angle into the appropriate coordinate form\r\n      // TODO: check anticlockwise version!\r\n      var normalizedAngle = this.anticlockwise ? angle - this.endAngle : angle - this.startAngle;\r\n      \r\n      // get the angle between 0 and 2pi\r\n      var positiveMinAngle = normalizedAngle % ( Math.PI * 2 );\r\n      // check this because modular arithmetic with negative numbers reveal a negative number\r\n      if ( positiveMinAngle < 0 ) {\r\n        positiveMinAngle += Math.PI * 2;\r\n      }\r\n      \r\n      return positiveMinAngle <= this.angleDifference;\r\n    },\r\n    \r\n    // discretizes the elliptical arc and returns an offset curve as a list of lineTos\r\n    offsetTo: function( r, reverse ) {\r\n      // how many segments to create (possibly make this more adaptive?)\r\n      var quantity = 32;\r\n      \r\n      var points = [];\r\n      var result = [];\r\n      for ( var i = 0; i < quantity; i++ ) {\r\n        var ratio = i / ( quantity - 1 );\r\n        if ( reverse ) {\r\n          ratio = 1 - ratio;\r\n        }\r\n        var angle = this.angleAt( ratio );\r\n        \r\n        points.push( this.positionAtAngle( angle ).plus( this.tangentAtAngle( angle ).perpendicular().normalized().times( r ) ) );\r\n        if ( i > 0 ) {\r\n          result.push( new Segment.Line( points[i-1], points[i] ) );\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    },\r\n    \r\n    getSVGPathFragment: function() {\r\n      // see http://www.w3.org/TR/SVG/paths.html#PathDataEllipticalArcCommands for more info\r\n      // rx ry x-axis-rotation large-arc-flag sweep-flag x y\r\n      var epsilon = 0.01; // allow some leeway to render things as 'almost circles'\r\n      var sweepFlag = this.anticlockwise ? '0' : '1';\r\n      var largeArcFlag;\r\n      var degreesRotation = toDegrees( this.rotation ); // bleh, degrees?\r\n      if ( this.angleDifference < Math.PI * 2 - epsilon ) {\r\n        largeArcFlag = this.angleDifference < Math.PI ? '0' : '1';\r\n        return 'A ' + this.radiusX + ' ' + this.radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;\r\n      } else {\r\n        // ellipse (or almost-ellipse) case needs to be handled differently\r\n        // since SVG will not be able to draw (or know how to draw) the correct circle if we just have a start and end, we need to split it into two circular arcs\r\n        \r\n        // get the angle that is between and opposite of both of the points\r\n        var splitOppositeAngle = ( this.startAngle + this.endAngle ) / 2; // this _should_ work for the modular case?\r\n        var splitPoint = this.positionAtAngle( splitOppositeAngle );\r\n        \r\n        largeArcFlag = '0'; // since we split it in 2, it's always the small arc\r\n        \r\n        var firstArc = 'A ' + this.radiusX + ' ' + this.radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + splitPoint.x + ' ' + splitPoint.y;\r\n        var secondArc = 'A ' + this.radiusX + ' ' + this.radiusY + ' ' + degreesRotation + ' ' + largeArcFlag + ' ' + sweepFlag + ' ' + this.end.x + ' ' + this.end.y;\r\n        \r\n        return firstArc + ' ' + secondArc;\r\n      }\r\n    },\r\n    \r\n    strokeLeft: function( lineWidth ) {\r\n      return this.offsetTo( -lineWidth / 2, false );\r\n    },\r\n    \r\n    strokeRight: function( lineWidth ) {\r\n      return this.offsetTo( lineWidth / 2, true );\r\n    },\r\n    \r\n    // not including 0 and 1\r\n    getInteriorExtremaTs: function() {\r\n      var that = this;\r\n      var result = [];\r\n      _.each( this.possibleExtremaAngles, function( angle ) {\r\n        if ( that.containsAngle( angle ) ) {\r\n          var t = that.tAtAngle( angle );\r\n          var epsilon = 0.0000000001; // TODO: general kite epsilon?\r\n          if ( t > epsilon && t < 1 - epsilon ) {\r\n            result.push( t );\r\n          }\r\n        }\r\n      } );\r\n      return result.sort(); // modifies original, which is OK\r\n    },\r\n    \r\n    subdivided: function( t ) {\r\n      // TODO: verify that we don't need to switch anticlockwise here, or subtract 2pi off any angles\r\n      var angle0 = this.angleAt( 0 );\r\n      var angleT = this.angleAt( t );\r\n      var angle1 = this.angleAt( 1 );\r\n      return [\r\n        new Segment.EllipticalArc( this.center, this.radiusX, this.radiusY, this.rotation, angle0, angleT, this.anticlockwise ),\r\n        new Segment.EllipticalArc( this.center, this.radiusX, this.radiusY, this.rotation, angleT, angle1, this.anticlockwise )\r\n      ];\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      throw new Error( 'Segment.EllipticalArc.intersectsBounds unimplemented' );\r\n    },\r\n    \r\n    intersection: function( ray ) {\r\n      // be lazy. transform it into the space of a non-elliptical arc.\r\n      var unitTransform = this.unitTransform;\r\n      var rayInUnitCircleSpace = unitTransform.inverseRay2( ray );\r\n      var hits = this.unitArcSegment.intersection( rayInUnitCircleSpace );\r\n      \r\n      return _.map( hits, function( hit ) {\r\n        var transformedPoint = unitTransform.transformPosition2( hit.point );\r\n        return {\r\n          distance: ray.pos.distance( transformedPoint ),\r\n          point: transformedPoint,\r\n          normal: unitTransform.inverseNormal2( hit.normal ),\r\n          wind: hit.wind\r\n        };\r\n      } );\r\n    },\r\n    \r\n    // returns the resultant winding number of this ray intersecting this segment.\r\n    windingIntersection: function( ray ) {\r\n      // be lazy. transform it into the space of a non-elliptical arc.\r\n      var rayInUnitCircleSpace = this.unitTransform.inverseRay2( ray );\r\n      return this.unitArcSegment.windingIntersection( rayInUnitCircleSpace );\r\n    },\r\n    \r\n    // assumes the current position is at start\r\n    writeToContext: function( context ) {\r\n      if ( context.ellipse ) {\r\n        context.ellipse( this.center.x, this.center.y, this.radiusX, this.radiusY, this.rotation, this.startAngle, this.endAngle, this.anticlockwise );\r\n      } else {\r\n        // fake the ellipse call by using transforms\r\n        this.unitTransform.getMatrix().canvasAppendTransform( context );\r\n        context.arc( 0, 0, 1, this.startAngle, this.endAngle, this.anticlockwise );\r\n        this.unitTransform.getInverse().canvasAppendTransform( context );\r\n      }\r\n    },\r\n    \r\n    transformed: function( matrix ) {\r\n      var transformedSemiMajorAxis = matrix.timesVector2( Vector2.createPolar( this.radiusX, this.rotation ) ).minus( matrix.timesVector2( Vector2.ZERO ) );\r\n      var transformedSemiMinorAxis = matrix.timesVector2( Vector2.createPolar( this.radiusY, this.rotation + Math.PI / 2 ) ).minus( matrix.timesVector2( Vector2.ZERO ) );\r\n      var rotation = transformedSemiMajorAxis.angle();\r\n      var radiusX = transformedSemiMajorAxis.magnitude();\r\n      var radiusY = transformedSemiMinorAxis.magnitude();\r\n      \r\n      var reflected = matrix.getDeterminant() < 0;\r\n      \r\n      // reverse the 'clockwiseness' if our transform includes a reflection\r\n      // TODO: check reflections. swapping angle signs should fix clockwiseness\r\n      var anticlockwise = reflected ? !this.anticlockwise : this.anticlockwise;\r\n      var startAngle = reflected ? -this.startAngle : this.startAngle;\r\n      var endAngle = reflected ? -this.endAngle : this.endAngle;\r\n      \r\n      return new Segment.EllipticalArc( matrix.timesVector2( this.center ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );\r\n    }\r\n  } );\r\n  \r\n  // adapted from http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes\r\n  // transforms the unit circle onto our ellipse\r\n  Segment.EllipticalArc.computeUnitTransform = function( center, radiusX, radiusY, rotation ) {\r\n    return new Transform3( Matrix3.translation( center.x, center.y ) // TODO: convert to Matrix3.translation( this.center) when available\r\n                                  .timesMatrix( Matrix3.rotation2( rotation ) )\r\n                                  .timesMatrix( Matrix3.scaling( radiusX, radiusY ) ) );\r\n  };\r\n  \r\n  return Segment.EllipticalArc;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Shape handling\r\n *\r\n * Shapes are internally made up of Subpaths, which contain a series of segments, and are optionally closed.\r\n * Familiarity with how Canvas handles subpaths is helpful for understanding this code.\r\n *\r\n * Canvas spec: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html\r\n * SVG spec: http://www.w3.org/TR/SVG/expanded-toc.html\r\n *           http://www.w3.org/TR/SVG/paths.html#PathData (for paths)\r\n * Notes for elliptical arcs: http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes\r\n * Notes for painting strokes: https://svgwg.org/svg2-draft/painting.html\r\n *\r\n * TODO: add nonzero / evenodd support when browsers support it\r\n * TODO: docs\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/Shape',['require','ASSERT/assert','ASSERT/assert','KITE/kite','DOT/Vector2','DOT/Bounds2','DOT/Ray2','DOT/Matrix3','DOT/Transform3','DOT/Util','DOT/Util','KITE/util/Subpath','KITE/../parser/svgPath','KITE/util/LineStyles','KITE/segments/Arc','KITE/segments/Cubic','KITE/segments/EllipticalArc','KITE/segments/Line','KITE/segments/Quadratic'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n  var assertExtra = require( 'ASSERT/assert' )( 'kite.extra', true );\r\n  \r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  // TODO: clean up imports\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Ray2 = require( 'DOT/Ray2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  var toDegrees = require( 'DOT/Util' ).toDegrees;\r\n  var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;\r\n  \r\n  var Subpath = require( 'KITE/util/Subpath' );\r\n  \r\n  var svgPath = require( 'KITE/../parser/svgPath' );\r\n  require( 'KITE/util/LineStyles' );\r\n  require( 'KITE/segments/Arc' );\r\n  require( 'KITE/segments/Cubic' );\r\n  require( 'KITE/segments/EllipticalArc' );\r\n  require( 'KITE/segments/Line' );\r\n  require( 'KITE/segments/Quadratic' );\r\n  \r\n  // for brevity\r\n  function p( x,y ) { return new Vector2( x, y ); }\r\n  function v( x,y ) { return new Vector2( x, y ); } // TODO: use this version in general, it makes more sense and is easier to type\r\n  \r\n  // a normalized vector for non-zero winding checks\r\n  // var weirdDir = p( Math.PI, 22 / 7 );\r\n  \r\n  // all arguments optional, they are for the copy() method. if used, ensure that 'bounds' is consistent with 'subpaths'\r\n  kite.Shape = function Shape( subpaths, bounds ) {\r\n    // lower-level piecewise mathematical description using segments, also individually immutable\r\n    this.subpaths = ( typeof subpaths === 'object' ) ? subpaths : [];\r\n    assert && assert( this.subpaths.length === 0 || this.subpaths[0].constructor.name !== 'Array' );\r\n    \r\n    // computed bounds for all pieces added so far\r\n    this.bounds = bounds || Bounds2.NOTHING;\r\n    \r\n    var that = this;\r\n    if ( subpaths && typeof subpaths !== 'object' ) {\r\n      assert && assert( typeof subpaths === 'string', 'if subpaths is not an object, it must be a string' )\r\n      ;\r\n      // parse the SVG path\r\n      _.each( svgPath.parse( subpaths ), function( item ) {\r\n        assert && assert( Shape.prototype[item.cmd] !== undefined, 'method ' + item.cmd + ' from parsed SVG does not exist' );\r\n        that[item.cmd].apply( that, item.args );\r\n      } );\r\n    }\r\n  };\r\n  var Shape = kite.Shape;\r\n  \r\n  Shape.prototype = {\r\n    constructor: Shape,\r\n    \r\n    moveTo: function( x, y ) { return this.moveToPoint( v( x, y ) ); },\r\n    moveToRelative: function( x, y ) { return this.moveToPointRelative( v( x, y ) ); },\r\n    moveToPointRelative: function( point ) { return this.moveToPoint( this.getRelativePoint().plus( point ) ); },\r\n    moveToPoint: function( point ) {\r\n      return this.addSubpath( new kite.Subpath().addPoint( point ) );\r\n    },\r\n    \r\n    lineTo: function( x, y ) { return this.lineToPoint( v( x, y ) ); },\r\n    lineToRelative: function( x, y ) { return this.lineToPointRelative( v( x, y ) ); },\r\n    lineToPointRelative: function( point ) { return this.lineToPoint( this.getRelativePoint().plus( point ) ); },\r\n    lineToPoint: function( point ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-lineto\r\n      if ( this.hasSubpaths() ) {\r\n        var start = this.getLastSubpath().getLastPoint();\r\n        var end = point;\r\n      var line = new kite.Segment.Line( start, end );\r\n        this.getLastSubpath().addPoint( end );\r\n        if ( !line.invalid ) {\r\n          this.getLastSubpath().addSegment( line );\r\n          this.bounds = this.bounds.withPoint( start ).withPoint( end );\r\n          assert && assert( !isNaN( this.bounds.getX() ) );\r\n        }\r\n      } else {\r\n        this.ensure( point );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    horizontalLineTo: function( x ) { return this.lineTo( x, this.getRelativePoint().y ); },\r\n    horizontalLineToRelative: function( x ) { return this.lineToRelative( x, 0 ); },\r\n    \r\n    verticalLineTo: function( y ) { return this.lineTo( this.getRelativePoint().x, y ); },\r\n    verticalLineToRelative: function( y ) { return this.lineToRelative( 0, y ); },\r\n    \r\n    quadraticCurveTo: function( cpx, cpy, x, y ) { return this.quadraticCurveToPoint( v( cpx, cpy ), v( x, y ) ); },\r\n    quadraticCurveToRelative: function( cpx, cpy, x, y ) { return this.quadraticCurveToPointRelative( v( cpx, cpy ), v( x, y ) ); },\r\n    quadraticCurveToPointRelative: function( controlPoint, point ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.quadraticCurveToPoint( relativePoint.plus( controlPoint ), relativePoint.plus( point ) );\r\n    },\r\n    // TODO: consider a rename to put 'smooth' farther back?\r\n    smoothQuadraticCurveTo: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ) ); },\r\n    smoothQuadraticCurveToRelative: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ).plus( this.getRelativePoint() ) ); },\r\n    quadraticCurveToPoint: function( controlPoint, point ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\r\n      this.ensure( controlPoint );\r\n      var start = this.getLastSubpath().getLastPoint();\r\n      var quadratic = new kite.Segment.Quadratic( start, controlPoint, point );\r\n      this.getLastSubpath().addPoint( point );\r\n      if ( !quadratic.invalid ) {\r\n        this.getLastSubpath().addSegment( quadratic );\r\n        this.bounds = this.bounds.union( quadratic.bounds );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    cubicCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },\r\n    cubicCurveToRelative: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPointRelative( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },\r\n    cubicCurveToPointRelative: function( control1, control2, point ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.cubicCurveToPoint( relativePoint.plus( control1 ), relativePoint.plus( control2 ), relativePoint.plus( point ) );\r\n    },\r\n    smoothCubicCurveTo: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ), v( x, y ) ); },\r\n    smoothCubicCurveToRelative: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ).plus( this.getRelativePoint() ), v( x, y ).plus( this.getRelativePoint() ) ); },\r\n    cubicCurveToPoint: function( control1, control2, point ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\r\n      this.ensure( control1 );\r\n      var start = this.getLastSubpath().getLastPoint();\r\n      var cubic = new kite.Segment.Cubic( start, control1, control2, point );\r\n      \r\n      if ( !cubic.invalid ) {\r\n        // if there is a cusp, we add the two (split) quadratic segments instead so that stroking treats the 'join' between them with the proper lineJoin\r\n        if ( cubic.hasCusp() ) {\r\n          this.getLastSubpath().addSegment( cubic.startQuadratic );\r\n          this.getLastSubpath().addSegment( cubic.endQuadratic );\r\n        } else {\r\n          this.getLastSubpath().addSegment( cubic );\r\n        }\r\n        \r\n        this.bounds = this.bounds.union( cubic.bounds );\r\n      }\r\n      this.getLastSubpath().addPoint( point );\r\n      \r\n      return this;\r\n    },\r\n    \r\n    arc: function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) { return this.arcPoint( v( centerX, centerY ), radius, startAngle, endAngle, anticlockwise ); },\r\n    arcPoint: function( center, radius, startAngle, endAngle, anticlockwise ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc\r\n      \r\n      var arc = new kite.Segment.Arc( center, radius, startAngle, endAngle, anticlockwise );\r\n      \r\n      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas\r\n      var startPoint = arc.start;\r\n      var endPoint = arc.end;\r\n      \r\n      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them\r\n      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {\r\n        this.getLastSubpath().addSegment( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );\r\n      }\r\n      \r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new kite.Subpath() );\r\n      }\r\n      \r\n      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)\r\n      this.getLastSubpath().addPoint( startPoint );\r\n      this.getLastSubpath().addPoint( endPoint );\r\n      \r\n      if ( !arc.invalid ) {\r\n        this.getLastSubpath().addSegment( arc );\r\n        \r\n        // and update the bounds\r\n        this.bounds = this.bounds.union( arc.bounds );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    ellipticalArc: function( centerX, centerY, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) { return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ); },\r\n    ellipticalArcPoint: function( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc\r\n      \r\n      var ellipticalArc = new kite.Segment.EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );\r\n      \r\n      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas\r\n      var startPoint = ellipticalArc.start;\r\n      var endPoint = ellipticalArc.end;\r\n      \r\n      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them\r\n      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {\r\n        this.getLastSubpath().addSegment( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );\r\n      }\r\n      \r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new kite.Subpath() );\r\n      }\r\n      \r\n      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)\r\n      this.getLastSubpath().addPoint( startPoint );\r\n      this.getLastSubpath().addPoint( endPoint );\r\n      \r\n      if ( !ellipticalArc.invalid ) {\r\n        this.getLastSubpath().addSegment( ellipticalArc );\r\n        \r\n        // and update the bounds\r\n        this.bounds = this.bounds.union( ellipticalArc.bounds );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    close: function() {\r\n      if ( this.hasSubpaths() ) {\r\n        var previousPath = this.getLastSubpath();\r\n        var nextPath = new kite.Subpath();\r\n        \r\n        previousPath.close();\r\n        this.addSubpath( nextPath );\r\n        nextPath.addPoint( previousPath.getFirstPoint() );\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    // matches SVG's elliptical arc from http://www.w3.org/TR/SVG/paths.html\r\n    ellipticalArcToRelative: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.ellipticalArcTo( radiusX, radiusY, rotation, largeArc, sweep, x + relativePoint.x, y + relativePoint.y );\r\n    },\r\n    ellipticalArcTo: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {\r\n      throw new Error( 'ellipticalArcTo unimplemented' );\r\n    },\r\n    \r\n    /*\r\n     * Draws a circle using the arc() call with the following parameters:\r\n     * circle( center, radius ) // center is a Vector2\r\n     * circle( centerX, centerY, radius )\r\n     */\r\n    circle: function( centerX, centerY, radius ) {\r\n      if ( typeof centerX === 'object' ) {\r\n        // circle( center, radius )\r\n        var center = centerX;\r\n        radius = centerY;\r\n        return this.arcPoint( center, radius, 0, Math.PI * 2, false );\r\n      } else {\r\n        // circle( centerX, centerY, radius )\r\n        return this.arcPoint( p( centerX, centerY ), radius, 0, Math.PI * 2, false );\r\n      }\r\n    },\r\n    \r\n    /*\r\n     * Draws an ellipse using the ellipticalArc() call with the following parameters:\r\n     * ellipse( center, radiusX, radiusY, rotation ) // center is a Vector2\r\n     * ellipse( centerX, centerY, radiusX, radiusY, rotation )\r\n     */\r\n    ellipse: function( centerX, centerY, radiusX, radiusY, rotation ) {\r\n      // TODO: separate into ellipse() and ellipsePoint()?\r\n      // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling\r\n      if ( typeof centerX === 'object' ) {\r\n        // ellipse( center, radiusX, radiusY, rotation )\r\n        var center = centerX;\r\n        rotation = radiusY;\r\n        radiusY = radiusX;\r\n        radiusX = centerY;\r\n        return this.ellipticalArcPoint( center, radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );\r\n      } else {\r\n        // ellipse( centerX, centerY, radiusX, radiusY, rotation )\r\n        return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );\r\n      }\r\n    },\r\n    \r\n    rect: function( x, y, width, height ) {\r\n      var subpath = new kite.Subpath();\r\n      this.addSubpath( subpath );\r\n      subpath.addPoint( v( x, y ) );\r\n      subpath.addPoint( v( x + width, y ) );\r\n      subpath.addPoint( v( x + width, y + height ) );\r\n      subpath.addPoint( v( x, y + height ) );\r\n      subpath.addSegment( new kite.Segment.Line( subpath.points[0], subpath.points[1] ) );\r\n      subpath.addSegment( new kite.Segment.Line( subpath.points[1], subpath.points[2] ) );\r\n      subpath.addSegment( new kite.Segment.Line( subpath.points[2], subpath.points[3] ) );\r\n      subpath.close();\r\n      this.addSubpath( new kite.Subpath() );\r\n      this.getLastSubpath().addPoint( v( x, y ) );\r\n      this.bounds = this.bounds.withCoordinates( x, y ).withCoordinates( x + width, y + height );\r\n      assert && assert( !isNaN( this.bounds.getX() ) );\r\n      \r\n      return this;\r\n    },\r\n\r\n    //Create a round rectangle. All arguments are number.\r\n    roundRect: function( x, y, width, height, arcw, arch ) {\r\n      var lowX = x + arcw;\r\n      var highX = x + width - arcw;\r\n      var lowY = y + arch;\r\n      var highY = y + height - arch;\r\n      // if ( true ) {\r\n      if ( arcw === arch ) {\r\n        // we can use circular arcs, which have well defined stroked offsets\r\n        this.arc( highX, lowY, arcw, -Math.PI / 2, 0, false )\r\n            .arc( highX, highY, arcw, 0, Math.PI / 2, false )\r\n            .arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false )\r\n            .arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false )\r\n            .close();\r\n      } else {\r\n        // we have to resort to elliptical arcs\r\n        this.ellipticalArc( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false )\r\n            .ellipticalArc( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false )\r\n            .ellipticalArc( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false )\r\n            .ellipticalArc( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false )\r\n            .close();\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    copy: function() {\r\n      // copy each individual subpath, so future modifications to either Shape doesn't affect the other one\r\n      return new Shape( _.map( this.subpaths, function( subpath ) { return subpath.copy(); } ), this.bounds );\r\n    },\r\n    \r\n    // write out this shape's path to a canvas 2d context. does NOT include the beginPath()!\r\n    writeToContext: function( context ) {\r\n      _.each( this.subpaths, function( subpath ) {\r\n        subpath.writeToContext( context );\r\n      } );\r\n    },\r\n    \r\n    // returns something like \"M150 0 L75 200 L225 200 Z\" for a triangle\r\n    getSVGPath: function() {\r\n      var subpathStrings = [];\r\n      _.each( this.subpaths, function( subpath ) {\r\n        if( subpath.isDrawable() ) {\r\n          // since the commands after this are relative to the previous 'point', we need to specify a move to the initial point\r\n          var startPoint = subpath.getFirstSegment().start;\r\n          assert && assert( startPoint.equals( subpath.getFirstPoint(), 0.00001 ) ); // sanity check\r\n          var string = 'M ' + startPoint.x + ' ' + startPoint.y + ' ';\r\n          \r\n          string += _.map( subpath.segments, function( segment ) { return segment.getSVGPathFragment(); } ).join( ' ' );\r\n          \r\n          if ( subpath.isClosed() ) {\r\n            string += ' Z';\r\n          }\r\n          subpathStrings.push( string );\r\n        }\r\n      } );\r\n      return subpathStrings.join( ' ' );\r\n    },\r\n    \r\n    // return a new Shape that is transformed by the associated matrix\r\n    transformed: function( matrix ) {\r\n      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.transformed( matrix ); } );\r\n      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.computeBounds() ); }, Bounds2.NOTHING );\r\n      return new Shape( subpaths, bounds );\r\n    },\r\n    \r\n    // returns the bounds. if lineStyles exists, include the stroke in the bounds\r\n    // TODO: consider renaming to getBounds()?\r\n    computeBounds: function( lineStyles ) {\r\n      if ( lineStyles ) {\r\n        return this.bounds.union( this.getStrokedShape( lineStyles ).bounds );\r\n      } else {\r\n        return this.bounds;\r\n      }\r\n    },\r\n    \r\n    containsPoint: function( point ) {\r\n      // we pick a ray, and determine the winding number over that ray. if the number of segments crossing it CCW == number of segments crossing it CW, then the point is contained in the shape\r\n      var ray = new Ray2( point, p( 1, 0 ) );\r\n      \r\n      return this.windingIntersection( ray ) !== 0;\r\n    },\r\n    \r\n    intersection: function( ray ) {\r\n      var hits = [];\r\n      _.each( this.subpaths, function( subpath ) {\r\n        if ( subpath.isDrawable() ) {\r\n          _.each( subpath.segments, function( segment ) {\r\n            _.each( segment.intersection( ray ), function( hit ) {\r\n              hits.push( hit );\r\n            } );\r\n          } );\r\n          \r\n          if ( subpath.hasClosingSegment() ) {\r\n            _.each( subpath.getClosingSegment().intersection( ray ), function( hit ) {\r\n              hits.push( hit );\r\n            } );\r\n          }\r\n        }\r\n      } );\r\n      return _.sortBy( hits, function( hit ) { return hit.distance; } );\r\n    },\r\n    \r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      \r\n      _.each( this.subpaths, function( subpath ) {\r\n        if ( subpath.isDrawable() ) {\r\n          _.each( subpath.segments, function( segment ) {\r\n            wind += segment.windingIntersection( ray );\r\n          } );\r\n          \r\n          // handle the implicit closing line segment\r\n          if ( subpath.hasClosingSegment() ) {\r\n            wind += subpath.getClosingSegment().windingIntersection( ray );\r\n          }\r\n        }\r\n      } );\r\n      \r\n      return wind;\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      var intersects = false;\r\n      // TODO: break-out-early optimizations\r\n      _.each( this.subpaths, function( subpath ) {\r\n        if ( subpath.isDrawable() ) {\r\n          _.each( subpath.segments, function( segment ) {\r\n            intersects = intersects && segment.intersectsBounds( bounds );\r\n          } );\r\n          \r\n          // handle the implicit closing line segment\r\n          if ( subpath.hasClosingSegment() ) {\r\n            intersects = intersects && subpath.getClosingSegment().intersectsBounds( bounds );\r\n          }\r\n        }\r\n      } );\r\n      return intersects;\r\n    },\r\n    \r\n    // returns a new Shape that is an outline of the stroked path of this current Shape. currently not intended to be nested (doesn't do intersection computations yet)\r\n    // TODO: rename stroked( lineStyles )\r\n    getStrokedShape: function( lineStyles ) {\r\n      var subpaths = _.flatten( _.map( this.subpaths, function( subpath ) { return subpath.stroked( lineStyles ); } ) );\r\n      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.computeBounds() ); }, Bounds2.NOTHING );\r\n      return new Shape( subpaths, bounds );\r\n    },\r\n    \r\n    toString: function() {\r\n      // TODO: consider a more verbose but safer way?\r\n      return 'new kite.Shape( \\'' + this.getSVGPath() + '\\' )';\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Internal subpath computations\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    ensure: function( point ) {\r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new Subpath() );\r\n        this.getLastSubpath().addPoint( point );\r\n      }\r\n    },\r\n    \r\n    addSubpath: function( subpath ) {\r\n      this.subpaths.push( subpath );\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    hasSubpaths: function() {\r\n      return this.subpaths.length > 0;\r\n    },\r\n    \r\n    getLastSubpath: function() {\r\n      return _.last( this.subpaths );\r\n    },\r\n    \r\n    // gets the last point in the last subpath, or null if it doesn't exist\r\n    getLastPoint: function() {\r\n      return this.hasSubpaths() ? this.getLastSubpath().getLastPoint() : null;\r\n    },\r\n    \r\n    getLastSegment: function() {\r\n      if ( !this.hasSubpaths() ) { return null; }\r\n      \r\n      var subpath = this.getLastSubpath();\r\n      if ( !subpath.isDrawable() ) { return null; }\r\n      \r\n      return subpath.getLastSegment();\r\n    },\r\n    \r\n    // returns the point to be used for smooth quadratic segments\r\n    getSmoothQuadraticControlPoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n      \r\n      var segment = this.getLastSegment();\r\n      if ( !segment || !( segment instanceof kite.Segment.Quadratic ) ) { return lastPoint; }\r\n      \r\n      return lastPoint.plus( lastPoint.minus( segment.control ) );\r\n    },\r\n    \r\n    // returns the point to be used for smooth cubic segments\r\n    getSmoothCubicControlPoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n      \r\n      var segment = this.getLastSegment();\r\n      if ( !segment || !( segment instanceof kite.Segment.Cubic ) ) { return lastPoint; }\r\n      \r\n      return lastPoint.plus( lastPoint.minus( segment.control2 ) );\r\n    },\r\n    \r\n    getRelativePoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n      return lastPoint ? lastPoint : Vector2.ZERO;\r\n    }\r\n  };\r\n  \r\n  /*---------------------------------------------------------------------------*\r\n  * Shape shortcuts\r\n  *----------------------------------------------------------------------------*/\r\n  \r\n  Shape.rectangle = function( x, y, width, height ) {\r\n    return new Shape().rect( x, y, width, height );\r\n  };\r\n  Shape.rect = Shape.rectangle;\r\n\r\n  //Create a round rectangle. All arguments are number.\r\n  //Rounding is currently using quadraticCurveTo.  Please note, future versions may use arcTo\r\n  //TODO: rewrite with arcTo?\r\n  Shape.roundRect = function( x, y, width, height, arcw, arch ) {\r\n    return new Shape().roundRect( x, y, width, height, arcw, arch );\r\n  };\r\n  Shape.roundRectangle = Shape.roundRect;\r\n  \r\n  Shape.bounds = function( bounds ) {\r\n    return new Shape().rect( bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY );\r\n  };\r\n\r\n  //Create a line segment, using either (x1,y1,x2,y2) or ({x1,y1},{x2,y2}) arguments\r\n  Shape.lineSegment = function( a, b, c, d ) {\r\n    // TODO: add type assertions?\r\n    if ( typeof a === 'number' ) {\r\n      return new Shape().moveTo( a, b ).lineTo( c, d );\r\n    }\r\n    else {\r\n      return new Shape().moveToPoint( a ).lineToPoint( b );\r\n    }\r\n  };\r\n  \r\n  Shape.regularPolygon = function( sides, radius ) {\r\n    var shape = new Shape();\r\n    _.each( _.range( sides ), function( k ) {\r\n      var point = Vector2.createPolar( radius, 2 * Math.PI * k / sides );\r\n      ( k === 0 ) ? shape.moveToPoint( point ) : shape.lineToPoint( point );\r\n    } );\r\n    return shape.close();\r\n  };\r\n  \r\n  // supports both circle( centerX, centerY, radius ), circle( center, radius ), and circle( radius ) with the center default to 0,0\r\n  Shape.circle = function( centerX, centerY, radius ) {\r\n    if ( centerY === undefined ) {\r\n      // circle( radius ), center = 0,0\r\n      return new Shape().circle( 0, 0, centerX );\r\n    }\r\n    return new Shape().circle( centerX, centerY, radius ).close();\r\n  };\r\n  \r\n  /*\r\n   * Supports ellipse( centerX, centerY, radiusX, radiusY ), ellipse( center, radiusX, radiusY ), and ellipse( radiusX, radiusY )\r\n   * with the center default to 0,0 and rotation of 0\r\n   */\r\n  Shape.ellipse = function( centerX, centerY, radiusX, radiusY ) {\r\n    // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling\r\n    if ( radiusX === undefined ) {\r\n      // ellipse( radiusX, radiusY ), center = 0,0\r\n      return new Shape().ellipse( 0, 0, centerX, centerY );\r\n    }\r\n    return new Shape().ellipse( centerX, centerY, radiusX, radiusY ).close();\r\n  };\r\n  \r\n  // supports both arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) and arc( center, radius, startAngle, endAngle, anticlockwise )\r\n  Shape.arc = function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) {\r\n    return new Shape().arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise );\r\n  };\r\n  \r\n  return Shape;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Mix-in for Node's event handling, with experimental performance enhancements\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/FixedNodeEvents',['require','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var eventNames = [\r\n    'selfBounds',\r\n    'childBounds',\r\n    'bounds',\r\n    'resize',\r\n    'boundsAccuracy'\r\n  ];\r\n  \r\n  scenery.FixedNodeEvents = function FixedNodeEvents( type ) {\r\n    var proto = type.prototype;\r\n    \r\n    // this should be called in the constructor to initialize\r\n    proto.initializeNodeEvents = function() {\r\n      this._events = {};\r\n      \r\n      var node = this;\r\n      \r\n      // TODO: performance: consider delaying this? Could affect memory usage?\r\n      var len = eventNames.length;\r\n      for ( var i = 0; i < len; i++ ) {\r\n        node._events[eventNames[i]] = [];\r\n      }\r\n    };\r\n    \r\n    /**\r\n     * @param {String}   type     The type of event, like 'resize' or 'bounds'\r\n     * @param {Function} listener Callback, called with arguments that depend on the event type\r\n     */\r\n    proto.addEventListener = function( type, listener ) {\r\n      sceneryAssert && sceneryAssert( type !== undefined && listener !== undefined,\r\n                                      'Both a type and listener are required for addEventListener' );\r\n      \r\n      // most commonly a bug, maybe there will be a good use case? can always work around by wrapping with a new function each time\r\n      sceneryAssert && sceneryAssert( _.indexOf( this._events[type], listener ),\r\n                                      'Event listener was already there for addEventListener with type ' + type );\r\n      \r\n      this._events[type].push( listener );\r\n      \r\n      // allow chaining\r\n      return this;\r\n    };\r\n    \r\n    /**\r\n     * @param {String}   type     The type of event, like 'resize' or 'bounds'\r\n     * @param {Function} listener The callback to remove.\r\n     */\r\n    proto.removeEventListener = function( type, listener ) {\r\n      sceneryAssert && sceneryAssert( type !== undefined && listener !== undefined,\r\n                                      'Both a type and listener are required for removeEventListener' );\r\n      \r\n      // ensure the listener is in our list\r\n      sceneryAssert && sceneryAssert( _.indexOf( this._events[type], listener ) !== -1,\r\n                                      'Listener did not exist for type ' + type );\r\n      \r\n      this._events[type].splice( _.indexOf( this._events[type], listener ), 1 );\r\n      \r\n      // allow chaining\r\n      return this;\r\n    };\r\n    \r\n    /*\r\n     * Fires an event to all event listeners attached to this node. It does not bubble down to\r\n     * all ancestors with trails, like dispatchEvent does. Use fireEvent when you only want an event\r\n     * that is relevant for a specific node, and ancestors don't need to be notified.\r\n     */\r\n    proto.fireEvent = function( type, args ) {\r\n      sceneryAssert && sceneryAssert( _.contains( eventNames, type ),\r\n                                      'unknown event type: ' + type );\r\n      \r\n      var events = this._events[type];\r\n      var len = events.length;\r\n      if ( len ) { // TODO: consider removing branch? is this even helpful?\r\n        var copy = events.slice( 0 ); // defensive copy, in case listeners are added or removed as a side effect of a listener being called\r\n        for ( var i = 0; i < len; i++ ) {\r\n          copy[i]( args );\r\n        }\r\n      }\r\n    };\r\n  };\r\n  var FixedNodeEvents = scenery.FixedNodeEvents;\r\n  \r\n  return FixedNodeEvents;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Controls the underlying layer behavior around a node. The node's LayerStrategy's enter() and exit() will be\r\n * called in a depth-first order during the layer building process, and will modify a LayerBuilder to signal any\r\n * layer-specific signals.\r\n *\r\n * This generally ensures that a layer containing the proper renderer and settings to support its associated node\r\n * will be created.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/layers/LayerStrategy',['require','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  /*\r\n   * If the node specifies a renderer, we will always push a preferred type. That type will be fresh (if rendererOptions are specified), otherwise\r\n   * the top matching preferred type for that renderer will be used. This allows us to always pop in the exit().\r\n   *\r\n   * Specified as such, since there is no needed shared state (we can have node.layerStrategy = scenery.LayerStrategy for many nodes)\r\n   */\r\n  scenery.LayerStrategy = {\r\n    // true iff enter/exit will push/pop a layer type to the preferred stack. currently limited to only one layer type per level.\r\n    hasPreferredLayerType: function( pointer, layerBuilder ) {\r\n      return pointer.trail.lastNode().hasRenderer();\r\n    },\r\n    \r\n    getPreferredLayerType: function( pointer, layerBuilder ) {\r\n      sceneryAssert && sceneryAssert( this.hasPreferredLayerType( pointer, layerBuilder ) ); // sanity check\r\n      \r\n      var node = pointer.trail.lastNode();\r\n      var preferredLayerType;\r\n      \r\n      if ( node.hasRendererLayerType() ) {\r\n        preferredLayerType = node.getRendererLayerType();\r\n      } else {\r\n        preferredLayerType = layerBuilder.bestPreferredLayerTypeFor( [ node.getRenderer() ] );\r\n        if ( !preferredLayerType ) {\r\n          // there was no preferred layer type matching, just use the default\r\n          preferredLayerType = node.getRenderer().defaultLayerType;\r\n        }\r\n      }\r\n      \r\n      return preferredLayerType;\r\n    },\r\n    \r\n    enter: function( pointer, layerBuilder ) {\r\n      var trail = pointer.trail;\r\n      var node = trail.lastNode();\r\n      var preferredLayerType;\r\n      \r\n      // if the node has a renderer, always push a layer type, so that we can pop on the exit() and ensure consistent behavior\r\n      if ( node.hasRenderer() ) {\r\n        preferredLayerType = this.getPreferredLayerType( pointer, layerBuilder );\r\n        \r\n        // push the preferred layer type\r\n        layerBuilder.pushPreferredLayerType( preferredLayerType );\r\n        if ( layerBuilder.getCurrentLayerType() !== preferredLayerType ) {\r\n          layerBuilder.switchToType( pointer, preferredLayerType );\r\n        }\r\n      } else if ( node.isPainted() ) {\r\n        // node doesn't specify a renderer, but isPainted.\r\n        \r\n        var supportedRenderers = node._supportedRenderers;\r\n        var currentType = layerBuilder.getCurrentLayerType();\r\n        preferredLayerType = layerBuilder.bestPreferredLayerTypeFor( supportedRenderers );\r\n        \r\n        // If any of the preferred types are compatible, use the top one. This allows us to support caching and hierarchical layer types\r\n        if ( preferredLayerType ) {\r\n          if ( currentType !== preferredLayerType ) {\r\n            layerBuilder.switchToType( pointer, preferredLayerType );\r\n          }\r\n        } else {\r\n          // if no preferred types are compatible, only switch if the current type is also incompatible\r\n          if ( !currentType || !currentType.supportsNode( node ) ) {\r\n            layerBuilder.switchToType( pointer, supportedRenderers[0].defaultLayerType );\r\n          }\r\n        }\r\n      }\r\n      \r\n      if ( node.isLayerSplitBefore() || this.hasSplitFlags( node ) ) {\r\n        layerBuilder.switchToType( pointer, layerBuilder.getCurrentLayerType() );\r\n      }\r\n      \r\n      if ( node.isPainted() ) {\r\n        // trigger actual layer creation if necessary (allow collapsing of layers otherwise)\r\n        layerBuilder.markPainted( pointer );\r\n      }\r\n    },\r\n    \r\n    // afterSelf: function( trail, layerBuilder ) {\r\n    //   // no-op, and possibly not used\r\n    // },\r\n    \r\n    // betweenChildren: function( trail, layerBuilder ) {\r\n    //   // no-op, and possibly not used\r\n    // },\r\n    \r\n    exit: function( pointer, layerBuilder ) {\r\n      var trail = pointer.trail;\r\n      var node = trail.lastNode();\r\n      \r\n      if ( node.hasRenderer() ) {\r\n        layerBuilder.popPreferredLayerType();\r\n        \r\n        // switch down to the next lowest preferred layer type, if any. if null, pass the null to switchToType\r\n        // this allows us to not 'leak' the renderer information, and the temporary layer type is most likely collapsed and ignored\r\n        // NOTE: disabled for now, since this prevents us from having adjacent children sharing the same layer type\r\n        // if ( layerBuilder.getCurrentLayerType() !== layerBuilder.getPreferredLayerType() ) {\r\n        //   layerBuilder.switchToType( pointer, layerBuilder.getPreferredLayerType() );\r\n        // }\r\n      }\r\n      \r\n      if ( node.isLayerSplitAfter() || this.hasSplitFlags( node ) ) {\r\n        layerBuilder.switchToType( pointer, layerBuilder.getCurrentLayerType() );\r\n      }\r\n    },\r\n    \r\n    // whether splitting before and after the node is required\r\n    hasSplitFlags: function( node ) {\r\n      // currently, only enforce splitting if we are using CSS transforms\r\n      var rendererOptions = node.getRendererOptions();\r\n      return node.hasRenderer() && rendererOptions && (\r\n        rendererOptions.cssTranslation ||\r\n        rendererOptions.cssRotation ||\r\n        rendererOptions.cssScale ||\r\n        rendererOptions.cssTransform\r\n      );\r\n    }\r\n  };\r\n  var LayerStrategy = scenery.LayerStrategy;\r\n  \r\n  return LayerStrategy;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * A node for the Scenery scene graph. Supports general directed acyclic graphics (DAGs).\r\n * Handles multiple layers with assorted types (Canvas 2D, SVG, DOM, WebGL, etc.).\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/nodes/Node',['require','DOT/Bounds2','DOT/Transform3','DOT/Matrix3','DOT/Vector2','DOT/Util','KITE/Shape','SCENERY/scenery','SCENERY/util/FixedNodeEvents','SCENERY/layers/LayerStrategy'],function( require ) {\r\n  'use strict';\r\n  \r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var clamp = require( 'DOT/Util' ).clamp;\r\n  \r\n  var Shape = require( 'KITE/Shape' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  var NodeEvents = require( 'SCENERY/util/FixedNodeEvents' ); // uncapitalized, because of JSHint (TODO: find the flag)\r\n  var LayerStrategy = require( 'SCENERY/layers/LayerStrategy' ); // used to set the default layer strategy on the prototype\r\n  // require( 'SCENERY/layers/Renderer' ); // commented out so Require.js doesn't balk at the circular dependency\r\n  \r\n  // TODO: FIXME: Why do I have to comment out this dependency?\r\n  // require( 'SCENERY/util/Trail' );\r\n  // require( 'SCENERY/util/TrailPointer' );\r\n  \r\n  var globalIdCounter = 1;\r\n  \r\n  /*\r\n   * Available keys for use in the options parameter object for a vanilla Node (not inherited), in the order they are executed in:\r\n   *\r\n   * children:         A list of children to add (in order)\r\n   * cursor:           Will display the specified CSS cursor when the mouse is over this Node or one of its descendents. The Scene needs to have input listeners attached with an initialize method first.\r\n   * visible:          If false, this node (and its children) will not be displayed (or get input events)\r\n   * pickable:         If false, this node (and its children) will not get input events\r\n   * translation:      Sets the translation of the node to either the specified dot.Vector2 value, or the x,y values from an object (e.g. translation: { x: 1, y: 2 } )\r\n   * x:                Sets the x-translation of the node\r\n   * y:                Sets the y-translation of the node\r\n   * rotation:         Sets the rotation of the node in radians\r\n   * scale:            Sets the scale of the node. Supports either a number (same x-y scale), or a dot.Vector2 / object with ob.x and ob.y to set the scale for each axis independently\r\n   * left:             Sets the x-translation so that the left (min X) of the bounding box (in the parent coordinate frame) is at the specified value\r\n   * right:            Sets the x-translation so that the right (max X) of the bounding box (in the parent coordinate frame) is at the specified value\r\n   * top:              Sets the y-translation so that the top (min Y) of the bounding box (in the parent coordinate frame) is at the specified value\r\n   * bottom:           Sets the y-translation so that the bottom (min Y) of the bounding box (in the parent coordinate frame) is at the specified value\r\n   * centerX:          Sets the x-translation so that the horizontal center of the bounding box (in the parent coordinate frame) is at the specified value\r\n   * centerY:          Sets the y-translation so that the vertical center of the bounding box (in the parent coordinate frame) is at the specified value\r\n   * renderer:         Forces Scenery to use the specific renderer (canvas/svg) to display this node (and if possible, children). Accepts both strings (e.g. 'canvas', 'svg', etc.) or actual Renderer objects (e.g. Renderer.Canvas, Renderer.SVG, etc.)\r\n   * rendererOptions:  Parameter object that is passed to the created layer, and can affect how the layering process works.\r\n   * layerSplit:       Forces a split between layers before and after this node (and its children) have been rendered. Useful for performance with Canvas-based renderers.\r\n   * layerSplitBefore: Forces a split between layers before this node (and its children) have been rendered. Useful for performance with Canvas-based renderers.\r\n   * layerSplitAfter:  Forces a split between layers after this node (and its children) have been rendered. Useful for performance with Canvas-based renderers.\r\n   */\r\n  scenery.Node = function Node( options ) {\r\n    var self = this;\r\n    \r\n    // assign a unique ID to this node (allows trails to get a unique list of IDs)\r\n    this._id = globalIdCounter++;\r\n    \r\n    // all of the Instances tracking this Node (across multiple layers and scenes)\r\n    this._instances = [];\r\n    \r\n    // Whether this node (and its children) will be visible when the scene is updated. Visible nodes by default will not be pickable either\r\n    this._visible = true;\r\n    \r\n    // Opacity from 0 to 1\r\n    this._opacity = 1;\r\n    \r\n    // Whether hit testing will check for this node (and its children).\r\n    this._pickable = true;\r\n    \r\n    // This node and all children will be clipped by this shape (in addition to any other clipping shapes).\r\n    // The shape should be in the local coordinate frame\r\n    this._clipShape = null;\r\n    \r\n    // areas for hit intersection. if set on a Node, no descendants can handle events\r\n    this._mouseArea = null; // {Shape} for mouse position          in the local coordinate frame\r\n    this._touchArea = null; // {Shape} for touch and pen position  in the local coordinate frame\r\n    \r\n    // the CSS cursor to be displayed over this node. null should be the default (inherit) value\r\n    this._cursor = null;\r\n    \r\n    this._children = []; // ordered\r\n    this._parents = []; // unordered\r\n    \r\n    this._peers = []; // array of peer factories: { element: ..., options: ... }, where element can be an element or a string\r\n    this._liveRegions = []; // array of live region instances\r\n    \r\n    /*\r\n     * Set up the transform reference. we add a listener so that the transform itself can be modified directly\r\n     * by reference, or node.transform = <transform> / node.setTransform() can be used to change the transform reference.\r\n     * Both should trigger the necessary event notifications for Scenery to keep track internally.\r\n     */\r\n    this._transform = new Transform3();\r\n    this._transformListener = {\r\n      // TODO: performance handling so we don't need to do two recursions!\r\n      before: function() { self.beforeTransformChange(); },\r\n      after: function() { self.afterTransformChange(); }\r\n    };\r\n    this._transform.addTransformListener( this._transformListener );\r\n    \r\n    this._inputListeners = []; // for user input handling (mouse/touch)\r\n    this.initializeNodeEvents(); // for internal events like paint invalidation, layer invalidation, etc.\r\n    \r\n    // TODO: add getter/setters that will be able to invalidate whether this node is under any pointers, etc.\r\n    this._includeStrokeInHitRegion = false;\r\n    \r\n    // bounds handling\r\n    this._bounds = Bounds2.NOTHING;      // for this node and its children, in \"parent\" coordinates\r\n    this._selfBounds = Bounds2.NOTHING;  // just for this node, in \"local\" coordinates\r\n    this._childBounds = Bounds2.NOTHING; // just for children, in \"local\" coordinates\r\n    this._boundsDirty = true;\r\n    this._selfBoundsDirty = this.isPainted();\r\n    this._childBoundsDirty = true;\r\n    \r\n    // Similar to bounds, but includes any mouse/touch areas respectively. They are validated separately (immediately after normal bounds validation),\r\n    // and are only non-null if there are mouseAreas/touchAreas in this node or any descendants. null indicates that the normal bounds can be treated\r\n    // as the mouse/touch bounds, and hit pruning can use those instead. These are needed because mouse/touch areas (and thus pruning bounds) can be\r\n    // larger than the actual bounds (display bounds, _bounds above)\r\n    this._mouseBounds = null;\r\n    this._mouseBoundsDirty = true;\r\n    this._touchBounds = null;\r\n    this._touchBoundsDirty = true;\r\n    \r\n    // dirty region handling\r\n    this._paintDirty = false;        // whether the self paint is dirty (just this node, none of its children)\r\n    this._subtreePaintDirty = false; // whether the subtree paint is dirty (this node and its children, usually after a transform)\r\n    this._childPaintDirty = false;   // whether the child paint is dirty (excluding self paint, just used for finding _paintDirty, _selfPaintDirty)\r\n    \r\n    // what type of renderer should be forced for this node.\r\n    this._renderer = null;\r\n    this._rendererOptions = null; // options that will determine the layer type\r\n    this._rendererLayerType = null; // cached layer type that is used by the LayerStrategy\r\n    \r\n    // whether layers should be split before and/or after this node. setting both will put this node and its children into a separate layer\r\n    this._layerSplitBefore = false;\r\n    this._layerSplitAfter = false;\r\n    \r\n    if ( options ) {\r\n      this.mutate( options );\r\n    }\r\n  };\r\n  var Node = scenery.Node;\r\n  \r\n  Node.prototype = {\r\n    constructor: Node,\r\n    \r\n    insertChild: function( index, node ) {\r\n      sceneryAssert && sceneryAssert( node !== null && node !== undefined, 'insertChild cannot insert a null/undefined child' );\r\n      sceneryAssert && sceneryAssert( !_.contains( this._children, node ), 'Parent already contains child' );\r\n      sceneryAssert && sceneryAssert( node !== this, 'Cannot add self as a child' );\r\n      \r\n      node._parents.push( this );\r\n      this._children.splice( index, 0, node );\r\n      \r\n      node.invalidateBounds();\r\n      this._boundsDirty = true; // like calling this.invalidateBounds(), but we already marked all ancestors with dirty child bounds\r\n      \r\n      this.markForInsertion( node, index );\r\n      this.notifyStitch( false );\r\n      \r\n      node.invalidateSubtreePaint();\r\n    },\r\n    \r\n    addChild: function( node ) {\r\n      this.insertChild( this._children.length, node );\r\n    },\r\n    \r\n    removeChild: function( node ) {\r\n      sceneryAssert && sceneryAssert( node );\r\n      sceneryAssert && sceneryAssert( this.isChild( node ) );\r\n      \r\n      var indexOfChild = _.indexOf( this._children, node );\r\n      \r\n      this.removeChildWithIndex( node, indexOfChild );\r\n    },\r\n    \r\n    removeChildAt: function( index ) {\r\n      sceneryAssert && sceneryAssert( index >= 0 );\r\n      sceneryAssert && sceneryAssert( index < this._children.length );\r\n      \r\n      var node = this._children[index];\r\n      \r\n      this.removeChildWithIndex( node, index );\r\n    },\r\n    \r\n    // meant for internal use\r\n    removeChildWithIndex: function( node, indexOfChild ) {\r\n      sceneryAssert && sceneryAssert( node );\r\n      sceneryAssert && sceneryAssert( this.isChild( node ) );\r\n      sceneryAssert && sceneryAssert( this._children[indexOfChild] === node );\r\n      \r\n      node.markOldPaint( false );\r\n      \r\n      var indexOfParent = _.indexOf( node._parents, this );\r\n      \r\n      this.markForRemoval( node, indexOfChild );\r\n      \r\n      node._parents.splice( indexOfParent, 1 );\r\n      this._children.splice( indexOfChild, 1 );\r\n      \r\n      this.invalidateBounds();\r\n      this._childBoundsDirty = true; // force recomputation of child bounds after removing a child\r\n      \r\n      this.notifyStitch( false );\r\n    },\r\n    \r\n    removeAllChildren: function() {\r\n      this.setChildren( [] );\r\n    },\r\n    \r\n    // TODO: efficiency by batching calls?\r\n    setChildren: function( children ) {\r\n      if ( this._children !== children ) {\r\n        // remove all children in a way where we don't have to copy the child array for safety\r\n        while ( this._children.length ) {\r\n          this.removeChild( this._children[this._children.length-1] );\r\n        }\r\n        \r\n        var len = children.length;\r\n        for ( var i = 0; i < len; i++ ) {\r\n          this.addChild( children[i] );\r\n        }\r\n      }\r\n    },\r\n    \r\n    getChildren: function() {\r\n      return this._children.slice( 0 ); // create a defensive copy\r\n    },\r\n    \r\n    getChildrenCount: function() {\r\n      return this._children.length;\r\n    },\r\n    \r\n    getParents: function() {\r\n      return this._parents.slice( 0 ); // create a defensive copy\r\n    },\r\n    \r\n    getChildAt: function( index ) {\r\n      return this._children[index];\r\n    },\r\n    \r\n    indexOfParent: function( parent ) {\r\n      return _.indexOf( this._parents, parent );\r\n    },\r\n    \r\n    indexOfChild: function( child ) {\r\n      return _.indexOf( this._children, child );\r\n    },\r\n    \r\n    moveToFront: function() {\r\n      var self = this;\r\n      _.each( this._parents.slice( 0 ), function( parent ) {\r\n        parent.moveChildToFront( self );\r\n      } );\r\n    },\r\n    \r\n    moveChildToFront: function( child ) {\r\n      if ( this.indexOfChild( child ) !== this._children.length - 1 ) {\r\n        this.removeChild( child );\r\n        this.addChild( child );\r\n      }\r\n    },\r\n    \r\n    moveToBack: function() {\r\n      var self = this;\r\n      _.each( this._parents.slice( 0 ), function( parent ) {\r\n        parent.moveChildToBack( self );\r\n      } );\r\n    },\r\n    \r\n    moveChildToBack: function( child ) {\r\n      if ( this.indexOfChild( child ) !== 0 ) {\r\n        this.removeChild( child );\r\n        this.insertChild( 0, child );\r\n      }\r\n    },\r\n    \r\n    // remove this node from its parents\r\n    detach: function() {\r\n      var that = this;\r\n      _.each( this._parents.slice( 0 ), function( parent ) {\r\n        parent.removeChild( that );\r\n      } );\r\n    },\r\n    \r\n    // currently, there is no way to remove peers. if a string is passed as the element pattern, it will be turned into an element\r\n    addPeer: function( element, options ) {\r\n      sceneryAssert && sceneryAssert( !this.instances.length, 'Cannot call addPeer after a node has instances (yet)' );\r\n      \r\n      this._peers.push( { element: element, options: options } );\r\n    },\r\n\r\n    /**               \r\n     * @param property any object that has es5 getter for 'value' es5 setter for value, and \r\n     */\r\n    addLiveRegion: function( property, options ) {\r\n      this._liveRegions.push( {property: property, options: options} );\r\n    },\r\n    \r\n    // ensure that cached bounds stored on this node (and all children) are accurate\r\n    validateBounds: function() {\r\n      var that = this;\r\n      var i;\r\n      \r\n      if ( this._selfBoundsDirty ) {\r\n        // note: this should only be triggered if the bounds were actually changed, since we have a guard in place at invalidateSelf()\r\n        this._selfBoundsDirty = false;\r\n        \r\n        // TODO: consider changing to parameter object (that may be a problem for the GC overhead)\r\n        this.fireEvent( 'selfBounds', this._selfBounds );\r\n      }\r\n      \r\n      // validate bounds of children if necessary\r\n      if ( this._childBoundsDirty ) {\r\n        \r\n        // have each child validate their own bounds\r\n        i = this._children.length;\r\n        while ( i-- ) {\r\n          this._children[i].validateBounds();\r\n        }\r\n        \r\n        var oldChildBounds = this._childBounds;\r\n        \r\n        // and recompute our _childBounds\r\n        this._childBounds = Bounds2.NOTHING.copy();\r\n        \r\n        i = this._children.length;\r\n        while ( i-- ) {\r\n          this._childBounds.includeBounds( this._children[i]._bounds );\r\n        }\r\n        \r\n        // run this before firing the event\r\n        this._childBoundsDirty = false;\r\n        \r\n        if ( !this._childBounds.equals( oldChildBounds ) ) {\r\n          // TODO: consider changing to parameter object (that may be a problem for the GC overhead)\r\n          this.fireEvent( 'childBounds', this._childBounds );\r\n        }\r\n      }\r\n      \r\n      // TODO: layout here?\r\n      \r\n      if ( this._boundsDirty ) {\r\n        // run this before firing the event\r\n        this._boundsDirty = false;\r\n        \r\n        var oldBounds = this._bounds;\r\n        \r\n        // converts local to parent bounds. mutable methods used to minimize number of created bounds instances (we create one so we don't change references to the old one)\r\n        var newBounds = this.transformBoundsFromLocalToParent( this._selfBounds.copy().includeBounds( this._childBounds ) );\r\n        var changed = !newBounds.equals( oldBounds );\r\n        \r\n        if ( changed ) {\r\n          this._bounds = newBounds;\r\n          \r\n          i = this._parents.length;\r\n          while ( i-- ) {\r\n            this._parents[i].invalidateBounds();\r\n          }\r\n          \r\n          // TODO: consider changing to parameter object (that may be a problem for the GC overhead)\r\n          this.fireEvent( 'bounds', this._bounds );\r\n        }\r\n      }\r\n      \r\n      // if there were side-effects, run the validation again until we are clean\r\n      if ( this._selfBoundsDirty || this._childBoundsDirty || this._boundsDirty ) {\r\n        // TODO: if there are side-effects in listeners, this could overflow the stack. we should report an error instead of locking up\r\n        this.validateBounds();\r\n      }\r\n      \r\n      // double-check that all of our bounds handling has been accurate\r\n      if ( sceneryAssertExtra ) {\r\n        // new scope for safety\r\n        (function(){\r\n          var epsilon = 0.000001;\r\n          \r\n          var childBounds = Bounds2.NOTHING.copy();\r\n          _.each( that.children, function( child ) { childBounds.includeBounds( child._bounds ); } );\r\n          \r\n          var fullBounds = that.localToParentBounds( that._selfBounds ).union( that.localToParentBounds( childBounds ) );\r\n          \r\n          sceneryAssertExtra && sceneryAssertExtra( that._childBounds.equalsEpsilon( childBounds, epsilon ), 'Child bounds mismatch after validateBounds: ' +\r\n                                                                                                    that._childBounds.toString() + ', expected: ' + childBounds.toString() );\r\n          sceneryAssertExtra && sceneryAssertExtra( that._bounds.equalsEpsilon( fullBounds, epsilon ), 'Bounds mismatch after validateBounds: ' +\r\n                                                                                              that._bounds.toString() + ', expected: ' + fullBounds.toString() );\r\n        })();\r\n      }\r\n    },\r\n    \r\n    validateMouseBounds: function() {\r\n      var that = this;\r\n      \r\n      sceneryAssert && sceneryAssert( !this._selfBoundsDirty && !this._childBoundsDirty && !this._boundsDirty, 'Bounds must be validated before calling validateMouseBounds' );\r\n      \r\n      if ( this._mouseBoundsDirty ) {\r\n        var hasMouseAreas = false;\r\n        \r\n        this._mouseBounds = this._selfBounds.copy(); // start with the self bounds, then add from there\r\n        \r\n        // union of all children's mouse bounds (if they exist)\r\n        var i = this._children.length;\r\n        while ( i-- ) {\r\n          var child = this._children[i];\r\n          child.validateMouseBounds();\r\n          if ( child._mouseBounds ) {\r\n            hasMouseAreas = true;\r\n            that._mouseBounds.includeBounds( child._mouseBounds );\r\n          }\r\n        }\r\n        \r\n        // do this before the transformation to the parent coordinate frame\r\n        if ( this._mouseArea ) {\r\n          hasMouseAreas = true;\r\n          this._mouseBounds.includeBounds( this._mouseArea.bounds );\r\n        }\r\n        \r\n        if ( hasMouseAreas ) {\r\n          // transform it to the parent coordinate frame\\\r\n          this.transformBoundsFromLocalToParent( this._mouseBounds );\r\n          \r\n          // and include the normal bounds, so that we don't have to \r\n          this._mouseBounds.includeBounds( this._bounds );\r\n        } else {\r\n          this._mouseBounds = null; // no mouse areas under this node\r\n        }\r\n        \r\n        this._mouseBoundsDirty = false;\r\n      }\r\n    },\r\n    \r\n    validateTouchBounds: function() {\r\n      var that = this;\r\n      \r\n      sceneryAssert && sceneryAssert( !this._selfBoundsDirty && !this._childBoundsDirty && !this._boundsDirty, 'Bounds must be validated before calling validateTouchBounds' );\r\n      \r\n      if ( this._touchBoundsDirty ) {\r\n        var hasTouchAreas = false;\r\n        \r\n        this._touchBounds = this._selfBounds.copy(); // start with the self bounds, then add from there\r\n        \r\n        // union of all children's touch bounds (if they exist)\r\n        var i = this._children.length;\r\n        while ( i-- ) {\r\n          var child = this._children[i];\r\n          child.validateTouchBounds();\r\n          if ( child._touchBounds ) {\r\n            hasTouchAreas = true;\r\n            that._touchBounds.includeBounds( child._touchBounds );\r\n          }\r\n        }\r\n        \r\n        // do this before the transformation to the parent coordinate frame\r\n        if ( this._touchArea ) {\r\n          hasTouchAreas = true;\r\n          this._touchBounds.includeBounds( this._touchArea.bounds );\r\n        }\r\n        \r\n        if ( hasTouchAreas ) {\r\n          // transform it to the parent coordinate frame\r\n          this.transformBoundsFromLocalToParent( this._touchBounds );\r\n          \r\n          // and include the normal bounds, so that we don't have to \r\n          this._touchBounds.includeBounds( this._bounds );\r\n        } else {\r\n          this._touchBounds = null; // no touch areas under this node\r\n        }\r\n        \r\n        this._touchBoundsDirty = false;\r\n      }\r\n    },\r\n    \r\n    validatePaint: function() {\r\n      if ( this._paintDirty ) {\r\n        sceneryAssert && sceneryAssert( this.isPainted(), 'Only painted nodes can have self dirty paint' );\r\n        if ( !this._subtreePaintDirty ) {\r\n          // if the subtree is clean, just notify the self (only will hit one layer, instead of possibly multiple ones)\r\n          this.notifyDirtySelfPaint();\r\n        }\r\n        this._paintDirty = false;\r\n      }\r\n      \r\n      if ( this._subtreePaintDirty ) {\r\n        this.notifyDirtySubtreePaint();\r\n        this._subtreePaintDirty = false;\r\n      }\r\n      \r\n      // clear flags and recurse\r\n      if ( this._childPaintDirty ) {\r\n        this._childPaintDirty = false;\r\n        \r\n        var children = this._children;\r\n        var length = children.length;\r\n        for ( var i = 0; i < length; i++ ) {\r\n          children[i].validatePaint();\r\n        }\r\n      }\r\n    },\r\n    \r\n    // mark the bounds of this node as invalid, so it is recomputed before it is accessed again\r\n    invalidateBounds: function() {\r\n      this._boundsDirty = true;\r\n      this._mouseBoundsDirty = true;\r\n      this._touchBoundsDirty = true;\r\n      \r\n      // and set flags for all ancestors\r\n      var i = this._parents.length;\r\n      while ( i-- ) {\r\n        this._parents[i].invalidateChildBounds();\r\n      }\r\n    },\r\n    \r\n    // recursively tag all ancestors with _childBoundsDirty\r\n    invalidateChildBounds: function() {\r\n      // don't bother updating if we've already been tagged\r\n      if ( !this._childBoundsDirty ) {\r\n        this._childBoundsDirty = true;\r\n        this._mouseBoundsDirty = true;\r\n        this._touchBoundsDirty = true;\r\n        var i = this._parents.length;\r\n        while ( i-- ) {\r\n          this._parents[i].invalidateChildBounds();\r\n        }\r\n      }\r\n    },\r\n    \r\n    // mark the paint of this node as invalid, so its new region will be painted\r\n    invalidatePaint: function() {\r\n      sceneryAssert && sceneryAssert( this.isPainted(), 'Can only call invalidatePaint on a painted node' );\r\n      this._paintDirty = true;\r\n      \r\n      // and set flags for all ancestors\r\n      var i = this._parents.length;\r\n      while ( i-- ) {\r\n        this._parents[i].invalidateChildPaint();\r\n      }\r\n    },\r\n    \r\n    invalidateSubtreePaint: function() {\r\n      this._subtreePaintDirty = true;\r\n      \r\n      // and set flags for all ancestors\r\n      var i = this._parents.length;\r\n      while ( i-- ) {\r\n        this._parents[i].invalidateChildPaint();\r\n      }\r\n    },\r\n    \r\n    // recursively tag all ancestors with _childPaintDirty\r\n    invalidateChildPaint: function() {\r\n      // don't bother updating if we've already been tagged\r\n      if ( !this._childPaintDirty ) {\r\n        this._childPaintDirty = true;\r\n        var i = this._parents.length;\r\n        while ( i-- ) {\r\n          this._parents[i].invalidateChildPaint();\r\n        }\r\n      }\r\n    },\r\n    \r\n    // called to notify that self rendering will display different paint, with possibly different bounds\r\n    invalidateSelf: function( newBounds ) {\r\n      sceneryAssert && sceneryAssert( newBounds.isEmpty() || newBounds.isFinite() , \"Bounds must be empty or finite in invalidateSelf\");\r\n      \r\n      // mark the old region to be repainted, regardless of whether the actual bounds change\r\n      this.notifyBeforeSelfChange();\r\n      \r\n      // if these bounds are different than current self bounds\r\n      if ( !this._selfBounds.equals( newBounds ) ) {\r\n        // set repaint flags\r\n        this._selfBoundsDirty = true;\r\n        this.invalidateBounds();\r\n        \r\n        // record the new bounds\r\n        this._selfBounds = newBounds;\r\n      }\r\n      \r\n      this.invalidatePaint();\r\n    },\r\n    \r\n    markOldSelfPaint: function() {\r\n      this.notifyBeforeSelfChange();\r\n    },\r\n    \r\n    // should be called whenever something triggers changes for how this node is layered\r\n    markLayerRefreshNeeded: function() {\r\n      this.markForLayerRefresh();\r\n      this.notifyStitch( true );\r\n    },\r\n    \r\n    // marks the last-rendered bounds of this node and optionally all of its descendants as needing a repaint\r\n    markOldPaint: function( justSelf ) {\r\n      // TODO: rearchitecture\r\n      if ( justSelf ) {\r\n        this.notifyBeforeSelfChange();\r\n      } else {\r\n        this.notifyBeforeSubtreeChange();\r\n      }\r\n    },\r\n    \r\n    isChild: function( potentialChild ) {\r\n      var ourChild = _.contains( this._children, potentialChild );\r\n      var itsParent = _.contains( potentialChild._parents, this );\r\n      sceneryAssert && sceneryAssert( ourChild === itsParent );\r\n      return ourChild;\r\n    },\r\n    \r\n    // the bounds for self content in \"local\" coordinates.\r\n    getSelfBounds: function() {\r\n      return this._selfBounds;\r\n    },\r\n    \r\n    getChildBounds: function() {\r\n      this.validateBounds();\r\n      return this._childBounds;\r\n    },\r\n    \r\n    // the bounds for content in render(), in \"parent\" coordinates\r\n    getBounds: function() {\r\n      this.validateBounds();\r\n      return this._bounds;\r\n    },\r\n    \r\n    // like getBounds() in the \"parent\" coordinate frame, but includes only visible nodes\r\n    getVisibleBounds: function() {\r\n      // defensive copy, since we use mutable modifications below\r\n      var bounds = this._selfBounds.copy();\r\n      \r\n      var i = this._children.length;\r\n      while ( i-- ) {\r\n        var child = this._children[i];\r\n        if ( child.isVisible() ) {\r\n          bounds.includeBounds( child.getVisibleBounds() );\r\n        }\r\n      }\r\n      \r\n      sceneryAssert && sceneryAssert( bounds.isFinite() || bounds.isEmpty(), 'Visible bounds should not be infinite' );\r\n      return this.localToParentBounds( bounds );\r\n    },\r\n    \r\n    trailUnderPointer: function( pointer ) {\r\n      var options = {};\r\n      if ( pointer.isMouse ) { options.isMouse = true; }\r\n      if ( pointer.isTouch ) { options.isTouch = true; }\r\n      if ( pointer.isPen ) { options.isPen = true; }\r\n      \r\n      return this.trailUnderPoint( pointer.point, options );\r\n    },\r\n    \r\n    /*\r\n     * Return a trail to the top node (if any, otherwise null) whose self-rendered area contains the\r\n     * point (in parent coordinates).\r\n     *\r\n     * If options.pruneInvisible is false, invisible nodes will be allowed in the trail.\r\n     * If options.pruneUnpickable is false, unpickable nodes will be allowed in the trail.\r\n     */\r\n    trailUnderPoint: function( point, options ) {\r\n      sceneryAssert && sceneryAssert( point, 'trailUnderPointer requires a point' );\r\n      \r\n      if ( options === undefined ) { options = {}; }\r\n      \r\n      var pruneInvisible = ( options.pruneInvisible === undefined ) ? true : options.pruneInvisible;\r\n      var pruneUnpickable = ( options.pruneUnpickable === undefined ) ? true : options.pruneUnpickable;\r\n      \r\n      if ( pruneInvisible && !this.isVisible() ) {\r\n        return null;\r\n      }\r\n      if ( pruneUnpickable && !this.isPickable() ) {\r\n        return null;\r\n      }\r\n      \r\n      // update bounds for pruning\r\n      this.validateBounds();\r\n      if ( options.isMouse ) { this.validateMouseBounds(); }\r\n      if ( options.isTouch ) { this.validateTouchBounds(); }\r\n      \r\n      var hasHitAreas = options && ( ( options.isMouse && this._mouseBounds ) || ( options.isTouch && this._touchBounds ) || options.isPen );\r\n      \r\n      // bail quickly if this doesn't hit our computed bounds\r\n      if ( hasHitAreas ? (\r\n            // if we have hit areas, prune based on the respective hit bounds (mouseBounds/touchBounds)\r\n            ( options.isMouse && !this._mouseBounds.containsPoint( point ) ) ||\r\n            ( options.isTouch && !this._touchBounds.containsPoint( point ) )\r\n            // otherwise, prune based on the normal bounds\r\n          ) : !this._bounds.containsPoint( point ) ) {\r\n        return null; // not in our bounds, so this point can't possibly be contained\r\n      }\r\n      \r\n      // point in the local coordinate frame. computed after the main bounds check, so we can bail out there efficiently\r\n      var localPoint = this.parentToLocalPoint( point );\r\n      \r\n      // check children first, since they are rendered later\r\n      if ( this._children.length > 0 && ( hasHitAreas || this._childBounds.containsPoint( localPoint ) ) ) {\r\n        \r\n        // manual iteration here so we can return directly, and so we can iterate backwards (last node is in front)\r\n        for ( var i = this._children.length - 1; i >= 0; i-- ) {\r\n          var child = this._children[i];\r\n          \r\n          var childHit = child.trailUnderPoint( localPoint, options );\r\n          \r\n          // the child will have the point in its parent's coordinate frame (i.e. this node's frame)\r\n          if ( childHit ) {\r\n            childHit.addAncestor( this, i );\r\n            return childHit;\r\n          }\r\n        }\r\n      }\r\n\r\n      // tests for mouse and touch hit areas before testing containsPointSelf\r\n      if ( hasHitAreas ) {\r\n        if ( options.isMouse && this._mouseArea ) {\r\n          return this._mouseArea.containsPoint( localPoint ) ? new scenery.Trail( this ) : null;\r\n        }\r\n        if ( ( options.isTouch || options.isPen ) && this._touchArea ) {\r\n          return this._touchArea.containsPoint( localPoint ) ? new scenery.Trail( this ) : null;\r\n        }\r\n      }\r\n      \r\n      // didn't hit our children, so check ourself as a last resort\r\n      if ( hasHitAreas || this._selfBounds.containsPoint( localPoint ) ) {\r\n        if ( this.containsPointSelf( localPoint ) ) {\r\n          return new scenery.Trail( this );\r\n        }\r\n      }\r\n      \r\n      // signal no hit\r\n      return null;\r\n    },\r\n    \r\n    // checking for whether a point (in parent coordinates) is contained in this sub-tree\r\n    containsPoint: function( point ) {\r\n      return this.trailUnderPoint( point ) !== null;\r\n    },\r\n    \r\n    // override for computation of whether a point is inside the self content\r\n    // point is considered to be in the local coordinate frame\r\n    containsPointSelf: function( point ) {\r\n      // if self bounds are not null default to checking self bounds\r\n      return this._selfBounds.containsPoint( point );\r\n    },\r\n    \r\n    // whether this node's self intersects the specified bounds, in the local coordinate frame\r\n    intersectsBoundsSelf: function( bounds ) {\r\n      // if self bounds are not null, child should override this\r\n      return this._selfBounds.intersectsBounds( bounds );\r\n    },\r\n    \r\n    isPainted: function() {\r\n      return false;\r\n    },\r\n    \r\n    hasParent: function() {\r\n      return this._parents.length !== 0;\r\n    },\r\n    \r\n    hasChildren: function() {\r\n      return this._children.length > 0;\r\n    },\r\n    \r\n    walkDepthFirst: function( callback ) {\r\n      callback( this );\r\n      var length = this._children.length;\r\n      for ( var i = 0; i < length; i++ ) {\r\n        this._children[i].walkDepthFirst( callback );\r\n      }\r\n    },\r\n    \r\n    getChildrenWithinBounds: function( bounds ) {\r\n      var result = [];\r\n      var length = this._children.length;\r\n      for ( var i = 0; i < length; i++ ) {\r\n        var child = this._children[i];\r\n        if ( !child._bounds.intersection( bounds ).isEmpty() ) {\r\n          result.push( child );\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n    \r\n    // TODO: set this up with a mix-in for a generic notifier?\r\n    addInputListener: function( listener ) {\r\n      // don't allow listeners to be added multiple times\r\n      if ( _.indexOf( this._inputListeners, listener ) === -1 ) {\r\n        this._inputListeners.push( listener );\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    removeInputListener: function( listener ) {\r\n      // ensure the listener is in our list\r\n      sceneryAssert && sceneryAssert( _.indexOf( this._inputListeners, listener ) !== -1 );\r\n      \r\n      this._inputListeners.splice( _.indexOf( this._inputListeners, listener ), 1 );\r\n      return this;\r\n    },\r\n    \r\n    getInputListeners: function() {\r\n      return this._inputListeners.slice( 0 ); // defensive copy\r\n    },\r\n    \r\n    /*\r\n     * Dispatches an event across all possible Trails ending in this node.\r\n     *\r\n     * For example, if the scene has two children A and B, and both of those nodes have X as a child,\r\n     * dispatching an event on X will fire the event with the following trails:\r\n     * on X     with trail [ X ]\r\n     * on A     with trail [ A, X ]\r\n     * on scene with trail [ scene, A, X ]\r\n     * on B     with trail [ B, X ]\r\n     * on scene with trail [ scene, B, X ]\r\n     *\r\n     * This allows you to add a listener on any node to get notifications for all of the trails that the\r\n     * event is relevant for (e.g. marks dirty paint region for both places X was on the scene).\r\n     */\r\n    dispatchEvent: function( type, args ) {\r\n      sceneryEventLog && sceneryEventLog( this.constructor.name + '.dispatchEvent ' + type );\r\n      var trail = new scenery.Trail();\r\n      trail.setMutable(); // don't allow this trail to be set as immutable for storage\r\n      args.trail = trail; // this reference shouldn't be changed be listeners (or errors will occur)\r\n      \r\n      // store a branching flag, since if we don't branch at all, we don't have to walk our trail back down.\r\n      var branches = false;\r\n      \r\n      function recursiveEventDispatch( node ) {\r\n        trail.addAncestor( node );\r\n        \r\n        node.fireEvent( type, args );\r\n        \r\n        var parents = node._parents;\r\n        var length = parents.length;\r\n        \r\n        // make sure to set the branch flag here before iterating (don't move it)\r\n        branches = branches || length > 1;\r\n        \r\n        for ( var i = 0; i < length; i++ ) {\r\n          recursiveEventDispatch( parents[i] );\r\n        }\r\n        \r\n        // if there were no branches, we will not fire another listener once we have reached here\r\n        if ( branches ) {\r\n          trail.removeAncestor();\r\n        }\r\n      }\r\n      \r\n      recursiveEventDispatch( this );\r\n    },\r\n    \r\n    // TODO: consider renaming to translateBy to match scaleBy\r\n    translate: function( x, y, prependInstead ) {\r\n      if ( typeof x === 'number' ) {\r\n        // translate( x, y, prependInstead )\r\n        if ( !x && !y ) { return; } // bail out if both are zero\r\n        if ( prependInstead ) {\r\n          this.prependMatrix( Matrix3.translation( x, y ) );\r\n        } else {\r\n          this.appendMatrix( Matrix3.translation( x, y ) );\r\n        }\r\n      } else {\r\n        // translate( vector, prependInstead )\r\n        var vector = x;\r\n        if ( !vector.x && !vector.y ) { return; } // bail out if both are zero\r\n        this.translate( vector.x, vector.y, y ); // forward to full version\r\n      }\r\n    },\r\n    \r\n    // scale( s ) is also supported, which will scale both dimensions by the same amount. renamed from 'scale' to satisfy the setter/getter\r\n    scale: function( x, y, prependInstead ) {\r\n      if ( typeof x === 'number' ) {\r\n        if ( y === undefined ) {\r\n          // scale( scale )\r\n          if ( x === 1 ) { return; } // bail out if we are scaling by 1 (identity)\r\n          this.appendMatrix( Matrix3.scaling( x, x ) );\r\n        } else {\r\n          // scale( x, y, prependInstead )\r\n          if ( x === 1 && y === 1 ) { return; } // bail out if we are scaling by 1 (identity)\r\n          if ( prependInstead ) {\r\n            this.prependMatrix( Matrix3.scaling( x, y ) );\r\n          } else {\r\n            this.appendMatrix( Matrix3.scaling( x, y ) );\r\n          }\r\n        }\r\n      } else {\r\n        // scale( vector, prependInstead ) or scale( { x: x, y: y }, prependInstead )\r\n        var vector = x;\r\n        this.scale( vector.x, vector.y, y ); // forward to full version\r\n      }\r\n    },\r\n    \r\n    // TODO: consider naming to rotateBy to match scaleBy (due to scale property / method name conflict)\r\n    rotate: function( angle, prependInstead ) {\r\n      if ( angle % ( 2 * Math.PI ) === 0 ) { return; } // bail out if our angle is effectively 0\r\n      if ( prependInstead ) {\r\n        this.prependMatrix( Matrix3.rotation2( angle ) );\r\n      } else {\r\n        this.appendMatrix( Matrix3.rotation2( angle ) );\r\n      }\r\n    },\r\n    \r\n    // point should be in the parent coordinate frame\r\n    // TODO: determine whether this should use the appendMatrix method\r\n    rotateAround: function( point, angle ) {\r\n      var matrix = Matrix3.translation( -point.x, -point.y );\r\n      matrix = Matrix3.rotation2( angle ).timesMatrix( matrix );\r\n      matrix = Matrix3.translation( point.x, point.y ).timesMatrix( matrix );\r\n      this.prependMatrix( matrix );\r\n    },\r\n    \r\n    getX: function() {\r\n      return this.getTranslation().x;\r\n    },\r\n    \r\n    setX: function( x ) {\r\n      sceneryAssert && sceneryAssert( typeof x === 'number' );\r\n      \r\n      this.setTranslation( x, this.getY() );\r\n      return this;\r\n    },\r\n    \r\n    getY: function() {\r\n      return this.getTranslation().y;\r\n    },\r\n    \r\n    setY: function( y ) {\r\n      sceneryAssert && sceneryAssert( typeof y === 'number' );\r\n      \r\n      this.setTranslation( this.getX(), y );\r\n      return this;\r\n    },\r\n    \r\n    // returns a vector with an entry for each axis, e.g. (5,2) for an Affine-style matrix with rows ((5,0,0),(0,2,0),(0,0,1))\r\n    getScaleVector: function() {\r\n      return this._transform.getMatrix().getScaleVector();\r\n    },\r\n    \r\n    // supports setScaleMagnitude( 5 ) for both dimensions, setScaleMagnitude( 5, 3 ) for each dimension separately, or setScaleMagnitude( new Vector2( x, y ) )\r\n    setScaleMagnitude: function( a, b ) {\r\n      var currentScale = this.getScaleVector();\r\n      \r\n      if ( typeof a === 'number' ) {\r\n        if ( b === undefined ) {\r\n          // to map setScaleMagnitude( scale ) => setScaleMagnitude( scale, scale )\r\n          b = a;\r\n        }\r\n        // setScaleMagnitude( x, y )\r\n        this.appendMatrix( Matrix3.scaling( a / currentScale.x, b / currentScale.y ) );\r\n      } else {\r\n        // setScaleMagnitude( vector ), where we set the x-scale to vector.x and y-scale to vector.y\r\n        this.appendMatrix( Matrix3.scaling( a.x / currentScale.x, a.y / currentScale.y ) );\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    getRotation: function() {\r\n      return this._transform.getMatrix().getRotation();\r\n    },\r\n    \r\n    setRotation: function( rotation ) {\r\n      sceneryAssert && sceneryAssert( typeof rotation === 'number' );\r\n      \r\n      this.appendMatrix( Matrix3.rotation2( rotation - this.getRotation() ) );\r\n      return this;\r\n    },\r\n    \r\n    // supports setTranslation( x, y ) or setTranslation( new Vector2( x, y ) ) .. or technically setTranslation( { x: x, y: y } )\r\n    setTranslation: function( a, b ) {\r\n      var translation = this.getTranslation();\r\n      \r\n      var dx, dy;\r\n      \r\n      if ( typeof a === 'number' ) {\r\n        dx = a - translation.x;\r\n        dy = b - translation.y;\r\n      } else {\r\n        dx = a.x - translation.x;\r\n        dy = a.y - translation.y;\r\n      }\r\n      \r\n      this.translate( dx, dy, true );\r\n      \r\n      return this;\r\n    },\r\n    \r\n    getTranslation: function() {\r\n      return this._transform.getMatrix().getTranslation();\r\n    },\r\n    \r\n    // append a transformation matrix to our local transform\r\n    appendMatrix: function( matrix ) {\r\n      this._transform.append( matrix );\r\n    },\r\n    \r\n    // prepend a transformation matrix to our local transform\r\n    prependMatrix: function( matrix ) {\r\n      this._transform.prepend( matrix );\r\n    },\r\n    \r\n    setMatrix: function( matrix ) {\r\n      this._transform.set( matrix );\r\n    },\r\n    \r\n    getMatrix: function() {\r\n      return this._transform.getMatrix();\r\n    },\r\n    \r\n    // change the actual transform reference (not just the actual transform)\r\n    setTransform: function( transform ) {\r\n      sceneryAssert && sceneryAssert( transform.isFinite(), 'Transform should not have infinite/NaN values' );\r\n      \r\n      if ( this._transform !== transform ) {\r\n        // since our referenced transform doesn't change, we need to trigger the before/after ourselves\r\n        this.beforeTransformChange();\r\n        \r\n        // swap the transform and move the listener to the new one\r\n        this._transform.removeTransformListener( this._transformListener ); // don't leak memory!\r\n        this._transform = transform;\r\n        this._transform.prependTransformListener( this._transformListener );\r\n        \r\n        this.afterTransformChange();\r\n      }\r\n    },\r\n    \r\n    getTransform: function() {\r\n      // for now, return an actual copy. we can consider listening to changes in the future\r\n      return this._transform;\r\n    },\r\n    \r\n    resetTransform: function() {\r\n      this.setMatrix( Matrix3.IDENTITY );\r\n    },\r\n    \r\n    // called before our transform is changed\r\n    beforeTransformChange: function() {\r\n      // mark our old bounds as dirty, so that any dirty region repainting will include not just our new position, but also our old position\r\n      this.notifyBeforeSubtreeChange();\r\n    },\r\n    \r\n    // called after our transform is changed\r\n    afterTransformChange: function() {\r\n      this.notifyTransformChange();\r\n      \r\n      this.invalidateBounds();\r\n      this.invalidateSubtreePaint();\r\n    },\r\n    \r\n    // the left bound of this node, in the parent coordinate frame\r\n    getLeft: function() {\r\n      return this.getBounds().minX;\r\n    },\r\n    \r\n    // shifts this node horizontally so that its left bound (in the parent coordinate frame) is 'left'\r\n    setLeft: function( left ) {\r\n      sceneryAssert && sceneryAssert( typeof left === 'number' );\r\n      \r\n      this.translate( left - this.getLeft(), 0, true );\r\n      return this; // allow chaining\r\n    },\r\n    \r\n    // the right bound of this node, in the parent coordinate frame\r\n    getRight: function() {\r\n      return this.getBounds().maxX;\r\n    },\r\n    \r\n    // shifts this node horizontally so that its right bound (in the parent coordinate frame) is 'right'\r\n    setRight: function( right ) {\r\n      sceneryAssert && sceneryAssert( typeof right === 'number' );\r\n      \r\n      this.translate( right - this.getRight(), 0, true );\r\n      return this; // allow chaining\r\n    },\r\n    \r\n    getCenter: function() {\r\n      return this.getBounds().getCenter();\r\n    },\r\n    \r\n    setCenter: function( center ) {\r\n      sceneryAssert && sceneryAssert( center instanceof Vector2 );\r\n      \r\n      this.translate( center.minus( this.getCenter() ), true );\r\n      return this;\r\n    },\r\n    \r\n    getCenterX: function() {\r\n      return this.getBounds().getCenterX();\r\n    },\r\n    \r\n    setCenterX: function( x ) {\r\n      sceneryAssert && sceneryAssert( typeof x === 'number' );\r\n      \r\n      this.translate( x - this.getCenterX(), 0, true );\r\n      return this; // allow chaining\r\n    },\r\n    \r\n    getCenterY: function() {\r\n      return this.getBounds().getCenterY();\r\n    },\r\n    \r\n    setCenterY: function( y ) {\r\n      sceneryAssert && sceneryAssert( typeof y === 'number' );\r\n      \r\n      this.translate( 0, y - this.getCenterY(), true );\r\n      return this; // allow chaining\r\n    },\r\n    \r\n    // the top bound of this node, in the parent coordinate frame\r\n    getTop: function() {\r\n      return this.getBounds().minY;\r\n    },\r\n    \r\n    // shifts this node vertically so that its top bound (in the parent coordinate frame) is 'top'\r\n    setTop: function( top ) {\r\n      sceneryAssert && sceneryAssert( typeof top === 'number' );\r\n      \r\n      this.translate( 0, top - this.getTop(), true );\r\n      return this; // allow chaining\r\n    },\r\n    \r\n    // the bottom bound of this node, in the parent coordinate frame\r\n    getBottom: function() {\r\n      return this.getBounds().maxY;\r\n    },\r\n    \r\n    // shifts this node vertically so that its bottom bound (in the parent coordinate frame) is 'bottom'\r\n    setBottom: function( bottom ) {\r\n      sceneryAssert && sceneryAssert( typeof bottom === 'number' );\r\n      \r\n      this.translate( 0, bottom - this.getBottom(), true );\r\n      return this; // allow chaining\r\n    },\r\n    \r\n    getWidth: function() {\r\n      return this.getBounds().getWidth();\r\n    },\r\n    \r\n    getHeight: function() {\r\n      return this.getBounds().getHeight();\r\n    },\r\n    \r\n    getId: function() {\r\n      return this._id;\r\n    },\r\n    \r\n    isVisible: function() {\r\n      return this._visible;\r\n    },\r\n    \r\n    setVisible: function( visible ) {\r\n      sceneryAssert && sceneryAssert( typeof visible === 'boolean' );\r\n      \r\n      if ( visible !== this._visible ) {\r\n        if ( this._visible ) {\r\n          this.notifyBeforeSubtreeChange();\r\n        }\r\n        \r\n        this._visible = visible;\r\n        \r\n        this.notifyVisibilityChange();\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    getOpacity: function() {\r\n      return this._opacity;\r\n    },\r\n    \r\n    setOpacity: function( opacity ) {\r\n      sceneryAssert && sceneryAssert( typeof opacity === 'number' );\r\n      \r\n      var clampedOpacity = clamp( opacity, 0, 1 );\r\n      if ( clampedOpacity !== this._opacity ) {\r\n        this.notifyBeforeSubtreeChange();\r\n        \r\n        this._opacity = clampedOpacity;\r\n        \r\n        this.notifyOpacityChange();\r\n      }\r\n    },\r\n    \r\n    isPickable: function() {\r\n      return this._pickable;\r\n    },\r\n    \r\n    setPickable: function( pickable ) {\r\n      sceneryAssert && sceneryAssert( typeof pickable === 'boolean' );\r\n      \r\n      if ( this._pickable !== pickable ) {\r\n        // no paint or invalidation changes for now, since this is only handled for the mouse\r\n        this._pickable = pickable;\r\n        \r\n        // TODO: invalidate the cursor somehow?\r\n      }\r\n    },\r\n    \r\n    setCursor: function( cursor ) {\r\n      sceneryAssert && sceneryAssert( typeof cursor === 'string' || cursor === null );\r\n      \r\n      // TODO: consider a mapping of types to set reasonable defaults\r\n      /*\r\n      auto default none inherit help pointer progress wait crosshair text vertical-text alias copy move no-drop not-allowed\r\n      e-resize n-resize w-resize s-resize nw-resize ne-resize se-resize sw-resize ew-resize ns-resize nesw-resize nwse-resize\r\n      context-menu cell col-resize row-resize all-scroll url( ... ) --> does it support data URLs?\r\n       */\r\n      \r\n      // allow the 'auto' cursor type to let the ancestors or scene pick the cursor type\r\n      this._cursor = cursor === \"auto\" ? null : cursor;\r\n    },\r\n    \r\n    getCursor: function() {\r\n      return this._cursor;\r\n    },\r\n    \r\n    setMouseArea: function( shape ) {\r\n      sceneryAssert && sceneryAssert( shape === null || shape instanceof Shape, 'mouseArea needs to be a kite.Shape, or null' );\r\n      \r\n      if ( this._mouseArea !== shape ) {\r\n        this._mouseArea = shape; // TODO: could change what is under the mouse, invalidate!\r\n        \r\n        this.invalidateBounds();\r\n      }\r\n    },\r\n    \r\n    getMouseArea: function() {\r\n      return this._mouseArea;\r\n    },\r\n    \r\n    setTouchArea: function( shape ) {\r\n      sceneryAssert && sceneryAssert( shape === null || shape instanceof Shape, 'touchArea needs to be a kite.Shape, or null' );\r\n      \r\n      if ( this._touchArea !== shape ) {\r\n        this._touchArea = shape; // TODO: could change what is under the touch, invalidate!\r\n        \r\n        this.invalidateBounds();\r\n      }\r\n    },\r\n    \r\n    getTouchArea: function() {\r\n      return this._touchArea;\r\n    },\r\n    \r\n    updateLayerType: function() {\r\n      if ( this._renderer && this._rendererOptions ) {\r\n        // TODO: factor this check out! Make RendererOptions its own class?\r\n        // TODO: FIXME: support undoing this!\r\n        // ensure that if we are passing a CSS transform, we pass this node as the baseNode\r\n        if ( this._rendererOptions.cssTransform || this._rendererOptions.cssTranslation || this._rendererOptions.cssRotation || this._rendererOptions.cssScale ) {\r\n          this._rendererOptions.baseNode = this;\r\n        } else if ( this._rendererOptions.hasOwnProperty( 'baseNode' ) ) {\r\n          delete this._rendererOptions.baseNode; // don't override, let the scene pass in the scene\r\n        }\r\n        // if we set renderer and rendererOptions, only then do we want to trigger a specific layer type\r\n        this._rendererLayerType = this._renderer.createLayerType( this._rendererOptions );\r\n      } else {\r\n        this._rendererLayerType = null; // nothing signaled, since we want to support multiple layer types (including if we specify a renderer)\r\n      }\r\n    },\r\n    \r\n    getRendererLayerType: function() {\r\n      return this._rendererLayerType;\r\n    },\r\n    \r\n    hasRendererLayerType: function() {\r\n      return !!this._rendererLayerType;\r\n    },\r\n    \r\n    setRenderer: function( renderer ) {\r\n      var newRenderer;\r\n      if ( typeof renderer === 'string' ) {\r\n        sceneryAssert && sceneryAssert( scenery.Renderer[renderer], 'unknown renderer in setRenderer: ' + renderer );\r\n        newRenderer = scenery.Renderer[renderer];\r\n      } else if ( renderer instanceof scenery.Renderer ) {\r\n        newRenderer = renderer;\r\n      } else if ( !renderer ) {\r\n        newRenderer = null;\r\n      } else {\r\n        throw new Error( 'unrecognized type of renderer: ' + renderer );\r\n      }\r\n      if ( newRenderer !== this._renderer ) {\r\n        sceneryAssert && sceneryAssert( !this.isPainted() || !newRenderer || _.contains( this._supportedRenderers, newRenderer ), 'renderer ' + newRenderer + ' not supported by ' + this.constructor.name );\r\n        this._renderer = newRenderer;\r\n        \r\n        this.updateLayerType();\r\n        this.markLayerRefreshNeeded();\r\n      }\r\n    },\r\n    \r\n    getRenderer: function() {\r\n      return this._renderer;\r\n    },\r\n    \r\n    hasRenderer: function() {\r\n      return !!this._renderer;\r\n    },\r\n    \r\n    setRendererOptions: function( options ) {\r\n      // TODO: consider checking options based on the specified 'renderer'?\r\n      this._rendererOptions = options;\r\n      \r\n      this.updateLayerType();\r\n      this.markLayerRefreshNeeded();\r\n    },\r\n    \r\n    getRendererOptions: function() {\r\n      return this._rendererOptions;\r\n    },\r\n    \r\n    hasRendererOptions: function() {\r\n      return !!this._rendererOptions;\r\n    },\r\n    \r\n    setLayerSplitBefore: function( split ) {\r\n      sceneryAssert && sceneryAssert( typeof split === 'boolean' );\r\n      \r\n      if ( this._layerSplitBefore !== split ) {\r\n        this._layerSplitBefore = split;\r\n        this.markLayerRefreshNeeded();\r\n      }\r\n    },\r\n    \r\n    isLayerSplitBefore: function() {\r\n      return this._layerSplitBefore;\r\n    },\r\n    \r\n    setLayerSplitAfter: function( split ) {\r\n      sceneryAssert && sceneryAssert( typeof split === 'boolean' );\r\n      \r\n      if ( this._layerSplitAfter !== split ) {\r\n        this._layerSplitAfter = split;\r\n        this.markLayerRefreshNeeded();\r\n      }\r\n    },\r\n    \r\n    isLayerSplitAfter: function() {\r\n      return this._layerSplitAfter;\r\n    },\r\n    \r\n    setLayerSplit: function( split ) {\r\n      sceneryAssert && sceneryAssert( typeof split === 'boolean' );\r\n      \r\n      if ( split !== this._layerSplitBefore || split !== this._layerSplitAfter ) {\r\n        this._layerSplitBefore = split;\r\n        this._layerSplitAfter = split;\r\n        this.markLayerRefreshNeeded();\r\n      }\r\n    },\r\n    \r\n    // returns a unique trail (if it exists) where each node in the ancestor chain has 0 or 1 parents\r\n    getUniqueTrail: function() {\r\n      var trail = new scenery.Trail();\r\n      var node = this;\r\n      \r\n      while ( node ) {\r\n        trail.addAncestor( node );\r\n        sceneryAssert && sceneryAssert( node._parents.length <= 1 );\r\n        node = node._parents[0]; // should be undefined if there aren't any parents\r\n      }\r\n      \r\n      return trail;\r\n    },\r\n    \r\n    // all nodes in the connected component, returned in an arbitrary order\r\n    getConnectedNodes: function() {\r\n      var result = [];\r\n      var fresh = this._children.concat( this._parents ).concat( this );\r\n      while ( fresh.length ) {\r\n        var node = fresh.pop();\r\n        if ( !_.contains( result, node ) ) {\r\n          result.push( node );\r\n          fresh = fresh.concat( node._children, node._parents );\r\n        }\r\n      }\r\n      return result;\r\n    },\r\n    \r\n    getTopologicallySortedNodes: function() {\r\n      // see http://en.wikipedia.org/wiki/Topological_sorting\r\n      var edges = {};\r\n      var s = [];\r\n      var l = [];\r\n      var n;\r\n      _.each( this.getConnectedNodes(), function( node ) {\r\n        edges[node.id] = {};\r\n        _.each( node.children, function( m ) {\r\n          edges[node.id][m.id] = true;\r\n        } );\r\n        if ( !node.parents.length ) {\r\n          s.push( node );\r\n        }\r\n      } );\r\n      function handleChild( m ) {\r\n        delete edges[n.id][m.id];\r\n        if ( _.every( edges, function( children ) { return !children[m.id]; } ) ) {\r\n          // there are no more edges to m\r\n          s.push( m );\r\n        }\r\n      }\r\n      \r\n      while ( s.length ) {\r\n        n = s.pop();\r\n        l.push( n );\r\n        \r\n        _.each( n.children, handleChild );\r\n      }\r\n      \r\n      // ensure that there are no edges left, since then it would contain a circular reference\r\n      sceneryAssert && sceneryAssert( _.every( edges, function( children ) {\r\n        return _.every( children, function( final ) { return false; } );\r\n      } ), 'circular reference check' );\r\n      \r\n      return l;\r\n    },\r\n    \r\n    // verify that this.addChild( child ) it wouldn't cause circular references\r\n    canAddChild: function( child ) {\r\n      if ( this === child || _.contains( this.children, child ) ) {\r\n        return false;\r\n      }\r\n      \r\n      // see http://en.wikipedia.org/wiki/Topological_sorting\r\n      // TODO: remove duplication with above handling?\r\n      var edges = {};\r\n      var s = [];\r\n      var l = [];\r\n      var n;\r\n      _.each( this.getConnectedNodes().concat( child.getConnectedNodes() ), function( node ) {\r\n        edges[node.id] = {};\r\n        _.each( node.children, function( m ) {\r\n          edges[node.id][m.id] = true;\r\n        } );\r\n        if ( !node.parents.length && node !== child ) {\r\n          s.push( node );\r\n        }\r\n      } );\r\n      edges[this.id][child.id] = true; // add in our 'new' edge\r\n      function handleChild( m ) {\r\n        delete edges[n.id][m.id];\r\n        if ( _.every( edges, function( children ) { return !children[m.id]; } ) ) {\r\n          // there are no more edges to m\r\n          s.push( m );\r\n        }\r\n      }\r\n      \r\n      while ( s.length ) {\r\n        n = s.pop();\r\n        l.push( n );\r\n        \r\n        _.each( n.children, handleChild );\r\n        \r\n        // handle our new edge\r\n        if ( n === this ) {\r\n          handleChild( child );\r\n        }\r\n      }\r\n      \r\n      // ensure that there are no edges left, since then it would contain a circular reference\r\n      return _.every( edges, function( children ) {\r\n        return _.every( children, function( final ) { return false; } );\r\n      } );\r\n    },\r\n    \r\n    debugText: function() {\r\n      var startPointer = new scenery.TrailPointer( new scenery.Trail( this ), true );\r\n      var endPointer = new scenery.TrailPointer( new scenery.Trail( this ), false );\r\n      \r\n      var depth = 0;\r\n      \r\n      startPointer.depthFirstUntil( endPointer, function( pointer ) {\r\n        if ( pointer.isBefore ) {\r\n          // hackish way of multiplying a string\r\n          var padding = new Array( depth * 2 ).join( ' ' );\r\n          console.log( padding + pointer.trail.lastNode().getId() + ' ' + pointer.trail.toString() );\r\n        }\r\n        depth += pointer.isBefore ? 1 : -1;\r\n      }, false );\r\n    },\r\n    \r\n    /*\r\n     * Renders this node to a canvas. If toCanvas( callback ) is used, the canvas will contain the node's\r\n     * entire bounds.\r\n     *\r\n     * callback( canvas, x, y ) is called, where x and y offsets are computed if not specified.\r\n     */\r\n    toCanvas: function( callback, x, y, width, height ) {\r\n      var self = this;\r\n      \r\n      var padding = 2; // padding used if x and y are not set\r\n      \r\n      var bounds = this.getBounds();\r\n      x = x !== undefined ? x : Math.ceil( padding - bounds.minX );\r\n      y = y !== undefined ? y : Math.ceil( padding - bounds.minY );\r\n      width = width !== undefined ? width : Math.ceil( x + bounds.getWidth() + padding );\r\n      height = height !== undefined ? height : Math.ceil( y + bounds.getHeight() + padding );\r\n      \r\n      var canvas = document.createElement( 'canvas' );\r\n      canvas.width = width;\r\n      canvas.height = height;\r\n      var context = canvas.getContext( '2d' );\r\n      \r\n      var $div = $( document.createElement( 'div' ) );\r\n      $div.width( width ).height( height );\r\n      var scene = new scenery.Scene( $div );\r\n      \r\n      scene.addChild( self );\r\n      scene.x = x;\r\n      scene.y = y;\r\n      scene.updateScene();\r\n      \r\n      scene.renderToCanvas( canvas, context, function() {\r\n        callback( canvas, x, y );\r\n        \r\n        // let us be garbage collected\r\n        scene.removeChild( self );\r\n      } );\r\n    },\r\n    \r\n    // gives a data URI, with the same parameter handling as Node.toCanvas()\r\n    toDataURL: function( callback, x, y, width, height ) {\r\n      this.toCanvas( function( canvas, x, y ) {\r\n        // this x and y shadow the outside parameters, and will be different if the outside parameters are undefined\r\n        callback( canvas.toDataURL(), x, y );\r\n      }, x, y, width, height );\r\n    },\r\n    \r\n    // gives an HTMLImageElement with the same parameter handling as Node.toCanvas(). guaranteed to be asynchronous\r\n    toImage: function( callback, x, y, width, height ) {\r\n      this.toDataURL( function( url, x, y ) {\r\n        // this x and y shadow the outside parameters, and will be different if the outside parameters are undefined\r\n        var img = document.createElement( 'img' );\r\n        img.onload = function() {\r\n          callback( img, x, y );\r\n          try {\r\n            delete img.onload;\r\n          } catch ( e ) {} // fails on Safari 5.1\r\n        };\r\n        img.src = url;\r\n      }, x, y, width, height );\r\n    },\r\n    \r\n    // will call callback( node )\r\n    toImageNodeAsynchronous: function( callback, x, y, width, height ) {\r\n      this.toImage( function( image, x, y ) {\r\n        callback( new scenery.Node( { children: [\r\n          new scenery.Image( image, { x: -x, y: -y } )\r\n        ] } ) );\r\n      }, x, y, width, height );\r\n    },\r\n    \r\n    // fully synchronous, but returns a node that can only be rendered in Canvas\r\n    toCanvasNodeSynchronous: function( x, y, width, height ) {\r\n      var result;\r\n      this.toCanvas( function( canvas, x, y ) {\r\n        result = new scenery.Node( { children: [\r\n          new scenery.Image( canvas, { x: -x, y: -y } )\r\n        ] } );\r\n      }, x, y, width, height );\r\n      sceneryAssert && sceneryAssert( result, 'toCanvasNodeSynchronous requires that the node can be rendered only using Canvas' );\r\n      return result;\r\n    },\r\n    \r\n    // synchronous, but Image will not have the correct bounds immediately (that will be asynchronous)\r\n    toDataURLNodeSynchronous: function( x, y, width, height ) {\r\n      var result;\r\n      this.toDataURL( function( dataURL, x, y ) {\r\n        result = new scenery.Node( { children: [\r\n          new scenery.Image( dataURL, { x: -x, y: -y } )\r\n        ] } );\r\n      }, x, y, width, height );\r\n      sceneryAssert && sceneryAssert( result, 'toDataURLNodeSynchronous requires that the node can be rendered only using Canvas' );\r\n      return result;\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Instance handling\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    getInstances: function() {\r\n      return this._instances;\r\n    },\r\n    \r\n    addInstance: function( instance ) {\r\n      sceneryAssert && sceneryAssert( instance.getNode() === this, 'Must be an instance of this Node' );\r\n      sceneryAssert && sceneryAssert( !_.find( this._instances, function( other ) { return instance.equals( other ); } ), 'Cannot add duplicates of an instance to a Node' );\r\n      this._instances.push( instance );\r\n      if ( this._instances.length === 1 ) {\r\n        this.firstInstanceAdded();\r\n      }\r\n    },\r\n    \r\n    firstInstanceAdded: function() {\r\n      // no-op, meant to be overridden in the prototype chain\r\n    },\r\n    \r\n    // returns undefined if there is no instance.\r\n    getInstanceFromTrail: function( trail ) {\r\n      var result;\r\n      var len = this._instances.length;\r\n      if ( len === 1 ) {\r\n        // don't bother with checking the trail, but assertion should assure that it's what we're looking for\r\n        result = this._instances[0];\r\n      } else {\r\n        var i = len;\r\n        while ( i-- ) {\r\n          if ( this._instances[i].trail.equals( trail ) ) {\r\n            result = this._instances[i];\r\n            break;\r\n          }\r\n        }\r\n        // leave it as undefined if we don't find one\r\n      }\r\n      sceneryAssert && sceneryAssert( result, 'Could not find an instance for the trail ' + trail.toString() );\r\n      sceneryAssert && sceneryAssert( result.trail.equals( trail ), 'Instance has an incorrect Trail' );\r\n      return result;\r\n    },\r\n    \r\n    removeInstance: function( instance ) {\r\n      var index = _.indexOf( this._instances, instance ); // actual instance equality (NOT capitalized, normal meaning)\r\n      sceneryAssert && sceneryAssert( index !== -1, 'Cannot remove an Instance from a Node if it was not there' );\r\n      this._instances.splice( index, 1 );\r\n      if ( this._instances.length === 0 ) {\r\n        this.lastInstanceRemoved();\r\n      }\r\n    },\r\n    \r\n    lastInstanceRemoved: function() {\r\n      // no-op, meant to be overridden in the prototype chain\r\n    },\r\n    \r\n    notifyVisibilityChange: function() {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].notifyVisibilityChange();\r\n      }\r\n    },\r\n    \r\n    notifyOpacityChange: function() {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].notifyOpacityChange();\r\n      }\r\n    },\r\n    \r\n    notifyBeforeSelfChange: function() {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].notifyBeforeSelfChange();\r\n      }\r\n    },\r\n    \r\n    notifyBeforeSubtreeChange: function() {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].notifyBeforeSubtreeChange();\r\n      }\r\n    },\r\n    \r\n    notifyDirtySelfPaint: function() {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].notifyDirtySelfPaint();\r\n      }\r\n    },\r\n    \r\n    notifyDirtySubtreePaint: function() {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].notifyDirtySubtreePaint();\r\n      }\r\n    },\r\n    \r\n    notifyTransformChange: function() {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].notifyTransformChange();\r\n      }\r\n    },\r\n    \r\n    notifyBoundsAccuracyChange: function() {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].notifyBoundsAccuracyChange();\r\n      }\r\n    },\r\n    \r\n    notifyStitch: function( match ) {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].notifyStitch( match );\r\n      }\r\n    },\r\n    \r\n    markForLayerRefresh: function() {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].markForLayerRefresh();\r\n      }\r\n    },\r\n    \r\n    markForInsertion: function( child, index ) {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].markForInsertion( child, index );\r\n      }\r\n    },\r\n    \r\n    markForRemoval: function( child, index ) {\r\n      var i = this._instances.length;\r\n      while ( i-- ) {\r\n        this._instances[i].markForRemoval( child, index );\r\n      }\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Coordinate transform methods\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // apply this node's transform to the point\r\n    localToParentPoint: function( point ) {\r\n      return this._transform.transformPosition2( point );\r\n    },\r\n    \r\n    // apply this node's transform to the bounds\r\n    localToParentBounds: function( bounds ) {\r\n      return this._transform.transformBounds2( bounds );\r\n    },\r\n    \r\n    // apply the inverse of this node's transform to the point\r\n    parentToLocalPoint: function( point ) {\r\n      return this._transform.inversePosition2( point );\r\n    },\r\n    \r\n    // apply the inverse of this node's transform to the bounds\r\n    parentToLocalBounds: function( bounds ) {\r\n      return this._transform.inverseBounds2( bounds );\r\n    },\r\n    \r\n    // mutable optimized form of localToParentBounds\r\n    transformBoundsFromLocalToParent: function( bounds ) {\r\n      return bounds.transform( this._transform.getMatrix() );\r\n    },\r\n    \r\n    // returns the matrix (fresh copy) that transforms points from the local coordinate frame into the global coordinate frame\r\n    getLocalToGlobalMatrix: function() {\r\n      var node = this;\r\n      \r\n      // we need to apply the transformations in the reverse order, so we temporarily store them\r\n      var matrices = [];\r\n      \r\n      // concatenation like this has been faster than getting a unique trail, getting its transform, and applying it\r\n      while ( node ) {\r\n        matrices.push( node._transform.getMatrix() );\r\n        sceneryAssert && sceneryAssert( node._parents[1] === undefined, 'getLocalToGlobalMatrix unable to work for DAG' );\r\n        node = node._parents[0];\r\n      }\r\n      \r\n      var matrix = new Matrix3(); // will be modified in place\r\n      \r\n      // iterate from the back forwards (from the root node to here)\r\n      for ( var i = matrices.length - 1; i >=0; i-- ) {\r\n        matrix.multiplyMatrix( matrices[i] );\r\n      }\r\n      \r\n      // NOTE: always return a fresh copy, getGlobalToLocalMatrix depends on it to minimize instance usage!\r\n      return matrix;\r\n    },\r\n    \r\n    // equivalent to getUniqueTrail().getTransform(), but faster.\r\n    getUniqueTransform: function() {\r\n      return new Transform3( this.getLocalToGlobalMatrix() );\r\n    },\r\n    \r\n    // returns the matrix (fresh copy) that transforms points in the global coordinate frame into the local coordinate frame\r\n    getGlobalToLocalMatrix: function() {\r\n      return this.getLocalToGlobalMatrix().invert();\r\n    },\r\n    \r\n    // apply this node's transform (and then all of its parents' transforms) to the point\r\n    localToGlobalPoint: function( point ) {\r\n      var node = this;\r\n      var resultPoint = point.copy();\r\n      while ( node ) {\r\n        // in-place multiplication\r\n        node._transform.getMatrix().multiplyVector2( resultPoint );\r\n        sceneryAssert && sceneryAssert( node._parents[1] === undefined, 'localToGlobalPoint unable to work for DAG' );\r\n        node = node._parents[0];\r\n      }\r\n      return resultPoint;\r\n    },\r\n    \r\n    globalToLocalPoint: function( point ) {\r\n      var node = this;\r\n      // TODO: performance: test whether it is faster to get a total transform and then invert (won't compute individual inverses)\r\n      \r\n      // we need to apply the transformations in the reverse order, so we temporarily store them\r\n      var transforms = [];\r\n      while ( node ) {\r\n        transforms.push( node._transform );\r\n        sceneryAssert && sceneryAssert( node._parents[1] === undefined, 'globalToLocalPoint unable to work for DAG' );\r\n        node = node._parents[0];\r\n      }\r\n      \r\n      // iterate from the back forwards (from the root node to here)\r\n      var resultPoint = point.copy();\r\n      for ( var i = transforms.length - 1; i >=0; i-- ) {\r\n        // in-place multiplication\r\n        transforms[i].getInverse().multiplyVector2( resultPoint );\r\n      }\r\n      return resultPoint;\r\n    },\r\n    \r\n    // apply this node's transform (and then all of its parents' transforms) to the bounds\r\n    localToGlobalBounds: function( bounds ) {\r\n      // apply the bounds transform only once, so we can minimize the expansion encountered from multiple rotations\r\n      // it also seems to be a bit faster this way\r\n      return bounds.transformed( this.getLocalToGlobalMatrix() );\r\n    },\r\n    \r\n    globalToLocalBounds: function( bounds ) {\r\n      // apply the bounds transform only once, so we can minimize the expansion encountered from multiple rotations\r\n      return bounds.transformed( this.getGlobalToLocalMatrix() );\r\n    },\r\n    \r\n    // like localToGlobalPoint, but without applying this node's transform\r\n    parentToGlobalPoint: function( point ) {\r\n      sceneryAssert && sceneryAssert( this.parents.length <= 1, 'parentToGlobalPoint unable to work for DAG' );\r\n      return this.parents.length ? this.parents[0].localToGlobalPoint( point ) : point;\r\n    },\r\n    \r\n    // like localToGlobalBounds, but without applying this node's transform\r\n    parentToGlobalBounds: function( bounds ) {\r\n      sceneryAssert && sceneryAssert( this.parents.length <= 1, 'parentToGlobalBounds unable to work for DAG' );\r\n      return this.parents.length ? this.parents[0].localToGlobalBounds( bounds ) : bounds;\r\n    },\r\n    \r\n    globalToParentPoint: function( point ) {\r\n      sceneryAssert && sceneryAssert( this.parents.length <= 1, 'globalToParentPoint unable to work for DAG' );\r\n      return this.parents.length ? this.parents[0].globalToLocalPoint( point ) : point;\r\n    },\r\n    \r\n    globalToParentBounds: function( bounds ) {\r\n      sceneryAssert && sceneryAssert( this.parents.length <= 1, 'globalToParentBounds unable to work for DAG' );\r\n      return this.parents.length ? this.parents[0].globalToLocalBounds( bounds ) : bounds;\r\n    },\r\n    \r\n    // get the Bounds2 of this node in the global coordinate frame.  Does not work for DAG.\r\n    getGlobalBounds: function() {\r\n      sceneryAssert && sceneryAssert( this.parents.length <= 1, 'globalBounds unable to work for DAG' );\r\n      return this.parentToGlobalBounds( this.getBounds() );\r\n    },\r\n    \r\n    // get the Bounds2 of any other node by converting to the global coordinate frame.  Does not work for DAG.\r\n    boundsOf: function( node ) {\r\n      return this.globalToLocalBounds( node.getGlobalBounds() );\r\n    },\r\n    \r\n    // get the Bounds2 of this node in the coordinate frame of the parameter node. Does not work for DAG cases.\r\n    boundsTo: function( node ) {\r\n      return node.globalToLocalBounds( this.getGlobalBounds() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * ES5 get/set\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    set layerSplit( value ) { this.setLayerSplit( value ); },\r\n    get layerSplit() { throw new Error( 'You can\\'t get a layerSplit property, since it modifies two separate properties' ); },\r\n    \r\n    set layerSplitBefore( value ) { this.setLayerSplitBefore( value ); },\r\n    get layerSplitBefore() { return this.isLayerSplitBefore(); },\r\n    \r\n    set layerSplitAfter( value ) { this.setLayerSplitAfter( value ); },\r\n    get layerSplitAfter() { return this.isLayerSplitAfter(); },\r\n    \r\n    set renderer( value ) { this.setRenderer( value ); },\r\n    get renderer() { return this.getRenderer(); },\r\n    \r\n    set rendererOptions( value ) { this.setRendererOptions( value ); },\r\n    get rendererOptions() { return this.getRendererOptions(); },\r\n    \r\n    set cursor( value ) { this.setCursor( value ); },\r\n    get cursor() { return this.getCursor(); },\r\n    \r\n    set mouseArea( value ) { this.setMouseArea( value ); },\r\n    get mouseArea() { return this.getMouseArea(); },\r\n    \r\n    set touchArea( value ) { this.setTouchArea( value ); },\r\n    get touchArea() { return this.getTouchArea(); },\r\n    \r\n    set visible( value ) { this.setVisible( value ); },\r\n    get visible() { return this.isVisible(); },\r\n    \r\n    set opacity( value ) { this.setOpacity( value ); },\r\n    get opacity() { return this.getOpacity(); },\r\n    \r\n    set pickable( value ) { this.setPickable( value ); },\r\n    get pickable() { return this.isPickable(); },\r\n    \r\n    set transform( value ) { this.setTransform( value ); },\r\n    get transform() { return this.getTransform(); },\r\n    \r\n    set matrix( value ) { this.setMatrix( value ); },\r\n    get matrix() { return this.getMatrix(); },\r\n    \r\n    set translation( value ) { this.setTranslation( value ); },\r\n    get translation() { return this.getTranslation(); },\r\n    \r\n    set rotation( value ) { this.setRotation( value ); },\r\n    get rotation() { return this.getRotation(); },\r\n    \r\n    set x( value ) { this.setX( value ); },\r\n    get x() { return this.getX(); },\r\n    \r\n    set y( value ) { this.setY( value ); },\r\n    get y() { return this.getY(); },\r\n    \r\n    set left( value ) { this.setLeft( value ); },\r\n    get left() { return this.getLeft(); },\r\n    \r\n    set right( value ) { this.setRight( value ); },\r\n    get right() { return this.getRight(); },\r\n    \r\n    set top( value ) { this.setTop( value ); },\r\n    get top() { return this.getTop(); },\r\n    \r\n    set bottom( value ) { this.setBottom( value ); },\r\n    get bottom() { return this.getBottom(); },\r\n    \r\n    set center( value ) { this.setCenter( value ); },\r\n    get center() { return this.getCenter(); },\r\n    \r\n    set centerX( value ) { this.setCenterX( value ); },\r\n    get centerX() { return this.getCenterX(); },\r\n    \r\n    set centerY( value ) { this.setCenterY( value ); },\r\n    get centerY() { return this.getCenterY(); },\r\n    \r\n    set children( value ) { this.setChildren( value ); },\r\n    get children() { return this.getChildren(); },\r\n    \r\n    get parents() { return this.getParents(); },\r\n    \r\n    get width() { return this.getWidth(); },\r\n    get height() { return this.getHeight(); },\r\n    get bounds() { return this.getBounds(); },\r\n    get selfBounds() { return this.getSelfBounds(); },\r\n    get childBounds() { return this.getChildBounds(); },\r\n    get globalBounds() { return this.getGlobalBounds(); },\r\n    get visibleBounds() { return this.getVisibleBounds(); },\r\n    get id() { return this.getId(); },\r\n    get instances() { return this.getInstances(); },\r\n    \r\n    mutate: function( options ) {\r\n      var node = this;\r\n      \r\n      _.each( this._mutatorKeys, function( key ) {\r\n        if ( options[key] !== undefined ) {\r\n          var descriptor = Object.getOwnPropertyDescriptor( Node.prototype, key );\r\n          \r\n          // if the key refers to a function that is not ES5 writable, it will execute that function with the single argument\r\n          if ( descriptor && typeof descriptor.value === 'function' ) {\r\n            node[key]( options[key] );\r\n          } else {\r\n            node[key] = options[key];\r\n          }\r\n        }\r\n      } );\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    toString: function( spaces, includeChildren ) {\r\n      spaces = spaces || '';\r\n      var props = this.getPropString( spaces + '  ', includeChildren === undefined ? true : includeChildren );\r\n      return spaces + this.getBasicConstructor( props ? ( '\\n' + props + '\\n' + spaces ) : '' );\r\n    },\r\n    \r\n    getBasicConstructor: function( propLines ) {\r\n      return 'new scenery.Node( {' + propLines + '} )';\r\n    },\r\n    \r\n    getPropString: function( spaces, includeChildren ) {\r\n      var self = this;\r\n      \r\n      var result = '';\r\n      function addProp( key, value, nowrap ) {\r\n        if ( result ) {\r\n          result += ',\\n';\r\n        }\r\n        if ( !nowrap && typeof value === 'string' ) {\r\n          result += spaces + key + ': \\'' + value + '\\'';\r\n        } else {\r\n          result += spaces + key + ': ' + value;\r\n        }\r\n      }\r\n      \r\n      if ( this._children.length && includeChildren ) {\r\n        var childString = '';\r\n        _.each( this._children, function( child ) {\r\n          if ( childString ) {\r\n            childString += ',\\n';\r\n          }\r\n          childString += child.toString( spaces + '  ' );\r\n        } );\r\n        addProp( 'children', '[\\n' + childString + '\\n' + spaces + ']', true );\r\n      }\r\n      \r\n      // direct copy props\r\n      if ( this.cursor ) { addProp( 'cursor', this.cursor ); }\r\n      if ( !this.visible ) { addProp( 'visible', this.visible ); }\r\n      if ( !this.pickable ) { addProp( 'pickable', this.pickable ); }\r\n      if ( this.opacity !== 1 ) { addProp( 'opacity', this.opacity ); }\r\n      \r\n      if ( !this.transform.isIdentity() ) {\r\n        var m = this.transform.getMatrix();\r\n        addProp( 'matrix', 'new dot.Matrix3( ' + m.m00() + ', ' + m.m01() + ', ' + m.m02() + ', ' +\r\n                                                 m.m10() + ', ' + m.m11() + ', ' + m.m12() + ', ' +\r\n                                                 m.m20() + ', ' + m.m21() + ', ' + m.m22() + ' )', true );\r\n      }\r\n      \r\n      if ( this.renderer ) {\r\n        addProp( 'renderer', this.renderer.name );\r\n        if ( this.rendererOptions ) {\r\n          // addProp( 'rendererOptions', JSON.stringify( this.rendererOptions ), true );\r\n        }\r\n      }\r\n      \r\n      if ( this._layerSplitBefore ) {\r\n        addProp( 'layerSplitBefore', true );\r\n      }\r\n      \r\n      if ( this._layerSplitAfter ) {\r\n        addProp( 'layerSplitAfter', true );\r\n      }\r\n      \r\n      return result;\r\n    }\r\n  };\r\n  \r\n  /*\r\n   * This is an array of property (setter) names for Node.mutate(), which are also used when creating nodes with parameter objects.\r\n   *\r\n   * E.g. new scenery.Node( { x: 5, rotation: 20 } ) will create a Path, and apply setters in the order below (node.x = 5; node.rotation = 20)\r\n   *\r\n   * The order below is important! Don't change this without knowing the implications.\r\n   * NOTE: translation-based mutators come before rotation/scale, since typically we think of their operations occuring \"after\" the rotation / scaling\r\n   * NOTE: left/right/top/bottom/centerX/centerY are at the end, since they rely potentially on rotation / scaling changes of bounds that may happen beforehand\r\n   * TODO: using more than one of {translation,x,left,right,centerX} or {translation,y,top,bottom,centerY} should be considered an error\r\n   * TODO: move fill / stroke setting to mixins\r\n   */\r\n  Node.prototype._mutatorKeys = [ 'children', 'cursor', 'visible', 'pickable', 'opacity', 'matrix', 'translation', 'x', 'y', 'rotation', 'scale',\r\n                                  'left', 'right', 'top', 'bottom', 'center', 'centerX', 'centerY', 'renderer', 'rendererOptions',\r\n                                  'layerSplit', 'layerSplitBefore', 'layerSplitAfter', 'mouseArea', 'touchArea' ];\r\n  \r\n  Node.prototype._supportedRenderers = [];\r\n  \r\n  Node.prototype.layerStrategy = LayerStrategy;\r\n  \r\n  // mix-in the events for Node\r\n  /* jshint -W064 */\r\n  NodeEvents( Node );\r\n  \r\n  return Node;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * A description of layer settings and the ability to create a layer with those settings.\r\n * Used internally for the layer building process.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/layers/LayerType',['require','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  scenery.LayerType = function LayerType( Constructor, name, renderer, args ) {\r\n    this.Constructor = Constructor;\r\n    this.name = name;\r\n    this.renderer = renderer;\r\n    this.args = args;\r\n  };\r\n  var LayerType = scenery.LayerType;\r\n  \r\n  LayerType.prototype = {\r\n    constructor: LayerType,\r\n    \r\n    supportsRenderer: function( renderer ) {\r\n      return this.renderer === renderer;\r\n    },\r\n    \r\n    supportsNode: function( node ) {\r\n      var supportedRenderers = node._supportedRenderers;\r\n      var i = supportedRenderers.length;\r\n      while ( i-- ) {\r\n        if ( this.supportsRenderer( supportedRenderers[i] ) ) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    },\r\n    \r\n    createLayer: function( args ) {\r\n      var Constructor = this.Constructor;\r\n      return new Constructor( _.extend( {}, args, this.args ) ); // allow overriding certain arguments if necessary by the LayerType\r\n    }\r\n  };\r\n  \r\n  return LayerType;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Represents a trail (path in the graph) from a 'root' node down to a descendant node.\r\n * In a DAG, or with different views, there can be more than one trail up from a node,\r\n * even to the same root node!\r\n *\r\n * It has an array of nodes, in order from the 'root' down to the last node,\r\n * a length, and an array of indices such that node_i.children[index_i] === node_{i+1}.\r\n *\r\n * The indices can sometimes become stale when nodes are added and removed, so Trails\r\n * can have their indices updated with reindex(). It's designed to be as fast as possible\r\n * on Trails that are already indexed accurately.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/Trail',['require','DOT/Matrix3','DOT/Transform3','SCENERY/scenery','SCENERY/nodes/Node'],function( require ) {\r\n  'use strict';\r\n  \r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  require( 'SCENERY/nodes/Node' );\r\n  // require( 'SCENERY/util/TrailPointer' );\r\n  \r\n  scenery.Trail = function Trail( nodes ) {\r\n    /*\r\n     * Controls the immutability of the trail.\r\n     * If set to true, add/remove descendant/ancestor should fail if assertions are enabled\r\n     * Use setImmutable() or setMutable() to signal a specific type of protection, so it cannot be changed later\r\n     */\r\n    if ( sceneryAssert ) {\r\n      // only do this if assertions are enabled, otherwise we won't access it at all\r\n      this.immutable = undefined;\r\n    }\r\n    \r\n    if ( nodes instanceof Trail ) {\r\n      // copy constructor (takes advantage of already built index information)\r\n      var otherTrail = nodes;\r\n      \r\n      this.nodes = otherTrail.nodes.slice( 0 );\r\n      this.length = otherTrail.length;\r\n      this.uniqueId = otherTrail.uniqueId;\r\n      this.indices = otherTrail.indices.slice( 0 );\r\n      return;\r\n    }\r\n    \r\n    this.nodes = [];\r\n    this.length = 0;\r\n    this.uniqueId = '';\r\n    \r\n    // indices[x] stores the index of nodes[x] in nodes[x-1]'s children\r\n    this.indices = [];\r\n    \r\n    var trail = this;\r\n    if ( nodes ) {\r\n      if ( nodes instanceof scenery.Node ) {\r\n        var node = nodes;\r\n        \r\n        // add just a single node in\r\n        trail.addDescendant( node );\r\n      } else {\r\n        // process it as an array\r\n        var len = nodes.length;\r\n        for ( var i = 0; i < len; i++ ) {\r\n          trail.addDescendant( nodes[i] );\r\n        }\r\n      }\r\n    }\r\n  };\r\n  var Trail = scenery.Trail;\r\n  \r\n  Trail.prototype = {\r\n    constructor: Trail,\r\n    \r\n    copy: function() {\r\n      return new Trail( this );\r\n    },\r\n    \r\n    // convenience function to determine whether this trail will render something\r\n    isPainted: function() {\r\n      return this.lastNode().isPainted();\r\n    },\r\n    \r\n    // this trail is visible only if all nodes on it are marked as visible\r\n    isVisible: function() {\r\n      var i = this.nodes.length;\r\n      while ( i-- ) {\r\n        if ( !this.nodes[i].isVisible() ) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n    \r\n    getOpacity: function() {\r\n      var opacity = 1;\r\n      var i = this.nodes.length;\r\n      while ( i-- ) {\r\n        opacity *= this.nodes[i].getOpacity();\r\n      }\r\n      return opacity;\r\n    },\r\n    \r\n    get: function( index ) {\r\n      if ( index >= 0 ) {\r\n        return this.nodes[index];\r\n      } else {\r\n        // negative index goes from the end of the array\r\n        return this.nodes[this.nodes.length + index];\r\n      }\r\n    },\r\n    \r\n    slice: function( startIndex, endIndex ) {\r\n      return new Trail( this.nodes.slice( startIndex, endIndex ) );\r\n    },\r\n    \r\n    subtrailTo: function( node, excludeNode ) {\r\n      return this.slice( 0, _.indexOf( this.nodes, node ) + ( excludeNode ? 0 : 1 ) );\r\n    },\r\n    \r\n    isEmpty: function() {\r\n      return this.nodes.length === 0;\r\n    },\r\n    \r\n    getInstance: function() {\r\n      return this.lastNode().getInstanceFromTrail( this );\r\n    },\r\n    \r\n    // from local to global\r\n    getMatrix: function() {\r\n      // TODO: performance: can we cache this ever? would need the scene to not really change in between\r\n      // this matrix will be modified in place, so always start fresh\r\n      var matrix = new Matrix3();\r\n      \r\n      // from the root up\r\n      var nodes = this.nodes;\r\n      var length = nodes.length;\r\n      for ( var i = 0; i < length; i++ ) {\r\n        matrix.multiplyMatrix( nodes[i]._transform.getMatrix() );\r\n      }\r\n      return matrix;\r\n    },\r\n    \r\n    // from parent to global\r\n    getParentMatrix: function() {\r\n      // this matrix will be modified in place, so always start fresh\r\n      var matrix = new Matrix3();\r\n      \r\n      // from the root up\r\n      var nodes = this.nodes;\r\n      var length = nodes.length;\r\n      for ( var i = 0; i < length - 1; i++ ) {\r\n        matrix.multiplyMatrix( nodes[i]._transform.getMatrix() );\r\n      }\r\n      return matrix;\r\n    },\r\n    \r\n    // from local to global\r\n    getTransform: function() {\r\n      return new Transform3( this.getMatrix() );\r\n    },\r\n    \r\n    // from parent to global\r\n    getParentTransform: function() {\r\n      return new Transform3( this.getParentMatrix() );\r\n    },\r\n    \r\n    addAncestor: function( node, index ) {\r\n      sceneryAssert && sceneryAssert( !this.immutable, 'cannot modify an immutable Trail with addAncestor' );\r\n      sceneryAssert && sceneryAssert( node, 'cannot add falsy value to a Trail' );\r\n      \r\n      \r\n      if ( this.nodes.length ) {\r\n        var oldRoot = this.nodes[0];\r\n        this.indices.unshift( index === undefined ? _.indexOf( node._children, oldRoot ) : index );\r\n      }\r\n      this.nodes.unshift( node );\r\n      \r\n      this.length++;\r\n      // accelerated version of this.updateUniqueId()\r\n      this.uniqueId = ( this.uniqueId ? node._id + '-' + this.uniqueId : node._id + '' );\r\n      return this;\r\n    },\r\n    \r\n    removeAncestor: function() {\r\n      sceneryAssert && sceneryAssert( !this.immutable, 'cannot modify an immutable Trail with removeAncestor' );\r\n      sceneryAssert && sceneryAssert( this.length > 0, 'cannot remove a Node from an empty trail' );\r\n      \r\n      this.nodes.shift();\r\n      if ( this.indices.length ) {\r\n        this.indices.shift();\r\n      }\r\n      \r\n      this.length--;\r\n      this.updateUniqueId();\r\n      return this;\r\n    },\r\n    \r\n    addDescendant: function( node, index ) {\r\n      sceneryAssert && sceneryAssert( !this.immutable, 'cannot modify an immutable Trail with addDescendant' );\r\n      sceneryAssert && sceneryAssert( node, 'cannot add falsy value to a Trail' );\r\n      \r\n      \r\n      if ( this.nodes.length ) {\r\n        var parent = this.lastNode();\r\n        this.indices.push( index === undefined ? _.indexOf( parent._children, node ) : index );\r\n      }\r\n      this.nodes.push( node );\r\n      \r\n      this.length++;\r\n      // accelerated version of this.updateUniqueId()\r\n      this.uniqueId = ( this.uniqueId ? this.uniqueId + '-' + node._id : node._id + '' );\r\n      return this;\r\n    },\r\n    \r\n    removeDescendant: function() {\r\n      sceneryAssert && sceneryAssert( !this.immutable, 'cannot modify an immutable Trail with removeDescendant' );\r\n      sceneryAssert && sceneryAssert( this.length > 0, 'cannot remove a Node from an empty trail' );\r\n      \r\n      this.nodes.pop();\r\n      if ( this.indices.length ) {\r\n        this.indices.pop();\r\n      }\r\n      \r\n      this.length--;\r\n      this.updateUniqueId();\r\n      return this;\r\n    },\r\n    \r\n    // refreshes the internal index references (important if any children arrays were modified!)\r\n    reindex: function() {\r\n      var length = this.length;\r\n      for ( var i = 1; i < length; i++ ) {\r\n        // only replace indices where they have changed (this was a performance hotspot)\r\n        var currentIndex = this.indices[i-1];\r\n        var baseNode = this.nodes[i-1];\r\n        \r\n        if ( baseNode._children[currentIndex] !== this.nodes[i] ) {\r\n          this.indices[i-1] = _.indexOf( baseNode._children, this.nodes[i] );\r\n        }\r\n      }\r\n    },\r\n    \r\n    setImmutable: function() {\r\n      // if assertions are disabled, we hope this is inlined as a no-op\r\n      if ( sceneryAssert ) {\r\n        sceneryAssert( this.immutable !== false, 'A trail cannot be made immutable after being flagged as mutable' );\r\n        this.immutable = true;\r\n      }\r\n      \r\n      // TODO: consider setting mutators to null here instead of the function call check (for performance, and profile the differences)\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    setMutable: function() {\r\n      // if assertions are disabled, we hope this is inlined as a no-op\r\n      if ( sceneryAssert ) {\r\n        sceneryAssert( this.immutable !== true, 'A trail cannot be made mutable after being flagged as immutable' );\r\n        this.immutable = false;\r\n      }\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    areIndicesValid: function() {\r\n      for ( var i = 1; i < this.length; i++ ) {\r\n        var currentIndex = this.indices[i-1];\r\n        if ( this.nodes[i-1]._children[currentIndex] !== this.nodes[i] ) {\r\n          return false;\r\n        }\r\n      }\r\n      return true;\r\n    },\r\n    \r\n    equals: function( other ) {\r\n      if ( this.length !== other.length ) {\r\n        return false;\r\n      }\r\n      \r\n      for ( var i = 0; i < this.nodes.length; i++ ) {\r\n        if ( this.nodes[i] !== other.nodes[i] ) {\r\n          return false;\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    },\r\n    \r\n    // returns a new Trail from the root up to the parameter node.\r\n    upToNode: function( node ) {\r\n      var nodeIndex = _.indexOf( this.nodes, node );\r\n      sceneryAssert && sceneryAssert( nodeIndex >= 0, 'Trail does not contain the node' );\r\n      return this.slice( 0, _.indexOf( this.nodes, node ) + 1 );\r\n    },\r\n    \r\n    // whether this trail contains the complete 'other' trail, but with added descendants afterwards\r\n    isExtensionOf: function( other, allowSameTrail ) {\r\n      sceneryAssertExtra && sceneryAssertExtra( this.areIndicesValid(), 'Trail.compare this.areIndicesValid() failed' );\r\n      sceneryAssertExtra && sceneryAssertExtra( other.areIndicesValid(), 'Trail.compare other.areIndicesValid() failed' );\r\n      \r\n      if ( this.length <= other.length - ( allowSameTrail ? 1 : 0 ) ) {\r\n        return false;\r\n      }\r\n      \r\n      for ( var i = 0; i < other.nodes.length; i++ ) {\r\n        if ( this.nodes[i] !== other.nodes[i] ) {\r\n          return false;\r\n        }\r\n      }\r\n      \r\n      return true;\r\n    },\r\n    \r\n    // TODO: phase out in favor of get()\r\n    nodeFromTop: function( offset ) {\r\n      return this.nodes[this.length - 1 - offset];\r\n    },\r\n    \r\n    lastNode: function() {\r\n      return this.nodeFromTop( 0 );\r\n    },\r\n    \r\n    rootNode: function() {\r\n      return this.nodes[0];\r\n    },\r\n    \r\n    // returns the previous graph trail in the order of self-rendering\r\n    previous: function() {\r\n      if ( this.nodes.length <= 1 ) {\r\n        return null;\r\n      }\r\n      \r\n      var top = this.nodeFromTop( 0 );\r\n      var parent = this.nodeFromTop( 1 );\r\n      \r\n      var parentIndex = _.indexOf( parent._children, top );\r\n      sceneryAssert && sceneryAssert( parentIndex !== -1 );\r\n      var arr = this.nodes.slice( 0, this.nodes.length - 1 );\r\n      if ( parentIndex === 0 ) {\r\n        // we were the first child, so give it the trail to the parent\r\n        return new Trail( arr );\r\n      } else {\r\n        // previous child\r\n        arr.push( parent._children[parentIndex-1] );\r\n        \r\n        // and find its last terminal\r\n        while( arr[arr.length-1]._children.length !== 0 ) {\r\n          var last = arr[arr.length-1];\r\n          arr.push( last._children[last._children.length-1] );\r\n        }\r\n        \r\n        return new Trail( arr );\r\n      }\r\n    },\r\n    \r\n    // like previous(), but keeps moving back until the trail goes to a node with isPainted() === true\r\n    previousPainted: function() {\r\n      var result = this.previous();\r\n      while ( result && !result.isPainted() ) {\r\n        result = result.previous();\r\n      }\r\n      return result;\r\n    },\r\n    \r\n    // in the order of self-rendering\r\n    next: function() {\r\n      var arr = this.nodes.slice( 0 );\r\n      \r\n      var top = this.nodeFromTop( 0 );\r\n      if ( top._children.length > 0 ) {\r\n        // if we have children, return the first child\r\n        arr.push( top._children[0] );\r\n        return new Trail( arr );\r\n      } else {\r\n        // walk down and attempt to find the next parent\r\n        var depth = this.nodes.length - 1;\r\n        \r\n        while ( depth > 0 ) {\r\n          var node = this.nodes[depth];\r\n          var parent = this.nodes[depth-1];\r\n          \r\n          arr.pop(); // take off the node so we can add the next sibling if it exists\r\n          \r\n          var index = _.indexOf( parent._children, node );\r\n          if ( index !== parent._children.length - 1 ) {\r\n            // there is another (later) sibling. use that!\r\n            arr.push( parent._children[index+1] );\r\n            return new Trail( arr );\r\n          } else {\r\n            depth--;\r\n          }\r\n        }\r\n        \r\n        // if we didn't reach a later sibling by now, it doesn't exist\r\n        return null;\r\n      }\r\n    },\r\n    \r\n    // like next(), but keeps moving back until the trail goes to a node with isPainted() === true\r\n    nextPainted: function() {\r\n      var result = this.next();\r\n      while ( result && !result.isPainted() ) {\r\n        result = result.next();\r\n      }\r\n      return result;\r\n    },\r\n    \r\n    // calls callback( trail ) for this trail, and each descendant trail\r\n    eachTrailUnder: function( callback ) {\r\n      // TODO: performance: should be optimized to be much faster, since we don't have to deal with the before/after\r\n      new scenery.TrailPointer( this, true ).eachTrailBetween( new scenery.TrailPointer( this, false ), callback );\r\n    },\r\n    \r\n    /*\r\n     * Standard Java-style compare. -1 means this trail is before (under) the other trail, 0 means equal, and 1 means this trail is\r\n     * after (on top of) the other trail.\r\n     * A shorter subtrail will compare as -1.\r\n     *\r\n     * Assumes that the Trails are properly indexed. If not, please reindex them!\r\n     *\r\n     * Comparison is for the rendering order, so an ancestor is 'before' a descendant\r\n     */\r\n    compare: function( other ) {\r\n      sceneryAssert && sceneryAssert( !this.isEmpty(), 'cannot compare with an empty trail' );\r\n      sceneryAssert && sceneryAssert( !other.isEmpty(), 'cannot compare with an empty trail' );\r\n      sceneryAssert && sceneryAssert( this.nodes[0] === other.nodes[0], 'for Trail comparison, trails must have the same root node' );\r\n      sceneryAssertExtra && sceneryAssertExtra( this.areIndicesValid(), 'Trail.compare this.areIndicesValid() failed on ' + this.toString() );\r\n      sceneryAssertExtra && sceneryAssertExtra( other.areIndicesValid(), 'Trail.compare other.areIndicesValid() failed on ' + other.toString() );\r\n      \r\n      var minNodeIndex = Math.min( this.indices.length, other.indices.length );\r\n      for ( var i = 0; i < minNodeIndex; i++ ) {\r\n        if ( this.indices[i] !== other.indices[i] ) {\r\n          if ( this.indices[i] < other.indices[i] ) {\r\n            return -1;\r\n          } else {\r\n            return 1;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // we scanned through and no nodes were different (one is a subtrail of the other)\r\n      if ( this.nodes.length < other.nodes.length ) {\r\n        return -1;\r\n      } else if ( this.nodes.length > other.nodes.length ) {\r\n        return 1;\r\n      } else {\r\n        return 0;\r\n      }\r\n    },\r\n    \r\n    isBefore: function( other ) {\r\n      return this.compare( other ) === -1;\r\n    },\r\n    \r\n    isAfter: function( other ) {\r\n      return this.compare( other ) === 1;\r\n    },\r\n    \r\n    localToGlobalPoint: function( point ) {\r\n      // TODO: performance: multiple timesVector2 calls up the chain is probably faster\r\n      return this.getMatrix().timesVector2( point );\r\n    },\r\n    \r\n    localToGlobalBounds: function( bounds ) {\r\n      return bounds.transformed( this.getMatrix() );\r\n    },\r\n    \r\n    globalToLocalPoint: function( point ) {\r\n      return this.getTransform().inversePosition2( point );\r\n    },\r\n    \r\n    globalToLocalBounds: function( bounds ) {\r\n      return this.getTransform().inverseBounds2( bounds );\r\n    },\r\n    \r\n    parentToGlobalPoint: function( point ) {\r\n      // TODO: performance: multiple timesVector2 calls up the chain is probably faster\r\n      return this.getParentMatrix().timesVector2( point );\r\n    },\r\n    \r\n    parentToGlobalBounds: function( bounds ) {\r\n      return bounds.transformed( this.getParentMatrix() );\r\n    },\r\n    \r\n    globalToParentPoint: function( point ) {\r\n      return this.getParentTransform().inversePosition2( point );\r\n    },\r\n    \r\n    globalToParentBounds: function( bounds ) {\r\n      return this.getParentTransform().inverseBounds2( bounds );\r\n    },\r\n    \r\n    updateUniqueId: function() {\r\n      // string concatenation is faster, see http://jsperf.com/string-concat-vs-joins\r\n      var result = '';\r\n      var len = this.nodes.length;\r\n      if ( len > 0 ) {\r\n        result += this.nodes[0]._id;\r\n      }\r\n      for ( var i = 1; i < len; i++ ) {\r\n        result += '-' + this.nodes[i]._id;\r\n      }\r\n      this.uniqueId = result;\r\n      // this.uniqueId = _.map( this.nodes, function( node ) { return node.getId(); } ).join( '-' );\r\n    },\r\n    \r\n    // concatenates the unique IDs of nodes in the trail, so that we can do id-based lookups\r\n    getUniqueId: function() {\r\n      // sanity checks\r\n      if ( sceneryAssert ) {\r\n        var oldUniqueId = this.uniqueId;\r\n        this.updateUniqueId();\r\n        sceneryAssert( oldUniqueId === this.uniqueId );\r\n      }\r\n      return this.uniqueId;\r\n    },\r\n    \r\n    toString: function() {\r\n      this.reindex();\r\n      if ( !this.length ) {\r\n        return 'Empty Trail';\r\n      }\r\n      return '[Trail ' + this.indices.join( '.' ) + ' ' + this.getUniqueId() + ']';\r\n    }\r\n  };\r\n  \r\n  // like eachTrailBetween, but only fires for painted trails\r\n  Trail.eachPaintedTrailBetween = function( a, b, callback, excludeEndTrails, scene ) {\r\n    Trail.eachTrailBetween( a, b, function( trail ) {\r\n      if ( trail && trail.isPainted() ) {\r\n        callback( trail );\r\n      }\r\n    }, excludeEndTrails, scene );\r\n  };\r\n  \r\n  // global way of iterating across trails\r\n  Trail.eachTrailBetween = function( a, b, callback, excludeEndTrails, scene ) {\r\n    var aPointer = a ? new scenery.TrailPointer( a.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( scene ), true );\r\n    var bPointer = b ? new scenery.TrailPointer( b.copy(), true ) : new scenery.TrailPointer( new scenery.Trail( scene ), false );\r\n    \r\n    // if we are excluding endpoints, just bump the pointers towards each other by one step\r\n    if ( excludeEndTrails ) {\r\n      aPointer.nestedForwards();\r\n      bPointer.nestedBackwards();\r\n      \r\n      // they were adjacent, so no callbacks will be executed\r\n      if ( aPointer.compareNested( bPointer ) === 1 ) {\r\n        return;\r\n      }\r\n    }\r\n    \r\n    aPointer.depthFirstUntil( bPointer, function( pointer ) {\r\n      if ( pointer.isBefore ) {\r\n        callback( pointer.trail );\r\n      }\r\n    }, false );\r\n  };\r\n  \r\n  return Trail;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Base code for layers that helps with shared layer functions\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/layers/Layer',['require','DOT/Bounds2','DOT/Transform3','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {\r\n  'use strict';\r\n  \r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  require( 'SCENERY/util/Trail' );\r\n  \r\n  var globalIdCounter = 1;\r\n  \r\n  /*\r\n   * Required arguments:\r\n   * $main     - the jQuery-wrapped container for the scene\r\n   * scene     - the scene itself\r\n   * baseNode  - the base node for this layer\r\n   */\r\n  scenery.Layer = function Layer( args ) {\r\n    \r\n    // assign a unique ID to this layer\r\n    this._id = globalIdCounter++;\r\n    \r\n    this.$main = args.$main;\r\n    this.scene = args.scene;\r\n    this.baseNode = args.baseNode;\r\n    \r\n    // TODO: cleanup of flags!\r\n    this.usesPartialCSSTransforms = args.cssTranslation || args.cssRotation || args.cssScale;\r\n    this.cssTranslation = args.cssTranslation; // CSS for the translation\r\n    this.cssRotation = args.cssRotation;       // CSS for the rotation\r\n    this.cssScale = args.cssScale;             // CSS for the scaling\r\n    this.cssTransform = args.cssTransform;     // CSS for the entire base node (will ignore other partial transforms)\r\n    sceneryAssert && sceneryAssert( !( this.usesPartialCSSTransforms && this.cssTransform ), 'Do not specify both partial and complete CSS transform arguments.' );\r\n    \r\n    // initialize to fully dirty so we draw everything the first time\r\n    // bounds in global coordinate frame\r\n    this.dirtyBounds = Bounds2.EVERYTHING;\r\n    \r\n    this.setStartBoundary( args.startBoundary );\r\n    this.setEndBoundary( args.endBoundary );\r\n    \r\n    // set baseTrail from the scene to our baseNode\r\n    if ( this.baseNode === this.scene ) {\r\n      this.baseTrail = new scenery.Trail( this.scene );\r\n    } else {\r\n      this.baseTrail = this.startPaintedTrail.upToNode( this.baseNode );\r\n      sceneryAssert && sceneryAssert( this.baseTrail.lastNode() === this.baseNode );\r\n    }\r\n    \r\n    // we reference all painted trails in an unordered way\r\n    this._layerTrails = []; // TODO: performance: remove layerTrails if possible!\r\n    this._instanceCount = 0; // track how many instances we are tracking (updated in stitching by instances)\r\n    \r\n    var layer = this;\r\n    \r\n    // whenever the base node's children or self change bounds, signal this. we want to explicitly ignore the base node's main bounds for\r\n    // CSS transforms, since the self / children bounds may not have changed\r\n    this.baseNodeBoundsListener = function( bounds ) {\r\n      layer.baseNodeInternalBoundsChange(); // TODO: verify that this is working as expected\r\n    };\r\n    this.baseNode.addEventListener( 'selfBounds', this.baseNodeBoundsListener );\r\n    this.baseNode.addEventListener( 'childBounds', this.baseNodeBoundsListener );\r\n    \r\n    this.fitToBounds = this.usesPartialCSSTransforms || this.cssTransform;\r\n    sceneryAssert && sceneryAssert( this.fitToBounds || this.baseNode === this.scene, 'If the baseNode is not the scene, we need to fit the bounds' );\r\n    \r\n    // used for CSS transforms where we need to transform our base node's bounds into the (0,0,w,h) bounds range\r\n    this.baseNodeTransform = new Transform3();\r\n    //this.baseNodeInteralBounds = Bounds2.NOTHING; // stores the bounds transformed into (0,0,w,h)\r\n    \r\n    this.disposed = false; // track whether we have been disposed or not\r\n  };\r\n  var Layer = scenery.Layer;\r\n  \r\n  Layer.prototype = {\r\n    constructor: Layer,\r\n    \r\n    setStartBoundary: function( boundary ) {\r\n      // console.log( 'setting start boundary on layer ' + this.getId() + ': ' + boundary.toString() );\r\n      this.startBoundary = boundary;\r\n      \r\n      // TODO: deprecate these, use boundary references instead? or boundary convenience functions\r\n      this.startPaintedTrail = this.startBoundary.nextPaintedTrail;\r\n      \r\n      // set immutability guarantees\r\n      this.startPaintedTrail.setImmutable();\r\n    },\r\n    \r\n    setEndBoundary: function( boundary ) {\r\n      // console.log( 'setting end boundary on layer ' + this.getId() + ': ' + boundary.toString() );\r\n      this.endBoundary = boundary;\r\n      \r\n      // TODO: deprecate these, use boundary references instead? or boundary convenience functions\r\n      this.endPaintedTrail = this.endBoundary.previousPaintedTrail;\r\n      \r\n      // set immutability guarantees\r\n      this.endPaintedTrail.setImmutable();\r\n    },\r\n    \r\n    toString: function() {\r\n      return this.getName() + ' ' + ( this.startPaintedTrail ? this.startPaintedTrail.toString() : '!' ) + ' => ' + ( this.endPaintedTrail ? this.endPaintedTrail.toString() : '!' );\r\n    },\r\n    \r\n    getId: function() {\r\n      return this._id;\r\n    },\r\n    get id() { return this._id; }, // ES5 version\r\n    \r\n    // painted trails associated with the layer, NOT necessarily in order\r\n    getLayerTrails: function() {\r\n      return this._layerTrails.slice( 0 );\r\n    },\r\n    \r\n    getPaintedTrailCount: function() {\r\n      return this._layerTrails.length;\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Abstract\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    render: function( state ) {\r\n      throw new Error( 'Layer.render unimplemented' );\r\n    },\r\n    \r\n    // TODO: consider a stack-based model for transforms?\r\n    // TODO: is this necessary? verify with the render state\r\n    applyTransformationMatrix: function( matrix ) {\r\n      throw new Error( 'Layer.applyTransformationMatrix unimplemented' );\r\n    },\r\n    \r\n    // adds a trail (with the last node) to the layer\r\n    addInstance: function( instance ) {\r\n      var trail = instance.trail;\r\n      \r\n      if ( sceneryAssert ) {\r\n        _.each( this._layerTrails, function( otherTrail ) {\r\n          sceneryAssert( !trail.equals( otherTrail ), 'trail in addInstance should not already exist in a layer' );\r\n        } );\r\n      }\r\n      \r\n      // TODO: sync this with DOMLayer's implementation\r\n      this._layerTrails.push( trail );\r\n      trail.setImmutable(); // don't allow this Trail to be changed\r\n    },\r\n    \r\n    // removes a trail (with the last node) to the layer\r\n    removeInstance: function( instance ) {\r\n      // TODO: sync this with DOMLayer's implementation\r\n      var i;\r\n      for ( i = 0; i < this._layerTrails.length; i++ ) {\r\n        this._layerTrails[i].reindex();\r\n        if ( this._layerTrails[i].compare( instance.trail ) === 0 ) {\r\n          break;\r\n        }\r\n      }\r\n      sceneryAssert && sceneryAssert( i < this._layerTrails.length );\r\n      \r\n      this._layerTrails.splice( i, 1 );\r\n    },\r\n    \r\n    // returns next zIndex in place. allows layers to take up more than one single zIndex\r\n    reindex: function( zIndex ) {\r\n      this.startBoundary.reindex();\r\n      this.endBoundary.reindex();\r\n    },\r\n    \r\n    pushClipShape: function( shape ) {\r\n      throw new Error( 'Layer.pushClipShape unimplemented' );\r\n    },\r\n    \r\n    popClipShape: function() {\r\n      throw new Error( 'Layer.popClipShape unimplemented' );\r\n    },\r\n    \r\n    renderToCanvas: function( canvas, context, delayCounts ) {\r\n      throw new Error( 'Layer.renderToCanvas unimplemented' );\r\n    },\r\n    \r\n    dispose: function() {\r\n      sceneryAssert && sceneryAssert( !this.disposed, 'Layer has already been disposed!' );\r\n      \r\n      this.disposed = true;\r\n      \r\n      // clean up listeners\r\n      this.baseNode.removeEventListener( 'selfBounds', this.baseNodeBoundsListener );\r\n      this.baseNode.removeEventListener( 'childBounds', this.baseNodeBoundsListener );\r\n    },\r\n    \r\n    getName: function() {\r\n      throw new Error( 'Layer.getName unimplemented' );\r\n    },\r\n    \r\n    // called when the base node's \"internal\" (self or child) bounds change, but not when it is just from the base node's own transform changing\r\n    baseNodeInternalBoundsChange: function() {\r\n      // no error, many times this doesn't need to be handled\r\n    }\r\n    \r\n  };\r\n  \r\n  Layer.cssTransformPadding = 3;\r\n  \r\n  return Layer;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Wraps the context and contains a reference to the canvas, so that we can absorb unnecessary state changes,\r\n * and possibly combine certain fill operations.\r\n *\r\n * TODO: performance analysis, possibly axe this and use direct modification.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/CanvasContextWrapper',['require','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  scenery.CanvasContextWrapper = function CanvasContextWrapper( canvas, context ) {\r\n    this.canvas = canvas;\r\n    this.context = context;\r\n    \r\n    this.resetStyles();\r\n  };\r\n  var CanvasContextWrapper = scenery.CanvasContextWrapper;\r\n  \r\n  CanvasContextWrapper.prototype = {\r\n    constructor: CanvasContextWrapper,\r\n    \r\n    // set local styles to undefined, so that they will be invalidated later\r\n    resetStyles: function() {\r\n      this.fillStyle = undefined; // null\r\n      this.strokeStyle = undefined; // null\r\n      this.lineWidth = undefined; // 1\r\n      this.lineCap = undefined; // 'butt'\r\n      this.lineJoin = undefined; // 'miter'\r\n      this.lineDash = undefined; // null\r\n      this.lineDashOffset = undefined; // 0\r\n      this.miterLimit = undefined; // 10\r\n      \r\n      this.font = undefined; // '10px sans-serif'\r\n      this.direction = undefined; // 'inherit'\r\n    },\r\n\r\n    /**\r\n     * Sets a (possibly) new width and height, and clears the canvas.\r\n     * @param width\r\n     * @param height\r\n     */\r\n    setDimensions: function( width, height ) {\r\n\r\n      //Don't guard against width and height, because we need to clear the canvas.\r\n      //TODO: Is it expensive to clear by setting both the width and the height?  Maybe we just need to set the width to clear it.\r\n      this.canvas.width = width;\r\n      this.canvas.height = height;\r\n\r\n      // assume all persistent data could have changed\r\n      this.resetStyles();\r\n    },\r\n    \r\n    setFillStyle: function( style ) {\r\n      if ( this.fillStyle !== style ) {\r\n        this.fillStyle = style;\r\n        \r\n        // allow gradients / patterns\r\n        this.context.fillStyle = ( style && style.getCanvasStyle ) ? style.getCanvasStyle() : style;\r\n      }\r\n    },\r\n    \r\n    setStrokeStyle: function( style ) {\r\n      if ( this.strokeStyle !== style ) {\r\n        this.strokeStyle = style;\r\n        \r\n        // allow gradients / patterns\r\n        this.context.strokeStyle = ( style && style.getCanvasStyle ) ? style.getCanvasStyle() : style;\r\n      }\r\n    },\r\n    \r\n    setLineWidth: function( width ) {\r\n      if ( this.lineWidth !== width ) {\r\n        this.lineWidth = width;\r\n        this.context.lineWidth = width;\r\n      }\r\n    },\r\n    \r\n    setLineCap: function( cap ) {\r\n      if ( this.lineCap !== cap ) {\r\n        this.lineCap = cap;\r\n        this.context.lineCap = cap;\r\n      }\r\n    },\r\n    \r\n    setLineJoin: function( join ) {\r\n      if ( this.lineJoin !== join ) {\r\n        this.lineJoin = join;\r\n        this.context.lineJoin = join;\r\n      }\r\n    },\r\n    \r\n    setLineDash: function( dash ) {\r\n      sceneryAssert && sceneryAssert( dash !== undefined, 'undefined line dash would cause hard-to-trace errors' );\r\n      if ( this.lineDash !== dash ) {\r\n        this.lineDash = dash;\r\n        if ( this.context.setLineDash ) {\r\n          this.context.setLineDash( dash === null ? [] : dash ); // see https://github.com/phetsims/scenery/issues/101 for null line-dash workaround\r\n        } else if ( this.context.mozDash !== undefined ) {\r\n          this.context.mozDash = dash;\r\n        } else if ( this.context.webkitLineDash !== undefined ) {\r\n          this.context.webkitLineDash = dash ? dash : [];\r\n        } else {\r\n          // unsupported line dash! do... nothing?\r\n        }\r\n      }\r\n    },\r\n    \r\n    setLineDashOffset: function( lineDashOffset ) {\r\n      if ( this.lineDashOffset !== lineDashOffset ) {\r\n        this.lineDashOffset = lineDashOffset;\r\n        if ( this.context.lineDashOffset !== undefined ) {\r\n          this.context.lineDashOffset = lineDashOffset;\r\n        } else if ( this.context.webkitLineDashOffset !== undefined ) {\r\n          this.context.webkitLineDashOffset = lineDashOffset;\r\n        } else {\r\n          // unsupported line dash! do... nothing?\r\n        }\r\n      }\r\n    },\r\n    \r\n    setFont: function( font ) {\r\n      if ( this.font !== font ) {\r\n        this.font = font;\r\n        this.context.font = font;\r\n      }\r\n    },\r\n    \r\n    setDirection: function( direction ) {\r\n      if ( this.direction !== direction ) {\r\n        this.direction = direction;\r\n        this.context.direction = direction;\r\n      }\r\n    }\r\n  };\r\n  \r\n  return CanvasContextWrapper;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Points to a specific node (with a trail), and whether it is conceptually before or after the node.\r\n *\r\n * There are two orderings:\r\n * - rendering order: the order that node selves would be rendered, matching the Trail implicit order\r\n * - nesting order:   the order in depth first with entering a node being \"before\" and exiting a node being \"after\"\r\n *\r\n * TODO: more seamless handling of the orders. or just exclusively use the nesting order\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/TrailPointer',['require','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  require( 'SCENERY/util/Trail' );\r\n  \r\n  /*\r\n   * isBefore: whether this points to before the node (and its children) have been rendered, or after\r\n   */\r\n  scenery.TrailPointer = function TrailPointer( trail, isBefore ) {\r\n    sceneryAssert && sceneryAssert( trail instanceof scenery.Trail, 'trail is not a trail' );\r\n    this.trail = trail;\r\n    \r\n    this.setBefore( isBefore );\r\n  };\r\n  var TrailPointer = scenery.TrailPointer;\r\n  \r\n  TrailPointer.prototype = {\r\n    constructor: TrailPointer,\r\n    \r\n    copy: function() {\r\n      return new TrailPointer( this.trail.copy(), this.isBefore );\r\n    },\r\n    \r\n    setBefore: function( isBefore ) {\r\n      this.isBefore = isBefore;\r\n      this.isAfter = !isBefore;\r\n    },\r\n    \r\n    // return the equivalent pointer that swaps before and after (may return null if it doesn't exist)\r\n    getRenderSwappedPointer: function() {\r\n      var newTrail = this.isBefore ? this.trail.previous() : this.trail.next();\r\n      \r\n      if ( newTrail === null ) {\r\n        return null;\r\n      } else {\r\n        return new TrailPointer( newTrail, !this.isBefore );\r\n      }\r\n    },\r\n    \r\n    getRenderBeforePointer: function() {\r\n      return this.isBefore ? this : this.getRenderSwappedPointer();\r\n    },\r\n    \r\n    getRenderAfterPointer: function() {\r\n      return this.isAfter ? this : this.getRenderSwappedPointer();\r\n    },\r\n    \r\n    /*\r\n     * In the render order, will return 0 if the pointers are equivalent, -1 if this pointer is before the\r\n     * other pointer, and 1 if this pointer is after the other pointer.\r\n     */\r\n    compareRender: function( other ) {\r\n      sceneryAssert && sceneryAssert( other !== null );\r\n      \r\n      var a = this.getRenderBeforePointer();\r\n      var b = other.getRenderBeforePointer();\r\n      \r\n      if ( a !== null && b !== null ) {\r\n        // normal (non-degenerate) case\r\n        return a.trail.compare( b.trail );\r\n      } else {\r\n        // null \"before\" point is equivalent to the \"after\" pointer on the last rendered node.\r\n        if ( a === b ) {\r\n          return 0; // uniqueness guarantees they were the same\r\n        } else {\r\n          return a === null ? 1 : -1;\r\n        }\r\n      }\r\n    },\r\n    \r\n    /*\r\n     * Like compareRender, but for the nested (depth-first) order\r\n     *\r\n     * TODO: optimization?\r\n     */\r\n    compareNested: function( other ) {\r\n      sceneryAssert && sceneryAssert( other );\r\n      \r\n      var comparison = this.trail.compare( other.trail );\r\n      \r\n      if ( comparison === 0 ) {\r\n        // if trails are equal, just compare before/after\r\n        if ( this.isBefore === other.isBefore ) {\r\n          return 0;\r\n        } else {\r\n          return this.isBefore ? -1 : 1;\r\n        }\r\n      } else {\r\n        // if one is an extension of the other, the shorter isBefore flag determines the order completely\r\n        if ( this.trail.isExtensionOf( other.trail ) ) {\r\n          return other.isBefore ? 1 : -1;\r\n        } else if ( other.trail.isExtensionOf( this.trail ) ) {\r\n          return this.isBefore ? -1 : 1;\r\n        } else {\r\n          // neither is a subtrail of the other, so a straight trail comparison should give the answer\r\n          return comparison;\r\n        }\r\n      }\r\n    },\r\n    \r\n    equalsRender: function( other ) {\r\n      return this.compareRender( other ) === 0;\r\n    },\r\n    \r\n    equalsNested: function( other ) {\r\n      return this.compareNested( other ) === 0;\r\n    },\r\n    \r\n    // will return false if this pointer has gone off of the beginning or end of the tree (will be marked with isAfter or isBefore though)\r\n    hasTrail: function() {\r\n      return !!this.trail;\r\n    },\r\n    \r\n    // TODO: refactor with \"Side\"-like handling\r\n    // moves this pointer forwards one step in the nested order\r\n    nestedForwards: function() {\r\n      if ( this.isBefore ) {\r\n        if ( this.trail.lastNode()._children.length > 0 ) {\r\n          // stay as before, just walk to the first child\r\n          this.trail.addDescendant( this.trail.lastNode()._children[0], 0 );\r\n        } else {\r\n          // stay on the same node, but switch to after\r\n          this.setBefore( false );\r\n        }\r\n      } else {\r\n        if ( this.trail.indices.length === 0 ) {\r\n          // nothing else to jump to below, so indicate the lack of existence\r\n          this.trail = null;\r\n          // stays isAfter\r\n          return null;\r\n        } else {\r\n          var index = this.trail.indices[this.trail.indices.length - 1];\r\n          this.trail.removeDescendant();\r\n          \r\n          if ( this.trail.lastNode()._children.length > index + 1 ) {\r\n            // more siblings, switch to the beginning of the next one\r\n            this.trail.addDescendant( this.trail.lastNode()._children[index+1], index + 1 );\r\n            this.setBefore( true );\r\n          } else {\r\n            // no more siblings. exit on parent. nothing else needed since we're already isAfter\r\n          }\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    // moves this pointer backwards one step in the nested order\r\n    nestedBackwards: function() {\r\n      if ( this.isBefore ) {\r\n        if ( this.trail.indices.length === 0 ) {\r\n          // jumping off the front\r\n          this.trail = null;\r\n          // stays isBefore\r\n          return null;\r\n        } else {\r\n          var index = this.trail.indices[this.trail.indices.length - 1];\r\n          this.trail.removeDescendant();\r\n          \r\n          if ( index - 1 >= 0 ) {\r\n            // more siblings, switch to the beginning of the previous one and switch to isAfter\r\n            this.trail.addDescendant( this.trail.lastNode()._children[index-1], index - 1 );\r\n            this.setBefore( false );\r\n          } else {\r\n            // no more siblings. enter on parent. nothing else needed since we're already isBefore\r\n          }\r\n        }\r\n      } else {\r\n        if ( this.trail.lastNode()._children.length > 0 ) {\r\n          // stay isAfter, but walk to the last child\r\n          var children = this.trail.lastNode()._children;\r\n          this.trail.addDescendant( children[children.length-1], children.length - 1 );\r\n        } else {\r\n          // switch to isBefore, since this is a leaf node\r\n          this.setBefore( true );\r\n        }\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    // treats the pointer as render-ordered (includes the start pointer 'before' if applicable, excludes the end pointer 'before' if applicable\r\n    eachNodeBetween: function( other, callback ) {\r\n      this.eachTrailBetween( other, function( trail ) {\r\n        callback( trail.lastNode() );\r\n      } );\r\n    },\r\n    \r\n    // treats the pointer as render-ordered (includes the start pointer 'before' if applicable, excludes the end pointer 'before' if applicable\r\n    eachTrailBetween: function( other, callback ) {\r\n      // this should trigger on all pointers that have the 'before' flag, except a pointer equal to 'other'.\r\n      \r\n      // since we exclude endpoints in the depthFirstUntil call, we need to fire this off first\r\n      if ( this.isBefore ) {\r\n        callback( this.trail );\r\n      }\r\n      \r\n      this.depthFirstUntil( other, function( pointer ) {\r\n        if ( pointer.isBefore ) {\r\n          callback( pointer.trail );\r\n        }\r\n      }, true ); // exclude the endpoints so we can ignore the ending 'before' case\r\n    },\r\n    \r\n    /*\r\n     * Recursively (depth-first) iterates over all pointers between this pointer and 'other', calling\r\n     * callback( pointer ) for each pointer. If excludeEndpoints is truthy, the callback will not be\r\n     * called if pointer is equivalent to this pointer or 'other'.\r\n     *\r\n     * If the callback returns a truthy value, the subtree for the current pointer will be skipped\r\n     * (applies only to before-pointers)\r\n     */\r\n    depthFirstUntil: function( other, callback, excludeEndpoints ) {\r\n      // make sure this pointer is before the other, but allow start === end if we are not excluding endpoints\r\n      sceneryAssert && sceneryAssert( this.compareNested( other ) <= ( excludeEndpoints ? -1 : 0 ), 'TrailPointer.depthFirstUntil pointers out of order, possibly in both meanings of the phrase!' );\r\n      sceneryAssert && sceneryAssert( this.trail.rootNode() === other.trail.rootNode(), 'TrailPointer.depthFirstUntil takes pointers with the same root' );\r\n      \r\n      // sanity check TODO: remove later\r\n      this.trail.reindex();\r\n      other.trail.reindex();\r\n      \r\n      var pointer = this.copy();\r\n      pointer.trail.setMutable(); // this trail will be modified in the iteration, so references to it may be modified\r\n      \r\n      var first = true;\r\n      \r\n      while ( !pointer.equalsNested( other ) ) {\r\n        sceneryAssert && sceneryAssert( pointer.compareNested( other ) !== 1, 'skipped in depthFirstUntil' );\r\n        var skipSubtree = false;\r\n        \r\n        if ( first ) {\r\n          // start point\r\n          if ( !excludeEndpoints ) {\r\n            skipSubtree = callback( pointer );\r\n          }\r\n          first = false;\r\n        } else {\r\n          // between point\r\n          skipSubtree = callback( pointer );\r\n        }\r\n        \r\n        if ( skipSubtree && pointer.isBefore ) {\r\n          // to skip the subtree, we just change to isAfter\r\n          pointer.setBefore( false );\r\n          \r\n          // if we skip a subtree, make sure we don't run past the ending pointer\r\n          if ( pointer.compareNested( other ) === 1 ) {\r\n            break;\r\n          }\r\n        } else {\r\n          pointer.nestedForwards();\r\n        }\r\n      }\r\n      \r\n      // end point\r\n      if ( !excludeEndpoints ) {\r\n        callback( pointer );\r\n      }\r\n    },\r\n    \r\n    toString: function() {\r\n      return '[' + ( this.isBefore ? 'before' : 'after' ) + ' ' + this.trail.toString().slice( 1 );\r\n    }\r\n  };\r\n  \r\n  return TrailPointer;\r\n} );\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * A Canvas-backed layer in the scene graph. Each layer handles dirty-region handling separately,\r\n * and corresponds to a single canvas / svg element / DOM element in the main container.\r\n * Importantly, it does not contain rendered content from a subtree of the main\r\n * scene graph. It only will render a contiguous block of nodes visited in a depth-first\r\n * manner.\r\n *\r\n * Backing store pixel ratio info: http://www.html5rocks.com/en/tutorials/canvas/hidpi/\r\n *\r\n * TODO: update internal documentation\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/layers/CanvasLayer',['require','PHET_CORE/inherit','DOT/Bounds2','SCENERY/scenery','KITE/Shape','SCENERY/layers/Layer','SCENERY/util/CanvasContextWrapper','SCENERY/util/Trail','SCENERY/util/TrailPointer','SCENERY/util/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Shape = require( 'KITE/Shape' );\r\n  \r\n  var Layer = require( 'SCENERY/layers/Layer' ); // uses Layer's prototype for inheritance\r\n  require( 'SCENERY/util/CanvasContextWrapper' );\r\n  require( 'SCENERY/util/Trail' );\r\n  require( 'SCENERY/util/TrailPointer' );\r\n  require( 'SCENERY/util/Util' );\r\n  \r\n  // stores CanvasContextWrappers to be re-used\r\n  var canvasContextPool = [];\r\n  \r\n  // assumes main is wrapped with JQuery\r\n  /*\r\n   *\r\n   */\r\n  scenery.CanvasLayer = function CanvasLayer( args ) {\r\n    sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' constructor' );\r\n    Layer.call( this, args );\r\n    \r\n    // TODO: deprecate Scene's backing scale, and handle this on a layer-by-layer option?\r\n    this.backingScale = args.scene.backingScale;\r\n    if ( args.fullResolution !== undefined ) {\r\n      this.backingScale = args.fullResolution ? scenery.Util.backingScale( document.createElement( 'canvas' ).getContext( '2d' ) ) : 1;\r\n    }\r\n    \r\n    this.logicalWidth = this.scene.sceneBounds.width;\r\n    this.logicalHeight = this.scene.sceneBounds.height;\r\n    \r\n    var canvas = document.createElement( 'canvas' );\r\n    canvas.width = this.logicalWidth * this.backingScale;\r\n    canvas.height = this.logicalHeight * this.backingScale;\r\n    canvas.style.width = this.logicalWidth + 'px';\r\n    canvas.style.height = this.logicalHeight + 'px';\r\n    canvas.style.position = 'absolute';\r\n    canvas.style.left = '0';\r\n    canvas.style.top = '0';\r\n    \r\n    // add this layer on top (importantly, the constructors of the layers are called in order)\r\n    this.$main.append( canvas );\r\n    \r\n    this.canvas = canvas;\r\n    // this.context = new DebugContext( canvas.getContext( '2d' ) );\r\n    this.context = canvas.getContext( '2d' );\r\n    this.scene = args.scene;\r\n    \r\n    // workaround for Chrome (WebKit) miterLimit bug: https://bugs.webkit.org/show_bug.cgi?id=108763\r\n    this.context.miterLimit = 20;\r\n    this.context.miterLimit = 10;\r\n    \r\n    this.isCanvasLayer = true;\r\n    \r\n    this.wrapper = new scenery.CanvasContextWrapper( this.canvas, this.context );\r\n    \r\n    this.boundlessCount = 0; // count of how many trails do not support bounds. we only will use dirty region repainting if this number is 0.\r\n  };\r\n  var CanvasLayer = scenery.CanvasLayer;\r\n  \r\n  inherit( Layer, CanvasLayer, {\r\n    \r\n    /*\r\n     * Renders the canvas layer from the scene\r\n     *\r\n     * Supported args: {\r\n     *   fullRender: true, // disables drawing to just dirty rectangles\r\n     *   TODO: pruning with bounds and flag to disable\r\n     * }\r\n     */\r\n    render: function( scene, args ) {\r\n      args = args || {};\r\n      \r\n      var dirtyBoundsEnabled = this.canUseDirtyRegions() && !args.fullRender;\r\n      \r\n      // bail out quickly if possible\r\n      if ( dirtyBoundsEnabled && this.dirtyBounds.isEmpty() ) {\r\n        return;\r\n      }\r\n      \r\n      // switch to an identity transform\r\n      this.context.setTransform( this.backingScale, 0, 0, this.backingScale, 0, 0 );\r\n      \r\n      var visibleDirtyBounds = dirtyBoundsEnabled ? this.dirtyBounds.intersection( scene.sceneBounds ) : scene.sceneBounds;\r\n      \r\n      if ( !visibleDirtyBounds.isEmpty() ) {\r\n        this.clearGlobalBounds( visibleDirtyBounds );\r\n        \r\n        if ( dirtyBoundsEnabled ) {\r\n          this.pushClipShape( Shape.bounds( visibleDirtyBounds ) );\r\n        }\r\n        \r\n        // dirty bounds (clear, possibly set restricted bounds and handling for that)\r\n        // visibility checks\r\n        this.recursiveRender( scene, args );\r\n        \r\n        // exists for now so that we pop the necessary context state\r\n        if ( dirtyBoundsEnabled ) {\r\n          this.popClipShape();\r\n        }\r\n      }\r\n      \r\n      // we rendered everything, no more dirty bounds\r\n      this.dirtyBounds = Bounds2.NOTHING;\r\n    },\r\n    \r\n    recursiveRender: function( scene, args ) {\r\n      var layer = this;\r\n      var i;\r\n      var startPointer = new scenery.TrailPointer( this.startPaintedTrail, true );\r\n      var endPointer = new scenery.TrailPointer( this.endPaintedTrail, true );\r\n      \r\n      // stack for canvases that need to be painted, since some effects require scratch canvases\r\n      var wrapperStack = [ this.wrapper ]; // type {CanvasContextWrapper}\r\n      this.wrapper.resetStyles(); // let's be defensive, save() and restore() may have been called previously\r\n      \r\n      function requiresScratchCanvas( trail ) {\r\n        return trail.lastNode().getOpacity() < 1;\r\n      }\r\n      \r\n      function getCanvasWrapper() {\r\n        var width = layer.logicalWidth * layer.backingScale;\r\n        var height = layer.logicalHeight * layer.backingScale;\r\n        \r\n        if ( canvasContextPool.length ) {\r\n          // use a pooled wrapper\r\n          var wrapper = canvasContextPool.pop();\r\n          wrapper.setDimensions( width, height );\r\n          return wrapper;\r\n        } else {\r\n          // create a new wrapper\r\n          var canvas = document.createElement( 'canvas' );\r\n          canvas.width = layer.logicalWidth * layer.backingScale;\r\n          canvas.height = layer.logicalHeight * layer.backingScale;\r\n          var context = canvas.getContext( '2d' );\r\n          \r\n          return new scenery.CanvasContextWrapper( canvas, context );\r\n        }\r\n      }\r\n      \r\n      function topWrapper() {\r\n        return wrapperStack[wrapperStack.length-1];\r\n      }\r\n      \r\n      function enter( trail ) {\r\n        var node = trail.lastNode();\r\n        \r\n        if ( requiresScratchCanvas( trail ) ) {\r\n          var wrapper = getCanvasWrapper();\r\n          wrapperStack.push( wrapper );\r\n          \r\n          var newContext = wrapper.context;\r\n          \r\n          // switch to an identity transform\r\n          newContext.setTransform( layer.backingScale, 0, 0, layer.backingScale, 0, 0 );\r\n          \r\n          // properly set the necessary transform on the context\r\n          var length = trail.nodes.length;\r\n          for ( var i = 0; i < length; i++ ) {\r\n            trail.nodes[i].transform.getMatrix().canvasAppendTransform( newContext );\r\n          }\r\n        } else {\r\n          node.transform.getMatrix().canvasAppendTransform( topWrapper().context );\r\n        }\r\n        \r\n        if ( node._clipShape ) {\r\n          // TODO: move to wrapper-specific part\r\n          layer.pushClipShape( node._clipShape );\r\n        }\r\n      }\r\n      \r\n      function exit( trail ) {\r\n        var node = trail.lastNode();\r\n        \r\n        if ( node._clipShape ) {\r\n          // TODO: move to wrapper-specific part\r\n          layer.popClipShape();\r\n        }\r\n        \r\n        if ( requiresScratchCanvas( trail ) ) {\r\n          var baseContext = wrapperStack[wrapperStack.length-2].context;\r\n          var topCanvas = wrapperStack[wrapperStack.length-1].canvas;\r\n          \r\n          // apply necessary style transforms before painting our popped canvas onto the next canvas\r\n          var opacityChange = trail.lastNode().getOpacity() < 1;\r\n          if ( opacityChange ) {\r\n            baseContext.globalAlpha = trail.lastNode().getOpacity();\r\n          }\r\n          \r\n          // paint our canvas onto the level below with a straight transform\r\n          baseContext.save();\r\n          baseContext.setTransform( 1, 0, 0, 1, 0, 0 );\r\n          baseContext.drawImage( topCanvas, 0, 0 );\r\n          baseContext.restore();\r\n          \r\n          // reset styles\r\n          if ( opacityChange ) {\r\n            baseContext.globalAlpha = 1;\r\n          }\r\n          \r\n          var wrapper = wrapperStack.pop();\r\n          if ( wrapper !== layer.wrapper ) {\r\n            // store the CanvasContextWrapper for recycling if it isn't our core wrapper\r\n            canvasContextPool.push( wrapper );\r\n          }\r\n        } else {\r\n          node.transform.getInverse().canvasAppendTransform( topWrapper().context );\r\n        }\r\n      }\r\n      \r\n      /*\r\n       * We count how many invisible nodes are in our trail, so we can properly iterate without inspecting everything.\r\n       * Additionally, state changes (enter/exit) are only done when nodes are visible, so we skip overhead. If\r\n       * invisibleCount > 0, then the current node is invisible.\r\n       */\r\n      var invisibleCount = 0;\r\n      \r\n      var boundaryTrail;\r\n      \r\n      // sanity check, and allows us to get faster speed\r\n      startPointer.trail.reindex();\r\n      endPointer.trail.reindex();\r\n      \r\n      // first, we need to walk the state up to before our pointer (as far as the recursive handling is concerned)\r\n      // if the pointer is 'before' the node, don't call its enterState since this will be taken care of as the first step.\r\n      // if the pointer is 'after' the node, call enterState since it will call exitState immediately inside the loop\r\n      var startWalkLength = startPointer.trail.length - ( startPointer.isBefore ? 1 : 0 );\r\n      boundaryTrail = new scenery.Trail();\r\n      for ( i = 0; i < startWalkLength; i++ ) {\r\n        var startNode = startPointer.trail.nodes[i];\r\n        boundaryTrail.addDescendant( startNode );\r\n        invisibleCount += startNode.isVisible() ? 0 : 1;\r\n        \r\n        if ( invisibleCount === 0 ) {\r\n          // walk up initial state\r\n          enter( boundaryTrail );\r\n        }\r\n      }\r\n      \r\n      startPointer.depthFirstUntil( endPointer, function renderPointer( pointer ) {\r\n        // handle render here\r\n        \r\n        var node = pointer.trail.lastNode();\r\n        \r\n        if ( pointer.isBefore ) {\r\n          invisibleCount += node.isVisible() ? 0 : 1;\r\n          \r\n          if ( invisibleCount === 0 ) {\r\n            enter( pointer.trail );\r\n            \r\n            if ( node.isPainted() ) {\r\n              var wrapper = wrapperStack[wrapperStack.length-1];\r\n              \r\n              // TODO: consider just passing the wrapper. state not needed (for now), context easily accessible\r\n              node.paintCanvas( wrapper );\r\n            }\r\n            \r\n            // TODO: restricted bounds rendering, and possibly generalize depthFirstUntil\r\n            // var children = node._children;\r\n            \r\n            // check if we need to filter the children we render, and ignore nodes with few children (but allow 2, since that may prevent branches)\r\n            // if ( state.childRestrictedBounds && children.length > 1 ) {\r\n            //   var localRestrictedBounds = node.globalToLocalBounds( state.childRestrictedBounds );\r\n              \r\n            //   // don't filter if every child is inside the bounds\r\n            //   if ( !localRestrictedBounds.containsBounds( node.parentToLocalBounds( node._bounds ) ) ) {\r\n            //     children = node.getChildrenWithinBounds( localRestrictedBounds );\r\n            //   }\r\n            // }\r\n            \r\n            // _.each( children, function( child ) {\r\n            //   fullRender( child, state );\r\n            // } );\r\n          } else {\r\n            // not visible, so don't render the entire subtree\r\n            return true;\r\n          }\r\n        } else {\r\n          if ( invisibleCount === 0 ) {\r\n            exit( pointer.trail );\r\n          }\r\n          \r\n          invisibleCount -= node.isVisible() ? 0 : 1;\r\n        }\r\n        \r\n      }, false ); // include endpoints (for now)\r\n      \r\n      // then walk the state back so we don't muck up any context saving that is going on, similar to how we walked it at the start\r\n      // if the pointer is 'before' the node, call exitState since it called enterState inside the loop on it\r\n      // if the pointer is 'after' the node, don't call its exitState since this was already done\r\n      boundaryTrail = endPointer.trail.copy();\r\n      var endWalkLength = endPointer.trail.length - ( endPointer.isAfter ? 1 : 0 );\r\n      for ( i = endWalkLength - 1; i >= 0; i-- ) {\r\n        var endNode = endPointer.trail.nodes[i];\r\n        invisibleCount -= endNode.isVisible() ? 0 : 1;\r\n        \r\n        if ( invisibleCount === 0 ) {\r\n          // walk back the state\r\n          exit( boundaryTrail );\r\n        }\r\n        \r\n        boundaryTrail.removeDescendant();\r\n      }\r\n    },\r\n    \r\n    dispose: function() {\r\n      Layer.prototype.dispose.call( this );\r\n      \r\n      this.canvas.parentNode.removeChild( this.canvas );\r\n    },\r\n    \r\n    // TODO: consider a stack-based model for transforms?\r\n    applyTransformationMatrix: function( matrix ) {\r\n      matrix.canvasAppendTransform( this.context );\r\n    },\r\n    \r\n    // returns next zIndex in place. allows layers to take up more than one single zIndex\r\n    reindex: function( zIndex ) {\r\n      Layer.prototype.reindex.call( this, zIndex );\r\n      \r\n      if ( this.zIndex !== zIndex ) {\r\n        this.canvas.style.zIndex = zIndex;\r\n        this.zIndex = zIndex;\r\n      }\r\n      return zIndex + 1;\r\n    },\r\n    \r\n    pushClipShape: function( shape ) {\r\n      // store the current state, since browser support for context.resetClip() is not yet in the stable browser versions\r\n      this.context.save();\r\n      \r\n      this.writeClipShape( shape );\r\n    },\r\n    \r\n    popClipShape: function() {\r\n      this.context.restore();\r\n    },\r\n    \r\n    // canvas-specific\r\n    writeClipShape: function( shape ) {\r\n      // set up the clipping\r\n      this.context.beginPath();\r\n      shape.writeToContext( this.context );\r\n      this.context.clip();\r\n    },\r\n    \r\n    clearGlobalBounds: function( bounds ) {\r\n      if ( !bounds.isEmpty() ) {\r\n        this.context.save();\r\n        this.context.setTransform( this.backingScale, 0, 0, this.backingScale, 0, 0 );\r\n        this.context.clearRect( bounds.getX(), bounds.getY(), bounds.getWidth(), bounds.getHeight() );\r\n        // use this for debugging cleared (dirty) regions for now\r\n        // this.context.fillStyle = '#' + Math.floor( Math.random() * 0xffffff ).toString( 16 );\r\n        // this.context.fillRect( bounds.x, bounds.y, bounds.width, bounds.height );\r\n        this.context.restore();\r\n      }\r\n    },\r\n    \r\n    getSVGString: function() {\r\n      return '<image xmlns:xlink=\"http://www.w3.org/1999/xlink\" xlink:href=\"' + this.canvas.toDataURL() + '\" x=\"0\" y=\"0\" height=\"' + this.canvas.height + 'px\" width=\"' + this.canvas.width + 'px\"/>';\r\n    },\r\n    \r\n    // TODO: note for DOM we can do https://developer.mozilla.org/en-US/docs/HTML/Canvas/Drawing_DOM_objects_into_a_canvas\r\n    renderToCanvas: function( canvas, context, delayCounts ) {\r\n      context.drawImage( this.canvas, 0, 0 );\r\n    },\r\n    \r\n    addInstance: function( instance ) {\r\n      var trail = instance.trail;\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' addInstance: ' + trail.toString() );\r\n      Layer.prototype.addInstance.call( this, instance );\r\n      \r\n      // since the node's getBounds() are in the parent coordinate frame, we peel off the last node to get the correct (relevant) transform\r\n      // TODO: more efficient way of getting this transform?\r\n      this.canvasMarkLocalBounds( trail.lastNode().getBounds(), trail.slice( 0, trail.length - 1 ) );\r\n      \r\n      if ( trail.lastNode().boundsInaccurate ) {\r\n        this.boundlessCount++;\r\n      }\r\n    },\r\n    \r\n    removeInstance: function( instance ) {\r\n      var trail = instance.trail;\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' removeInstance: ' + trail.toString() );\r\n      Layer.prototype.removeInstance.call( this, instance );\r\n      \r\n      // since the node's getBounds() are in the parent coordinate frame, we peel off the last node to get the correct (relevant) transform\r\n      // TODO: more efficient way of getting this transform?\r\n      this.canvasMarkLocalBounds( trail.lastNode().getBounds(), trail.slice( 0, trail.length - 1 ) );\r\n      \r\n      if ( trail.lastNode().boundsInaccurate ) {\r\n        this.boundlessCount--;\r\n      }\r\n    },\r\n    \r\n    canUseDirtyRegions: function() {\r\n      sceneryAssert && sceneryAssert( this.boundlessCount >= 0 );\r\n      return this.boundlessCount === 0;\r\n    },\r\n    \r\n    // NOTE: for performance, we will mutate the bounds passed in (they are almost assuredly from the local or parent bounds functions)\r\n    canvasMarkGlobalBounds: function( globalBounds ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' canvasMarkGlobalBounds: ' + globalBounds.toString() );\r\n      sceneryAssert && sceneryAssert( globalBounds.isEmpty() || globalBounds.isFinite(), 'Infinite (non-empty) dirty bounds passed to canvasMarkGlobalBounds' );\r\n      \r\n      // TODO: for performance, consider more than just a single dirty bounding box\r\n      this.dirtyBounds = this.dirtyBounds.union( globalBounds.dilate( 2 ).roundOut() );\r\n    },\r\n    \r\n    canvasMarkLocalBounds: function( localBounds, trail ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' canvasMarkLocalBounds: ' + localBounds.toString() + ' on ' + trail.toString() );\r\n      if ( !this.canUseDirtyRegions() ) {\r\n        this.dirtyBounds = Bounds2.EVERYTHING;\r\n      } else {\r\n        this.canvasMarkGlobalBounds( trail.localToGlobalBounds( localBounds ) );\r\n      }\r\n    },\r\n    \r\n    canvasMarkParentBounds: function( parentBounds, trail ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' canvasMarkParentBounds: ' + parentBounds.toString() + ' on ' + trail.toString() );\r\n      if ( !this.canUseDirtyRegions() ) {\r\n        this.dirtyBounds = Bounds2.EVERYTHING;\r\n      } else {\r\n        this.canvasMarkGlobalBounds( trail.parentToGlobalBounds( parentBounds ) );\r\n      }\r\n    },\r\n    \r\n    canvasMarkSelf: function( instance ) {\r\n      this.canvasMarkLocalBounds( instance.getNode().getSelfBounds(), instance.trail );\r\n    },\r\n    \r\n    canvasMarkSubtree: function( instance ) {\r\n      this.canvasMarkParentBounds( instance.getNode().getBounds(), instance.trail );\r\n    },\r\n    \r\n    getName: function() {\r\n      return 'canvas';\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Events from Instances\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    notifyVisibilityChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyVisibilityChange: ' + instance.trail.toString() );\r\n      // old paint taken care of in notifyBeforeSubtreeChange()\r\n      \r\n      if ( instance.trail.isVisible() ) {\r\n        this.canvasMarkSubtree( instance );\r\n      }\r\n    },\r\n    \r\n    notifyOpacityChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyOpacityChange: ' + instance.trail.toString() );\r\n      // old paint taken care of in notifyBeforeSubtreeChange()\r\n      \r\n      this.canvasMarkSubtree( instance );\r\n    },\r\n    \r\n    // only a painted trail under this layer\r\n    notifyBeforeSelfChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyBeforeSelfChange: ' + instance.trail.toString() );\r\n      this.canvasMarkSelf( instance );\r\n    },\r\n    \r\n    notifyBeforeSubtreeChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyBeforeSubtreeChange: ' + instance.trail.toString() );\r\n      this.canvasMarkSubtree( instance );\r\n    },\r\n    \r\n    // only a painted trail under this layer\r\n    notifyDirtySelfPaint: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyDirtySelfPaint: ' + instance.trail.toString() );\r\n      this.canvasMarkSelf( instance );\r\n    },\r\n    \r\n    notifyDirtySubtreePaint: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyDirtySubtreePaint: ' + instance.trail.toString() );\r\n      this.canvasMarkSubtree( instance );\r\n    },\r\n    \r\n    notifyTransformChange: function( instance ) {\r\n      // sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyTransformChange: ' + instance.trail.toString() );\r\n      // TODO: how best to mark this so if there are multiple 'movements' we don't get called more than needed?\r\n      // this.canvasMarkSubtree( instance );\r\n    },\r\n    \r\n    // only a painted trail under this layer (for now)\r\n    notifyBoundsAccuracyChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'CanvasLayer #' + this.id + ' notifyBoundsAccuracyChange: ' + instance.trail.toString() );\r\n      \r\n      if ( instance.node.boundsInaccurate ) {\r\n        this.boundlessCount++;\r\n      } else {\r\n        this.boundlessCount--;\r\n      }\r\n    }\r\n  } );\r\n  \r\n  return CanvasLayer;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * A DOM-based layer in the scene graph. Each layer handles dirty-region handling separately,\r\n * and corresponds to a single canvas / svg element / DOM element in the main container.\r\n * Importantly, it does not contain rendered content from a subtree of the main\r\n * scene graph. It only will render a contiguous block of nodes visited in a depth-first\r\n * manner.\r\n *\r\n * Nodes supporting the DOM renderer should have the following functions:\r\n *   allowsMultipleDOMInstances:               {Boolean} whether getDOMElement will return the same element every time, or new elements.\r\n *   getDOMElement():                          Returns a DOM element that represents this node.\r\n *   updateDOMElement( element ):              Updates the DOM element with any changes that were made.\r\n *   updateCSSTransform( transform, element ): Updates the CSS transform of the element\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/layers/DOMLayer',['require','PHET_CORE/inherit','DOT/Bounds2','SCENERY/scenery','SCENERY/layers/Layer','SCENERY/util/Trail'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Layer = require( 'SCENERY/layers/Layer' ); // DOMLayer inherits from Layer\r\n  require( 'SCENERY/util/Trail' );\r\n  \r\n  scenery.DOMLayer = function DOMLayer( args ) {\r\n    sceneryLayerLog && sceneryLayerLog( 'DOMLayer constructor' );\r\n    \r\n    Layer.call( this, args );\r\n    \r\n    var width = args.scene.sceneBounds.width;\r\n    var height = args.scene.sceneBounds.height;\r\n    \r\n    this.div = document.createElement( 'div' );\r\n    var div = this.div;\r\n    div.style.position = 'absolute';\r\n    div.style.left = '0';\r\n    div.style.top = '0';\r\n    div.style.width = '0';\r\n    div.style.height = '0';\r\n    div.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';\r\n    this.$div = $( this.div );\r\n    this.$main.append( this.div );\r\n    \r\n    this.scene = args.scene; // TODO: should already be set in the supertype Layer\r\n    \r\n    this.isDOMLayer = true;\r\n    \r\n    // maps trail ID => DOM element fragment\r\n    this.idElementMap = {};\r\n    \r\n    // maps trail ID => Trail. trails need to be reindexed\r\n    this.idTrailMap = {};\r\n    \r\n    this.trails = [];\r\n  };\r\n  var DOMLayer = scenery.DOMLayer;\r\n  \r\n  inherit( Layer, DOMLayer, {\r\n    \r\n    addInstance: function( instance ) {\r\n      Layer.prototype.addInstance.call( this, instance );\r\n      \r\n      var trail = instance.trail;\r\n      this.reindexTrails();\r\n      \r\n      var node = trail.lastNode();\r\n      \r\n      var element = node.getDOMElement();\r\n      node.updateDOMElement( element );\r\n      this.updateVisibility( trail, element );\r\n      \r\n      this.idElementMap[trail.getUniqueId()] = element;\r\n      this.idTrailMap[trail.getUniqueId()] = trail;\r\n      \r\n      // walk the insertion index up the array. TODO: performance: binary search version?\r\n      var insertionIndex;\r\n      for ( insertionIndex = 0; insertionIndex < this.trails.length; insertionIndex++ ) {\r\n        var otherTrail = this.trails[insertionIndex];\r\n        otherTrail.reindex();\r\n        var comparison = otherTrail.compare( trail );\r\n        sceneryAssert && sceneryAssert( comparison !== 0, 'Trail has already been inserted into the DOMLayer' );\r\n        if ( comparison === 1 ) { // TODO: enum values!\r\n          break;\r\n        }\r\n      }\r\n      \r\n      if ( insertionIndex === this.div.childNodes.length ) {\r\n        this.div.appendChild( element );\r\n        this.trails.push( trail );\r\n      } else {\r\n        this.div.insertBefore( this.getElementFromTrail( this.trails[insertionIndex] ) );\r\n        this.trails.splice( insertionIndex, 0, trail );\r\n      }\r\n      node.updateCSSTransform( trail.getTransform(), element );\r\n    },\r\n    \r\n    removeInstance: function( instance ) {\r\n      Layer.prototype.removeInstance.call( this, instance );\r\n      \r\n      var trail = instance.trail;\r\n      this.reindexTrails();\r\n      \r\n      var element = this.getElementFromTrail( trail );\r\n      sceneryAssert && sceneryAssert( element, 'Trail does not exist in the DOMLayer' );\r\n      \r\n      delete this.idElementMap[trail.getUniqueId];\r\n      delete this.idTrailMap[trail.getUniqueId];\r\n      \r\n      this.div.removeChild( element );\r\n      \r\n      var removalIndex = this.getIndexOfTrail( trail );\r\n      this.trails.splice( removalIndex, 1 );\r\n    },\r\n    \r\n    getElementFromTrail: function( trail ) {\r\n      return this.idElementMap[trail.getUniqueId()];\r\n    },\r\n    \r\n    reindexTrails: function( zIndex ) {\r\n      Layer.prototype.reindex.call( this, zIndex );\r\n      \r\n      var i = this.trails.length;\r\n      while ( i-- ) {\r\n        this.trails[i].reindex();\r\n      }\r\n    },\r\n    \r\n    getIndexOfTrail: function( trail ) {\r\n      // find the index where our trail is at. strict equality won't work, we want to compare differently\r\n      var i;\r\n      for ( i = 0; i < this.trails.length; i++ ) {\r\n        if ( this.trails[i].compare( trail ) === 0 ) {\r\n          return i;\r\n        }\r\n      }\r\n      throw new Error( 'DOMLayer.getIndexOfTrail unable to find trail: ' + trail.toString() );\r\n    },\r\n    \r\n    render: function( scene, args ) {\r\n      // nothing at all needed here, CSS transforms taken care of when dirty regions are notified\r\n    },\r\n    \r\n    dispose: function() {\r\n      Layer.prototype.dispose.call( this );\r\n      \r\n      this.div.parentNode.removeChild( this.div );\r\n    },\r\n    \r\n    updateVisibility: function( trail, element ) {\r\n      if ( trail.isVisible() ) {\r\n        element.style.visibility = 'visible';\r\n      } else {\r\n        element.style.visibility = 'hidden';\r\n      }\r\n    },\r\n    \r\n    // TODO: consider a stack-based model for transforms?\r\n    // TODO: deprecated? remove this?\r\n    applyTransformationMatrix: function( matrix ) {\r\n      // nothing at all needed here\r\n    },\r\n    \r\n    getContainer: function() {\r\n      return this.div;\r\n    },\r\n    \r\n    // returns next zIndex in place. allows layers to take up more than one single zIndex\r\n    reindex: function( zIndex ) {\r\n      Layer.prototype.reindex.call( this, zIndex );\r\n      \r\n      if ( this.zIndex !== zIndex ) {\r\n        this.div.style.zIndex = zIndex;\r\n        this.zIndex = zIndex;\r\n      }\r\n      return zIndex + 1;\r\n    },\r\n    \r\n    pushClipShape: function( shape ) {\r\n      // TODO: clipping\r\n    },\r\n    \r\n    popClipShape: function() {\r\n      // TODO: clipping\r\n    },\r\n    \r\n    getSVGString: function() {\r\n      var data = \"<svg xmlns='http://www.w3.org/2000/svg' width='\" + this.$main.width() + \"' height='\" + this.$main.height() + \"'>\" +\r\n        \"<foreignObject width='100%' height='100%'>\" +\r\n        $( this.div ).html() +\r\n        \"</foreignObject></svg>\";\r\n    },\r\n    \r\n    // TODO: note for DOM we can do https://developer.mozilla.org/en-US/docs/HTML/Canvas/Drawing_DOM_objects_into_a_canvas\r\n    // TODO: note that http://pbakaus.github.com/domvas/ may work better, but lacks IE support\r\n    renderToCanvas: function( canvas, context, delayCounts ) {\r\n      // TODO: consider not silently failing?\r\n      // var data = \"<svg xmlns='http://www.w3.org/2000/svg' width='\" + this.$main.width() + \"' height='\" + this.$main.height() + \"'>\" +\r\n      //   \"<foreignObject width='100%' height='100%'>\" +\r\n      //   $( this.div ).html() +\r\n      //   \"</foreignObject></svg>\";\r\n      \r\n      // var DOMURL = window.URL || window.webkitURL || window;\r\n      // var img = new Image();\r\n      // var svg = new Blob( [ data ] , { type: \"image/svg+xml;charset=utf-8\" } );\r\n      // var url = DOMURL.createObjectURL( svg );\r\n      // delayCounts.increment();\r\n      // img.onload = function() {\r\n      //   context.drawImage( img, 0, 0 );\r\n      //   // TODO: this loading is delayed!!! ... figure out a solution to potentially delay?\r\n      //   DOMURL.revokeObjectURL( url );\r\n      //   delayCounts.decrement();\r\n      // };\r\n      // img.src = url;\r\n    },\r\n    \r\n    getName: function() {\r\n      return 'dom';\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Events from Instances\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    notifyVisibilityChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyVisibilityChange: ' + instance.trail.toString() );\r\n      var trail = instance.trail;\r\n      \r\n      // TODO: performance: faster way to iterate through!\r\n      for ( var trailId in this.idTrailMap ) {\r\n        var subtrail = this.idTrailMap[trailId];\r\n        subtrail.reindex();\r\n        if ( subtrail.isExtensionOf( trail, true ) ) {\r\n          this.updateVisibility( subtrail, this.idElementMap[trailId] );\r\n        }\r\n      }\r\n    },\r\n    \r\n    notifyOpacityChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyOpacityChange: ' + instance.trail.toString() );\r\n      // TODO: BROKEN: FIXME: DOM opacity is not handled yet, see issue #31: https://github.com/phetsims/scenery/issues/31\r\n    },\r\n    \r\n    // only a painted trail under this layer\r\n    notifyBeforeSelfChange: function( instance ) {\r\n      // sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyBeforeSelfChange: ' + instance.trail.toString() );\r\n      // no-op, we don't need paint changes\r\n    },\r\n    \r\n    notifyBeforeSubtreeChange: function( instance ) {\r\n      // sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyBeforeSubtreeChange: ' + instance.trail.toString() );\r\n      // no-op, we don't need paint changes\r\n    },\r\n    \r\n    // only a painted trail under this layer\r\n    notifyDirtySelfPaint: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyDirtySelfPaint: ' + instance.trail.toString() );\r\n      var node = instance.getNode();\r\n      var trail = instance.trail;\r\n      \r\n      // TODO: performance: store this in the Instance itself?\r\n      var dirtyElement = this.idElementMap[trail.getUniqueId()];\r\n      if ( dirtyElement ) {\r\n        node.updateDOMElement( dirtyElement );\r\n        \r\n        if ( node.domUpdateTransformOnRepaint ) {\r\n          node.updateCSSTransform( trail.getTransform(), dirtyElement );\r\n        }\r\n      }\r\n    },\r\n\r\n    notifyDirtySubtreePaint: function( instance ) {\r\n      if ( instance.layer === this ) {\r\n        this.notifyDirtySelfPaint( instance );\r\n      }\r\n    },\r\n    \r\n    notifyTransformChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyTransformChange: ' + instance.trail.toString() );\r\n      var layer = this;\r\n      \r\n      var baseTrail = instance.trail;\r\n      \r\n      // TODO: performance: efficiency! this computes way more matrix transforms than needed\r\n      scenery.Trail.eachPaintedTrailBetween( this.startPaintedTrail, this.endPaintedTrail, function( trail ) {\r\n        if ( trail.isExtensionOf( baseTrail, true ) ) {\r\n          // TODO: put the element on the instance?\r\n          var element = layer.idElementMap[trail.getUniqueId()];\r\n          var node = trail.lastNode();\r\n          node.updateCSSTransform( trail.getTransform(), element );\r\n        }\r\n      }, false, this.scene );\r\n    },\r\n    \r\n    // only a painted trail under this layer (for now)\r\n    notifyBoundsAccuracyChange: function( instance ) {\r\n      // sceneryLayerLog && sceneryLayerLog( 'DOMLayer #' + this.id + ' notifyBoundsAccuracyChange: ' + instance.trail.toString() );\r\n      // no-op, we don't care about bounds\r\n    }\r\n    \r\n  } );\r\n  \r\n  return DOMLayer;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * An SVG-based layer in the scene graph. Each layer handles dirty-region handling separately,\r\n * and corresponds to a single canvas / svg element / DOM element in the main container.\r\n * Importantly, it does not contain rendered content from a subtree of the main\r\n * scene graph. It only will render a contiguous block of nodes visited in a depth-first\r\n * manner.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/layers/SVGLayer',['require','PHET_CORE/inherit','DOT/Bounds2','DOT/Transform3','DOT/Matrix3','SCENERY/scenery','SCENERY/layers/Layer','SCENERY/util/Trail','SCENERY/util/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Layer = require( 'SCENERY/layers/Layer' ); // extends Layer\r\n  require( 'SCENERY/util/Trail' );\r\n  require( 'SCENERY/util/Util' );\r\n  \r\n  // used namespaces\r\n  var svgns = 'http://www.w3.org/2000/svg';\r\n  var xlinkns = 'http://www.w3.org/1999/xlink';\r\n  \r\n  scenery.SVGLayer = function SVGLayer( args ) {\r\n    sceneryLayerLog && sceneryLayerLog( 'SVGLayer constructor' );\r\n    var $main = args.$main;\r\n    \r\n    this.scene = args.scene;\r\n    \r\n    // main SVG element\r\n    this.svg = document.createElementNS( svgns, 'svg' );\r\n    \r\n    // the SVG has a single group under it, which corresponds to the transform of the layer's base node\r\n    // TODO: consider renaming to 'this.baseGroup'\r\n    this.g = document.createElementNS( svgns, 'g' );\r\n    \r\n    // the <defs> block that we will be stuffing gradients and patterns into\r\n    this.defs = document.createElementNS( svgns, 'defs' );\r\n    \r\n    var width = args.scene.sceneBounds.width;\r\n    var height = args.scene.sceneBounds.height;\r\n    \r\n    this.svg.appendChild( this.defs );\r\n    this.svg.appendChild( this.g );\r\n    this.$svg = $( this.svg );\r\n    this.svg.setAttribute( 'width', width );\r\n    this.svg.setAttribute( 'height', height );\r\n    this.svg.setAttribute( 'stroke-miterlimit', 10 ); // to match our Canvas brethren so we have the same default behavior\r\n    this.svg.style.position = 'absolute';\r\n    this.svg.style.left = '0';\r\n    this.svg.style.top = '0';\r\n    this.svg.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';\r\n    this.svg.style['pointer-events'] = 'none';\r\n    $main.append( this.svg );\r\n    \r\n    this.isSVGLayer = true;\r\n    \r\n    // maps trail ID => SVG self fragment (that displays shapes, text, etc.)\r\n    this.idFragmentMap = {};\r\n    \r\n    // maps trail ID => SVG <g> that contains that node's self and everything under it\r\n    this.idGroupMap = {};\r\n    \r\n    \r\n    Layer.call( this, args );\r\n    \r\n    this.baseTransformDirty = true;\r\n    this.baseTransformChange = true;\r\n  };\r\n  var SVGLayer = scenery.SVGLayer;\r\n  \r\n  inherit( Layer, SVGLayer, {\r\n    \r\n    /*\r\n     * Notes about how state is tracked here:\r\n     * Trails are stored on group.trail so that we can look this up when inserting new groups\r\n     */\r\n    addInstance: function( instance ) {\r\n      var trail = instance.trail;\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' addInstance: ' + trail.toString() );\r\n      \r\n      sceneryAssert && sceneryAssert( !( trail.getUniqueId() in this.idFragmentMap ), 'Already contained that trail!' );\r\n      sceneryAssert && sceneryAssert( trail.isPainted(), 'Don\\'t add nodes without isPainted() to SVGLayer' );\r\n      \r\n      Layer.prototype.addInstance.call( this, instance );\r\n      \r\n      var subtrail = this.baseTrail.copy(); // grab the trail up to (and including) the base node, so we don't create superfluous groups\r\n      var lastId = null;\r\n      \r\n      // walk a subtrail up from the root node all the way to the full trail, creating groups where necessary\r\n      while ( subtrail.length <= trail.length ) {\r\n        var id = subtrail.getUniqueId();\r\n        var group = this.idGroupMap[id];\r\n        \r\n        if ( !group ) {\r\n          // we need to create a new group\r\n          \r\n          if ( lastId ) {\r\n            // we have a parent group to which we need to be added\r\n            group = document.createElementNS( svgns, 'g' );\r\n            \r\n            // apply the node's transform to the group\r\n            this.applyTransform( subtrail.lastNode().getTransform(), group );\r\n            \r\n            // add the group to its parent\r\n            this.insertGroupIntoParent( group, this.idGroupMap[lastId], subtrail );\r\n          } else {\r\n            // we are ensuring the base group\r\n            sceneryAssert && sceneryAssert( subtrail.lastNode() === this.baseNode );\r\n            \r\n            group = this.g;\r\n            \r\n            // sets up the proper transform for the base\r\n            this.initializeBase();\r\n            \r\n            // immediately update the base transform so we don't temporarily display.\r\n            // fixes https://github.com/phetsims/beers-law-lab/issues/20\r\n            this.refreshBaseTransform();\r\n          }\r\n          \r\n          // apply any stylings to the group (opacity, visibility)\r\n          this.updateNodeGroup( subtrail.lastNode(), group );\r\n          \r\n          group.referenceCount = 0; // initialize a reference count, so we can know when to remove unused groups\r\n          group.trail = subtrail.copy(); // put a reference to the trail on the group, so we can efficiently scan and see where to insert future groups\r\n          \r\n          this.idGroupMap[id] = group;\r\n        }\r\n        \r\n        // this trail will depend on this group, so increment the reference counter\r\n        group.referenceCount++;\r\n        \r\n        if ( subtrail.length === trail.length ) {\r\n          // TODO: cleaner control structures\r\n          break;\r\n        }\r\n        \r\n        // step down towards our full trail\r\n        subtrail.addDescendant( trail.nodes[subtrail.length] );\r\n        lastId = id;\r\n      }\r\n      \r\n      // actually add the node into its own group\r\n      var node = trail.lastNode();\r\n      var trailId = trail.getUniqueId();\r\n      \r\n      var nodeGroup = this.idGroupMap[trailId];\r\n      var svgFragment = node.createSVGFragment( this.svg, this.defs, nodeGroup );\r\n      this.updateNode( node, svgFragment );\r\n      this.updateNodeGroup( node, nodeGroup );\r\n      this.idFragmentMap[trailId] = svgFragment;\r\n      nodeGroup.appendChild( svgFragment );\r\n    },\r\n    \r\n    removeInstance: function( instance ) {\r\n      var trail = instance.trail;\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' removeInstance: ' + trail.toString() );\r\n      sceneryAssert && sceneryAssert( trail.getUniqueId() in this.idFragmentMap, 'Did not contain that trail!' );\r\n      \r\n      Layer.prototype.removeInstance.call( this, instance );\r\n      \r\n      // clean up the fragment and defs directly died to the node\r\n      var trailId = trail.getUniqueId();\r\n      var node = trail.lastNode();\r\n      var fragment = this.idFragmentMap[trailId];\r\n      this.idGroupMap[trailId].removeChild( fragment );\r\n      delete this.idFragmentMap[trailId];\r\n      if ( node.removeSVGDefs ) {\r\n        node.removeSVGDefs( this.svg, this.defs );\r\n      }\r\n      \r\n      // clean up any unneeded groups\r\n      var subtrail = trail.copy();\r\n      while ( subtrail.length > this.baseTrail.length ) {\r\n        var id = subtrail.getUniqueId();\r\n        \r\n        var group = this.idGroupMap[id];\r\n        group.referenceCount--;\r\n        if ( group.referenceCount === 0 ) {\r\n          // completely kill the group\r\n          group.parentNode.removeChild( group );\r\n          delete group.trail; // just in case someone held a reference\r\n          delete this.idGroupMap[id];\r\n        }\r\n        \r\n        subtrail.removeDescendant();\r\n      }\r\n      this.g.referenceCount--; // since we don't go down to the base group, adjust its reference count\r\n    },\r\n    \r\n    // subtrail is to group, and should include parentGroup below\r\n    insertGroupIntoParent: function( group, parentGroup, subtrail ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' insertGroupIntoParent subtrail:' + subtrail.toString() );\r\n      if ( !parentGroup.childNodes.length ) {\r\n        parentGroup.appendChild( group );\r\n      } else {\r\n        // if there is already a child, we need to do a scan to ensure we place our group as a child in the correct order (above/below)\r\n        \r\n        // scan other child groups in the parentGroup to find where we need to be (index i)\r\n        var afterNode = null;\r\n        var indexIndex = subtrail.length - 2; // index into the trail's indices\r\n        var ourIndex = subtrail.indices[indexIndex];\r\n        var i;\r\n        for ( i = 0; i < parentGroup.childNodes.length; i++ ) {\r\n          var child = parentGroup.childNodes[i];\r\n          if ( child.trail ) {\r\n            child.trail.reindex();\r\n            var otherIndex = child.trail.indices[indexIndex];\r\n            if ( otherIndex > ourIndex ) {\r\n              // this other group is above us\r\n              break;\r\n            }\r\n          }\r\n        }\r\n        \r\n        // insert our group before parentGroup.childNodes[i] (or append if that doesn't exist)\r\n        if ( i === parentGroup.childNodes.length ) {\r\n          parentGroup.appendChild( group );\r\n        } else {\r\n          parentGroup.insertBefore( group, parentGroup.childNodes[i] );\r\n        }\r\n      }\r\n    },\r\n    \r\n    // updates visual styles on an existing SVG fragment\r\n    updateNode: function( node, fragment ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' updateNode: ' + node.constructor.name + ' #' + node.id );\r\n      if ( node.updateSVGFragment ) {\r\n        node.updateSVGFragment( fragment );\r\n      }\r\n      if ( node.updateSVGDefs ) {\r\n        node.updateSVGDefs( this.svg, this.defs );\r\n      }\r\n    },\r\n    \r\n    // updates necessary paint attributes on a group (not including transform)\r\n    updateNodeGroup: function( node, group ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' updateNodeGroup: ' + node.constructor.name + ' #' + node.id );\r\n      this.updateGroupVisibility( node, group );\r\n      this.updateGroupOpacity( node, group );\r\n    },\r\n    \r\n    updateGroupVisibility: function( node, group ) {\r\n      // if we're updating visibility for the base trail, apply its visibility and everything beneath it\r\n      if ( node === this.baseNode ? this.baseTrail.isVisible() : node.isVisible() ) {\r\n        group.style.display = 'inherit';\r\n      } else {\r\n        group.style.display = 'none';\r\n      }\r\n    },\r\n    \r\n    updateGroupOpacity: function( node, group ) {\r\n      var opacity;\r\n      if ( node === this.baseNode ) {\r\n        opacity = this.baseTrail.getOpacity(); // multiplied by opacities of all ancestors\r\n      } else {\r\n        opacity = node.getOpacity();\r\n      }\r\n      group.setAttribute( 'opacity', opacity );\r\n    },\r\n    \r\n    getFragmentFromInstance: function( instance ) {\r\n      // TODO: performance: key optimization point for SVG layers\r\n      return this.idFragmentMap[instance.trail.getUniqueId()];\r\n    },\r\n    \r\n    getGroupFromInstance: function( instance ) {\r\n      // TODO: performance: key optimization point for SVG layers\r\n      return this.idGroupMap[instance.trail.getUniqueId()];\r\n    },\r\n    \r\n    applyTransform: function( transform, group ) {\r\n      if ( transform.isIdentity() ) {\r\n        if ( group.hasAttribute( 'transform' ) ) {\r\n          group.removeAttribute( 'transform' );\r\n        }\r\n      } else {\r\n        group.setAttribute( 'transform', transform.getMatrix().getSVGTransform() );\r\n      }\r\n    },\r\n    \r\n    render: function( scene, args ) {\r\n      this.refreshBaseTransform();\r\n    },\r\n    \r\n    refreshBaseTransform: function() {\r\n      if ( this.baseTransformDirty ) {\r\n        // this will be run either now or at the end of flushing changes\r\n        var includesBaseTransformChange = this.baseTransformChange;\r\n        this.updateBaseTransform( includesBaseTransformChange );\r\n        \r\n        this.baseTransformDirty = false;\r\n        this.baseTransformChange = false;\r\n      }\r\n    },\r\n    \r\n    dispose: function() {\r\n      Layer.prototype.dispose.call( this );\r\n      \r\n      this.svg.parentNode.removeChild( this.svg );\r\n    },\r\n    \r\n    markBaseTransformDirty: function( changed ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' markBaseTransformDirty' );\r\n      var baseTransformChange = this.baseTransformChange || !!changed;\r\n      this.baseTransformDirty = true;\r\n      this.baseTransformChange = baseTransformChange;\r\n    },\r\n    \r\n    initializeBase: function() {\r\n      // we don't want to call updateBaseTransform() twice, since baseNodeInternalBoundsChange() will call it if we use CSS transform\r\n      if ( this.cssTransform ) {\r\n        this.baseNodeInternalBoundsChange();\r\n      } else {\r\n        this.markBaseTransformDirty( true );\r\n      }\r\n    },\r\n    \r\n    // called when the base node's \"internal\" (self or child) bounds change, but not when it is just from the base node's own transform changing\r\n    baseNodeInternalBoundsChange: function() {\r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' baseNodeInternalBoundsChange' );\r\n      if ( this.cssTransform ) {\r\n        // we want to set the baseNodeTransform to a translation so that it maps the baseNode's self/children in the baseNode's local bounds to (0,0,w,h)\r\n        var internalBounds = this.baseNode.parentToLocalBounds( this.baseNode.getBounds() );\r\n        var padding = scenery.Layer.cssTransformPadding;\r\n        \r\n        // if there is nothing, or the bounds are empty for some reason, skip this!\r\n        if ( !internalBounds.isEmpty() ) {\r\n          this.baseNodeTransform.set( Matrix3.translation( Math.ceil( -internalBounds.minX + padding), Math.ceil( -internalBounds.minY + padding ) ) );\r\n          var baseNodeInteralBounds = this.baseNodeTransform.transformBounds2( internalBounds );\r\n          \r\n          // sanity check to ensure we are within that range\r\n          sceneryAssert && sceneryAssert( baseNodeInteralBounds.minX >= 0 && baseNodeInteralBounds.minY >= 0 );\r\n          \r\n          this.updateContainerDimensions( Math.ceil( baseNodeInteralBounds.maxX + padding ),\r\n                                          Math.ceil( baseNodeInteralBounds.maxY + padding ) );\r\n        }\r\n        \r\n        // if this gets removed, update initializeBase()\r\n        this.markBaseTransformDirty( true );\r\n      } else if ( this.usesPartialCSSTransforms ) {\r\n        this.markBaseTransformDirty( true );\r\n      }\r\n    },\r\n    \r\n    updateContainerDimensions: function( width, height ) {\r\n      this.svg.setAttribute( 'width', width );\r\n      this.svg.setAttribute( 'height', height );\r\n    },\r\n    \r\n    updateBaseTransform: function( includesBaseTransformChange ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' updateBaseTransform' );\r\n      var transform = this.baseTrail.getTransform(); // TODO: consider improving this, CSS+SVG bottleneck\r\n      \r\n      if ( this.cssTransform ) {\r\n        // set the full transform!\r\n        scenery.Util.applyCSSTransform( transform.getMatrix().timesMatrix( this.baseNodeTransform.getInverse() ), this.svg );\r\n        \r\n        if ( includesBaseTransformChange ) {\r\n          this.applyTransform( this.baseNodeTransform, this.g );\r\n        }\r\n      } else if ( this.usesPartialCSSTransforms ) {\r\n        // calculate what our CSS transform should be\r\n        var cssTransform = new Transform3();\r\n        var matrix = transform.getMatrix();\r\n        if ( this.cssTranslation ) {\r\n          cssTransform.append( Matrix3.translation( matrix.m02(), matrix.m12() ) );\r\n        }\r\n        if ( this.cssRotation ) {\r\n          cssTransform.append( Matrix3.rotation2( matrix.getRotation() ) );\r\n        }\r\n        if ( this.cssScale ) {\r\n          var scaleVector = matrix.getScaleVector();\r\n          cssTransform.append( Matrix3.scaling( scaleVector.x, scaleVector.y ) );\r\n        }\r\n        \r\n        // take the CSS transform out of what we will apply to the group\r\n        transform.prepend( cssTransform.getInverse() );\r\n        \r\n        // now we need to see where our baseNode bounds are mapped to with our transform,\r\n        // so that we can apply an extra translation and adjust dimensions as necessary\r\n        var padding = scenery.Layer.cssTransformPadding;\r\n        var internalBounds = this.baseNode.parentToLocalBounds( this.baseNode.getBounds() );\r\n        var mappedBounds = transform.transformBounds2( internalBounds );\r\n        var translation = Matrix3.translation( Math.ceil( -mappedBounds.minX + padding ), Math.ceil( -mappedBounds.minY + padding ) );\r\n        var inverseTranslation = translation.inverted();\r\n        this.updateContainerDimensions( Math.ceil( mappedBounds.getWidth()  + 2 * padding ),\r\n                                        Math.ceil( mappedBounds.getHeight() + 2 * padding ) );\r\n        \r\n        // put the translation adjustment and its inverse in-between the two transforms\r\n        cssTransform.append( inverseTranslation );\r\n        transform.prepend( translation );\r\n        \r\n        // apply the transforms\r\n        // TODO: checks to make sure we don't apply them in a row if one didn't change!\r\n        scenery.Util.applyCSSTransform( cssTransform.getMatrix(), this.svg );\r\n        this.applyTransform( transform, this.g );\r\n      } else {\r\n        this.applyTransform( transform, this.g );\r\n      }\r\n    },\r\n    \r\n    // TODO: consider a stack-based model for transforms?\r\n    applyTransformationMatrix: function( matrix ) {\r\n      // nothing at all needed here\r\n    },\r\n    \r\n    getContainer: function() {\r\n      return this.svg;\r\n    },\r\n    \r\n    // returns next zIndex in place. allows layers to take up more than one single zIndex\r\n    reindex: function( zIndex ) {\r\n      Layer.prototype.reindex.call( this, zIndex );\r\n      \r\n      if ( this.zIndex !== zIndex ) {\r\n        this.svg.style.zIndex = zIndex;\r\n        this.zIndex = zIndex;\r\n      }\r\n      return zIndex + 1;\r\n    },\r\n    \r\n    pushClipShape: function( shape ) {\r\n      // TODO: clipping\r\n    },\r\n    \r\n    popClipShape: function() {\r\n      // TODO: clipping\r\n    },\r\n    \r\n    getSVGString: function() {\r\n      // TODO: jQuery seems to be stripping namespaces, so figure that one out?\r\n      return $( '<div>' ).append( this.$svg.clone() ).html();\r\n      \r\n      // also note:\r\n      // var doc = document.implementation.createHTMLDocument(\"\");\r\n      // doc.write(html);\r\n       \r\n      // // You must manually set the xmlns if you intend to immediately serialize the HTML\r\n      // // document to a string as opposed to appending it to a <foreignObject> in the DOM\r\n      // doc.documentElement.setAttribute(\"xmlns\", doc.documentElement.namespaceURI);\r\n       \r\n      // // Get well-formed markup\r\n      // html = (new XMLSerializer).serializeToString(doc);\r\n    },\r\n    \r\n    // TODO: note for DOM we can do https://developer.mozilla.org/en-US/docs/HTML/Canvas/Drawing_DOM_objects_into_a_canvas\r\n    renderToCanvas: function( canvas, context, delayCounts ) {\r\n      // temporarily put the full transform on the containing group so the rendering is correct (CSS transforms can take this away)\r\n      this.applyTransform( this.baseTrail.getTransform(), this.g );\r\n      \r\n      if ( window.canvg ) {\r\n        delayCounts.increment();\r\n        \r\n        // TODO: if we are using CSS3 transforms, run that here\r\n        canvg( canvas, this.getSVGString(), {\r\n          ignoreMouse: true,\r\n          ignoreAnimation: true,\r\n          ignoreDimensions: true,\r\n          ignoreClear: true,\r\n          renderCallback: function() {\r\n            delayCounts.decrement();\r\n          }\r\n        } );\r\n      } else {\r\n        // will not work on Internet Explorer 9/10\r\n        \r\n        // TODO: very much not convinced that this is better than setting src of image\r\n        var DOMURL = window.URL || window.webkitURL || window;\r\n        var img = new Image();\r\n        var raw = this.getSVGString();\r\n        console.log( raw );\r\n        var svg = new Blob( [ raw ] , { type: \"image/svg+xml;charset=utf-8\" } );\r\n        var url = DOMURL.createObjectURL( svg );\r\n        delayCounts.increment();\r\n        img.onload = function() {\r\n          context.drawImage( img, 0, 0 );\r\n          // TODO: this loading is delayed!!! ... figure out a solution to potentially delay?\r\n          DOMURL.revokeObjectURL( url );\r\n          delayCounts.decrement();\r\n        };\r\n        img.src = url;\r\n        \r\n        throw new Error( 'this implementation hits Chrome bugs, won\\'t work on IE9/10, etc. deprecated' );\r\n      }\r\n      \r\n      // revert the transform damage that we did to our base group\r\n      this.updateBaseTransform();\r\n    },\r\n    \r\n    getName: function() {\r\n      return 'svg';\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Events from Instances\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    notifyVisibilityChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyVisibilityChange: ' + instance.trail.toString() );\r\n      var group = this.getGroupFromInstance( instance );\r\n      if ( group ) {\r\n        this.updateGroupVisibility( instance.getNode(), group );\r\n      } else if ( this.baseNode !== this.scene ) {\r\n        // if we are using a CSS transform (basically)\r\n        this.updateGroupVisibility( this.baseNode, this.getGroupFromInstance( this.baseTrail.getInstance() ) );\r\n      }\r\n    },\r\n    \r\n    notifyOpacityChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyOpacityChange: ' + instance.trail.toString() );\r\n      var group = this.getGroupFromInstance( instance );\r\n      if ( group ) {\r\n        this.updateGroupOpacity( instance.getNode(), group );\r\n      } else if ( this.baseNode !== this.scene ) {\r\n        // if we are using a CSS transform (basically)\r\n        this.updateGroupOpacity( this.baseNode, this.getGroupFromInstance( this.baseTrail.getInstance() ) );\r\n      }\r\n    },\r\n    \r\n    // only a painted trail under this layer\r\n    notifyBeforeSelfChange: function( instance ) {\r\n      // sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyBeforeSelfChange: ' + instance.trail.toString() );\r\n      // no-op, we don't need paint changes\r\n    },\r\n    \r\n    notifyBeforeSubtreeChange: function( instance ) {\r\n      // sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyBeforeSubtreeChange: ' + instance.trail.toString() );\r\n      // no-op, we don't need paint changes\r\n    },\r\n    \r\n    // only a painted trail under this layer\r\n    notifyDirtySelfPaint: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyDirtySelfPaint: ' + instance.trail.toString() );\r\n      var fragment = this.getFragmentFromInstance( instance );\r\n      \r\n      if ( fragment ) {\r\n        var node = instance.getNode();\r\n        \r\n        if ( node.updateSVGFragment ) {\r\n          // TODO: performance: don't re-do all of the fragment here! intelligent updating?\r\n          node.updateSVGFragment( fragment );\r\n        }\r\n        if ( node.updateSVGDefs ) {\r\n          // TODO: performance: don't re-do all of the defs here! intelligent updating?\r\n          node.updateSVGDefs( this.svg, this.defs );\r\n        }\r\n      }\r\n    },\r\n    \r\n    notifyDirtySubtreePaint: function( instance ) {\r\n      // TODO: performance: this caused a 50% increase for the fast-svg transform steps, what were we missing?\r\n      if ( instance.layer === this ) {\r\n        this.notifyDirtySelfPaint( instance );\r\n      }\r\n    },\r\n    \r\n    notifyTransformChange: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyTransformChange: ' + instance.trail.toString() );\r\n      var node = instance.node;\r\n      var trail = instance.trail;\r\n      \r\n      if ( trail.lastNode() === this.baseNode ) {\r\n        // our trail points to the base node. handle this case as special\r\n        this.markBaseTransformDirty();\r\n      } else if ( _.contains( trail.nodes, this.baseNode ) ) { // TODO: performance: this linear scan looks slower than needed\r\n        var group = this.idGroupMap[trail.getUniqueId()];\r\n        \r\n        // apply the transform to the group\r\n        this.applyTransform( node.getTransform(), group );\r\n      } else {\r\n        // ancestor node changed a transform. rebuild the base transform\r\n        this.markBaseTransformDirty();\r\n      }\r\n    },\r\n    \r\n    // only a painted trail under this layer (for now)\r\n    notifyBoundsAccuracyChange: function( instance ) {\r\n      // sceneryLayerLog && sceneryLayerLog( 'SVGLayer #' + this.id + ' notifyBoundsAccuracyChange: ' + instance.trail.toString() );\r\n      // no-op, we don't care about bounds\r\n    }\r\n    \r\n  } );\r\n  \r\n  return SVGLayer;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * An enumeration of different back-end technologies used for rendering. It also essentially\r\n * represents the API that nodes need to implement to be used with this specified back-end.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/layers/Renderer',['require','SCENERY/scenery','SCENERY/layers/LayerType','SCENERY/layers/CanvasLayer','SCENERY/layers/DOMLayer','SCENERY/layers/SVGLayer'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  require( 'SCENERY/layers/LayerType' );\r\n  require( 'SCENERY/layers/CanvasLayer' );\r\n  require( 'SCENERY/layers/DOMLayer' );\r\n  require( 'SCENERY/layers/SVGLayer' );\r\n  \r\n  // cached defaults\r\n  var defaults = {};\r\n  \r\n  scenery.Renderer = function Renderer( layerConstructor, name, defaultOptions ) {\r\n    this.layerConstructor = layerConstructor;\r\n    this.name = name;\r\n    this.defaultOptions = defaultOptions;\r\n    \r\n    this.defaultLayerType = this.createLayerType( {} ); // default options are handled in createLayerType\r\n  };\r\n  var Renderer = scenery.Renderer;\r\n  \r\n  Renderer.prototype = {\r\n    constructor: Renderer,\r\n    \r\n    createLayerType: function( rendererOptions ) {\r\n      return new scenery.LayerType( this.layerConstructor, this.name, this, _.extend( {}, this.defaultOptions, rendererOptions ) );\r\n    }\r\n  };\r\n  \r\n  Renderer.Canvas = new Renderer( scenery.CanvasLayer, 'canvas', {} );\r\n  Renderer.DOM = new Renderer( scenery.DOMLayer, 'dom', {} );\r\n  Renderer.SVG = new Renderer( scenery.SVGLayer, 'svg', {} );\r\n  \r\n  // add shortcuts for the default layer types\r\n  scenery.CanvasDefaultLayerType = Renderer.Canvas.defaultLayerType;\r\n  scenery.DOMDefaultLayerType    = Renderer.DOM.defaultLayerType;\r\n  scenery.SVGDefaultLayerType    = Renderer.SVG.defaultLayerType;\r\n  \r\n  // and shortcuts so we can index in with shorthands like 'svg', 'dom', etc.\r\n  Renderer.canvas = Renderer.Canvas;\r\n  Renderer.dom = Renderer.DOM;\r\n  Renderer.svg = Renderer.SVG;\r\n  Renderer.webgl = Renderer.WebGL;\r\n  \r\n  return Renderer;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Mix-in for nodes that support a standard fill.\r\n *\r\n * TODO: pattern and gradient handling\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/nodes/Fillable',['require','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  scenery.Fillable = function Fillable( type ) {\r\n    var proto = type.prototype;\r\n    \r\n    // this should be called in the constructor to initialize\r\n    proto.initializeFillable = function() {\r\n      this._fill = null;\r\n      \r\n      var that = this;\r\n      this._fillListener = function() {\r\n        that.invalidatePaint(); // TODO: move this to invalidateFill?\r\n        that.invalidateFill();\r\n      };\r\n    };\r\n    \r\n    proto.hasFill = function() {\r\n      return this._fill !== null;\r\n    };\r\n    \r\n    proto.getFill = function() {\r\n      return this._fill;\r\n    };\r\n    \r\n    proto.setFill = function( fill ) {\r\n      if ( this.getFill() !== fill ) {\r\n        var hasInstances = this._instances.length > 0;\r\n        \r\n        if ( hasInstances && this._fill && this._fill.removeChangeListener ) {\r\n          this._fill.removeChangeListener( this._fillListener );\r\n        }\r\n        \r\n        this._fill = fill;\r\n        \r\n        if ( hasInstances && this._fill && this._fill.addChangeListener ) {\r\n          this._fill.addChangeListener( this._fillListener );\r\n        }\r\n        \r\n        this.invalidatePaint();\r\n        \r\n        this.invalidateFill();\r\n      }\r\n      return this;\r\n    };\r\n    \r\n    var superFirstInstanceAdded = proto.firstInstanceAdded;\r\n    proto.firstInstanceAdded = function() {\r\n      if ( this._fill && this._fill.addChangeListener ) {\r\n        this._fill.addChangeListener( this._fillListener );\r\n      }\r\n      \r\n      if ( superFirstInstanceAdded ) {\r\n        superFirstInstanceAdded.call( this );\r\n      }\r\n    };\r\n    \r\n    var superLastInstanceRemoved = proto.lastInstanceRemoved;\r\n    proto.lastInstanceRemoved = function() {\r\n      if ( this._fill && this._fill.removeChangeListener ) {\r\n        this._fill.removeChangeListener( this._fillListener );\r\n      }\r\n      \r\n      if ( superLastInstanceRemoved ) {\r\n        superLastInstanceRemoved.call( this );\r\n      }\r\n    };\r\n    \r\n    proto.beforeCanvasFill = function( wrapper ) {\r\n      wrapper.setFillStyle( this._fill );\r\n      if ( this._fill.transformMatrix ) {\r\n        wrapper.context.save();\r\n        this._fill.transformMatrix.canvasAppendTransform( wrapper.context );\r\n      }\r\n    };\r\n    \r\n    proto.afterCanvasFill = function( wrapper ) {\r\n      if ( this._fill.transformMatrix ) {\r\n        wrapper.context.restore();\r\n      }\r\n    };\r\n    \r\n    proto.getSVGFillStyle = function() {\r\n      var style = 'fill: ';\r\n      if ( !this._fill ) {\r\n        // no fill\r\n        style += 'none;';\r\n      } else if ( this._fill.toCSS ) {\r\n        // Color object fill\r\n        style += this._fill.toCSS() + ';';\r\n      } else if ( this._fill.getSVGDefinition ) {\r\n        // reference the SVG definition with a URL\r\n        style += 'url(#fill' + this.getId() + ');';\r\n      } else {\r\n        // plain CSS color\r\n        style += this._fill + ';';\r\n      }\r\n      return style;\r\n    };\r\n    \r\n    proto.isFillDOMCompatible = function() {\r\n      // make sure we're not a pattern or gradient\r\n      return !this._fill || !this._fill.getSVGDefinition;\r\n    };\r\n    \r\n    proto.getCSSFill = function() {\r\n      sceneryAssert && sceneryAssert( this.isFillDOMCompatible() );\r\n      \r\n      // if it's a Color object, get the corresponding CSS\r\n      // 'transparent' will make us invisible if the fill is null\r\n      return this._fill ? ( this._fill.toCSS ? this._fill.toCSS() : this._fill ) : 'transparent';\r\n    };\r\n    \r\n    proto.addSVGFillDef = function( svg, defs ) {\r\n      var fill = this.getFill();\r\n      var fillId = 'fill' + this.getId();\r\n      \r\n      // add new definitions if necessary\r\n      if ( fill && fill.getSVGDefinition ) {\r\n        defs.appendChild( fill.getSVGDefinition( fillId ) );\r\n      }\r\n    };\r\n    \r\n    proto.removeSVGFillDef = function( svg, defs ) {\r\n      var fillId = 'fill' + this.getId();\r\n      \r\n      // wipe away any old definition\r\n      var oldFillDef = svg.getElementById( fillId );\r\n      if ( oldFillDef ) {\r\n        defs.removeChild( oldFillDef );\r\n      }\r\n    };\r\n    \r\n    proto.appendFillablePropString = function( spaces, result ) {\r\n      if ( this._fill ) {\r\n        if ( result ) {\r\n          result += ',\\n';\r\n        }\r\n        if ( typeof this._fill === 'string' ) {\r\n          result += spaces + 'fill: \\'' + this._fill + '\\'';\r\n        } else {\r\n          result += spaces + 'fill: ' + this._fill.toString();\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    };\r\n    \r\n    // on mutation, set the fill parameter first\r\n    proto._mutatorKeys = [ 'fill' ].concat( proto._mutatorKeys );\r\n    \r\n    Object.defineProperty( proto, 'fill', { set: proto.setFill, get: proto.getFill } );\r\n    \r\n    if ( !proto.invalidateFill ) {\r\n      proto.invalidateFill = function() {\r\n        // override if fill handling is necessary (TODO: mixins!)\r\n      };\r\n    }\r\n  };\r\n  var Fillable = scenery.Fillable;\r\n  \r\n  return Fillable;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Mix-in for nodes that support a standard stroke.\r\n *\r\n * TODO: miterLimit handling\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/nodes/Strokable',['require','SCENERY/scenery','KITE/util/LineStyles'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  var LineStyles = require( 'KITE/util/LineStyles' );\r\n  \r\n  scenery.Strokable = function Strokable( type ) {\r\n    var proto = type.prototype;\r\n    \r\n    // this should be called in the constructor to initialize\r\n    proto.initializeStrokable = function() {\r\n      this._stroke = null;\r\n      this._lineDrawingStyles = new LineStyles();\r\n      \r\n      var that = this;\r\n      this._strokeListener = function() {\r\n        that.invalidatePaint(); // TODO: move this to invalidateStroke?\r\n        that.invalidateStroke();\r\n      };\r\n    };\r\n    \r\n    proto.hasStroke = function() {\r\n      return this._stroke !== null;\r\n    };\r\n    \r\n    // TODO: setting these properties looks like a good candidate for refactoring to lessen file size\r\n    proto.getLineWidth = function() {\r\n      return this._lineDrawingStyles.lineWidth;\r\n    };\r\n    \r\n    proto.setLineWidth = function( lineWidth ) {\r\n      if ( this.getLineWidth() !== lineWidth ) {\r\n        this.markOldSelfPaint(); // since the previous line width may have been wider\r\n        \r\n        this._lineDrawingStyles.lineWidth = lineWidth;\r\n        \r\n        this.invalidateStroke();\r\n      }\r\n      return this;\r\n    };\r\n    \r\n    proto.getLineCap = function() {\r\n      return this._lineDrawingStyles.lineCap;\r\n    };\r\n    \r\n    proto.setLineCap = function( lineCap ) {\r\n      if ( this._lineDrawingStyles.lineCap !== lineCap ) {\r\n        this.markOldSelfPaint();\r\n        \r\n        this._lineDrawingStyles.lineCap = lineCap;\r\n        \r\n        this.invalidateStroke();\r\n      }\r\n      return this;\r\n    };\r\n    \r\n    proto.getLineJoin = function() {\r\n      return this._lineDrawingStyles.lineJoin;\r\n    };\r\n    \r\n    proto.setLineJoin = function( lineJoin ) {\r\n      if ( this._lineDrawingStyles.lineJoin !== lineJoin ) {\r\n        this.markOldSelfPaint();\r\n        \r\n        this._lineDrawingStyles.lineJoin = lineJoin;\r\n        \r\n        this.invalidateStroke();\r\n      }\r\n      return this;\r\n    };\r\n    \r\n    proto.getLineDash = function() {\r\n      return this._lineDrawingStyles.lineDash;\r\n    };\r\n    \r\n    proto.setLineDash = function( lineDash ) {\r\n      if ( this._lineDrawingStyles.lineDash !== lineDash ) {\r\n        this.markOldSelfPaint();\r\n        \r\n        this._lineDrawingStyles.lineDash = lineDash;\r\n        \r\n        this.invalidateStroke();\r\n      }\r\n      return this;\r\n    };\r\n    \r\n    proto.getLineDashOffset = function() {\r\n      return this._lineDrawingStyles.lineDashOffset;\r\n    };\r\n    \r\n    proto.setLineDashOffset = function( lineDashOffset ) {\r\n      if ( this._lineDrawingStyles.lineDashOffset !== lineDashOffset ) {\r\n        this.markOldSelfPaint();\r\n        \r\n        this._lineDrawingStyles.lineDashOffset = lineDashOffset;\r\n        \r\n        this.invalidateStroke();\r\n      }\r\n      return this;\r\n    };\r\n    \r\n    proto.setLineStyles = function( lineStyles ) {\r\n      // TODO: since we have been using lineStyles as mutable for now, lack of change check is good here?\r\n      this.markOldSelfPaint();\r\n      \r\n      this._lineDrawingStyles = lineStyles;\r\n      this.invalidateStroke();\r\n      return this;\r\n    };\r\n    \r\n    proto.getLineStyles = function() {\r\n      return this._lineDrawingStyles;\r\n    };\r\n    \r\n    proto.getStroke = function() {\r\n      return this._stroke;\r\n    };\r\n    \r\n    proto.setStroke = function( stroke ) {\r\n      if ( this.getStroke() !== stroke ) {\r\n        // since this can actually change the bounds, we need to handle a few things differently than the fill\r\n        this.markOldSelfPaint();\r\n        \r\n        var hasInstances = this._instances.length > 0;\r\n        \r\n        if ( hasInstances && this._stroke && this._stroke.removeChangeListener ) {\r\n          this._stroke.removeChangeListener( this._strokeListener );\r\n        }\r\n        \r\n        this._stroke = stroke;\r\n        \r\n        if ( hasInstances && this._stroke && this._stroke.addChangeListener ) {\r\n          this._stroke.addChangeListener( this._strokeListener );\r\n        }\r\n        \r\n        this.invalidateStroke();\r\n      }\r\n      return this;\r\n    };\r\n    \r\n    var superFirstInstanceAdded = proto.firstInstanceAdded;\r\n    proto.firstInstanceAdded = function() {\r\n      if ( this._stroke && this._stroke.addChangeListener ) {\r\n        this._stroke.addChangeListener( this._strokeListener );\r\n      }\r\n      \r\n      if ( superFirstInstanceAdded ) {\r\n        superFirstInstanceAdded.call( this );\r\n      }\r\n    };\r\n    \r\n    var superLastInstanceRemoved = proto.lastInstanceRemoved;\r\n    proto.lastInstanceRemoved = function() {\r\n      if ( this._stroke && this._stroke.removeChangeListener ) {\r\n        this._stroke.removeChangeListener( this._strokeListener );\r\n      }\r\n      \r\n      if ( superLastInstanceRemoved ) {\r\n        superLastInstanceRemoved.call( this );\r\n      }\r\n    };\r\n    \r\n    proto.beforeCanvasStroke = function( wrapper ) {\r\n      // TODO: is there a better way of not calling so many things on each stroke?\r\n      wrapper.setStrokeStyle( this._stroke );\r\n      wrapper.setLineWidth( this.getLineWidth() );\r\n      wrapper.setLineCap( this.getLineCap() );\r\n      wrapper.setLineJoin( this.getLineJoin() );\r\n      wrapper.setLineDash( this.getLineDash() );\r\n      wrapper.setLineDashOffset( this.getLineDashOffset() );\r\n      if ( this._stroke.transformMatrix ) {\r\n        wrapper.context.save();\r\n        this._stroke.transformMatrix.canvasAppendTransform( wrapper.context );\r\n      }\r\n    };\r\n    \r\n    proto.afterCanvasStroke = function( wrapper ) {\r\n      if ( this._stroke.transformMatrix ) {\r\n        wrapper.context.restore();\r\n      }\r\n    };\r\n    \r\n    proto.getSVGStrokeStyle = function() {\r\n      if ( !this._stroke ) {\r\n        // no stroke\r\n        return 'stroke: none;';\r\n      }\r\n      \r\n      var style = 'stroke: ';\r\n      if ( this._stroke.toCSS ) {\r\n        // Color object stroke\r\n        style += this._stroke.toCSS() + ';';\r\n      } else if ( this._stroke.getSVGDefinition ) {\r\n        // reference the SVG definition with a URL\r\n        style += 'url(#stroke' + this.getId() + ');';\r\n      } else {\r\n        // plain CSS color\r\n        style += this._stroke + ';';\r\n      }\r\n      \r\n      // TODO: don't include unnecessary directives? - is it worth any branching cost?\r\n      style += 'stroke-width: ' + this.getLineWidth() + ';';\r\n      style += 'stroke-linecap: ' + this.getLineCap() + ';';\r\n      style += 'stroke-linejoin: ' + this.getLineJoin() + ';';\r\n      if ( this.getLineDash() ) {\r\n        style += 'stroke-dasharray: ' + this.getLineDash().join( ',' ) + ';';\r\n        style += 'stroke-dashoffset: ' + this.getLineDashOffset() + ';';\r\n      }\r\n      \r\n      return style;\r\n    };\r\n    \r\n    proto.addSVGStrokeDef = function( svg, defs ) {\r\n      var stroke = this.getStroke();\r\n      var strokeId = 'stroke' + this.getId();\r\n      \r\n      // add new definitions if necessary\r\n      if ( stroke && stroke.getSVGDefinition ) {\r\n        defs.appendChild( stroke.getSVGDefinition( strokeId ) );\r\n      }\r\n    };\r\n    \r\n    proto.removeSVGStrokeDef = function( svg, defs ) {\r\n      var strokeId = 'stroke' + this.getId();\r\n      \r\n      // wipe away any old definition\r\n      var oldStrokeDef = svg.getElementById( strokeId );\r\n      if ( oldStrokeDef ) {\r\n        defs.removeChild( oldStrokeDef );\r\n      }\r\n    };\r\n    \r\n    proto.appendStrokablePropString = function( spaces, result ) {\r\n      var self = this;\r\n      \r\n      function addProp( key, value, nowrap ) {\r\n        if ( result ) {\r\n          result += ',\\n';\r\n        }\r\n        if ( !nowrap && typeof value === 'string' ) {\r\n          result += spaces + key + ': \\'' + value + '\\'';\r\n        } else {\r\n          result += spaces + key + ': ' + value;\r\n        }\r\n      }\r\n      \r\n      if ( this._stroke ) {\r\n        var defaultStyles = new LineStyles();\r\n        if ( typeof this._stroke === 'string' ) {\r\n          addProp( 'stroke', this._stroke );\r\n        } else {\r\n          addProp( 'stroke', this._stroke.toString(), true );\r\n        }\r\n        \r\n        _.each( [ 'lineWidth', 'lineCap', 'lineJoin', 'lineDashOffset' ], function( prop ) {\r\n          if ( self[prop] !== defaultStyles[prop] ) {\r\n            addProp( prop, self[prop] );\r\n          }\r\n        } );\r\n        \r\n        if ( this.lineDash ) {\r\n          addProp( 'lineDash', JSON.stringify( this.lineDash ), true );\r\n        }\r\n      }\r\n      \r\n      return result;\r\n    };\r\n    \r\n    // on mutation, set the stroke parameters first since they may affect the bounds (and thus later operations)\r\n    proto._mutatorKeys = [ 'stroke', 'lineWidth', 'lineCap', 'lineJoin', 'lineDash', 'lineDashOffset' ].concat( proto._mutatorKeys );\r\n    \r\n    // TODO: miterLimit support?\r\n    Object.defineProperty( proto, 'stroke', { set: proto.setStroke, get: proto.getStroke } );\r\n    Object.defineProperty( proto, 'lineWidth', { set: proto.setLineWidth, get: proto.getLineWidth } );\r\n    Object.defineProperty( proto, 'lineCap', { set: proto.setLineCap, get: proto.getLineCap } );\r\n    Object.defineProperty( proto, 'lineJoin', { set: proto.setLineJoin, get: proto.getLineJoin } );\r\n    Object.defineProperty( proto, 'lineDash', { set: proto.setLineDash, get: proto.getLineDash } );\r\n    Object.defineProperty( proto, 'lineDashOffset', { set: proto.setLineDashOffset, get: proto.getLineDashOffset } );\r\n    \r\n    if ( !proto.invalidateStroke ) {\r\n      proto.invalidateStroke = function() {\r\n        // override if stroke handling is necessary (TODO: mixins!)\r\n      };\r\n    }\r\n  };\r\n  var Strokable = scenery.Strokable;\r\n  \r\n  return Strokable;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * A Path draws a Shape with a specific type of fill and stroke.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/nodes/Path',['require','PHET_CORE/inherit','KITE/Shape','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/nodes/Fillable','SCENERY/nodes/Strokable','SCENERY/util/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Renderer = require( 'SCENERY/layers/Renderer' );\r\n  var Fillable = require( 'SCENERY/nodes/Fillable' );\r\n  var Strokable = require( 'SCENERY/nodes/Strokable' );\r\n  var objectCreate = require( 'SCENERY/util/Util' ).objectCreate;\r\n  \r\n  scenery.Path = function Path( options ) {\r\n    // TODO: consider directly passing in a shape object (or at least handling that case)\r\n    this._shape = null;\r\n    \r\n    // ensure we have a parameter object\r\n    options = options || {};\r\n    \r\n    this.initializeFillable();\r\n    this.initializeStrokable();\r\n    \r\n    Node.call( this, options );\r\n  };\r\n  var Path = scenery.Path;\r\n  \r\n  inherit( Node, Path, {\r\n    // sets the shape drawn, or null to remove the shape\r\n    setShape: function( shape ) {\r\n      if ( this._shape !== shape ) {\r\n        if ( typeof shape === 'string' ) {\r\n          // be content with setShape always invalidating the shape?\r\n          shape = new Shape( shape );\r\n        }\r\n        this._shape = shape;\r\n        this.invalidateShape();\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    getShape: function() {\r\n      return this._shape;\r\n    },\r\n    \r\n    invalidateShape: function() {\r\n      this.markOldSelfPaint();\r\n      \r\n      if ( this.hasShape() ) {\r\n        this.invalidateSelf( this.computeShapeBounds() );\r\n        this.invalidatePaint();\r\n      }\r\n    },\r\n    \r\n    // separated out, so that we can override this with a faster version in Rectangle. includes the Stroke, if any\r\n    computeShapeBounds: function() {\r\n      return this._stroke ? this._shape.computeBounds( this._lineDrawingStyles ) : this._shape.bounds;\r\n    },\r\n    \r\n    // hook stroke mixin changes to invalidation\r\n    invalidateStroke: function() {\r\n      this.invalidateShape();\r\n    },\r\n    \r\n    hasShape: function() {\r\n      return this._shape !== null;\r\n    },\r\n    \r\n    paintCanvas: function( wrapper ) {\r\n      var context = wrapper.context;\r\n      \r\n      if ( this.hasShape() ) {\r\n        // TODO: fill/stroke delay optimizations?\r\n        context.beginPath();\r\n        this._shape.writeToContext( context );\r\n\r\n        if ( this._fill ) {\r\n          this.beforeCanvasFill( wrapper ); // defined in Fillable\r\n          context.fill();\r\n          this.afterCanvasFill( wrapper ); // defined in Fillable\r\n        }\r\n        if ( this._stroke ) {\r\n          this.beforeCanvasStroke( wrapper ); // defined in Strokable\r\n          context.stroke();\r\n          this.afterCanvasStroke( wrapper ); // defined in Strokable\r\n        }\r\n      }\r\n    },\r\n    \r\n    paintWebGL: function( state ) {\r\n      throw new Error( 'Path.prototype.paintWebGL unimplemented' );\r\n    },\r\n    \r\n    // svg element, the <defs> block, and the associated group for this node's transform\r\n    createSVGFragment: function( svg, defs, group ) {\r\n      return document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );\r\n    },\r\n    \r\n    updateSVGFragment: function( path ) {\r\n      var svgPath = this.hasShape() ? this._shape.getSVGPath() : \"\";\r\n      \r\n      // temporary workaround for https://bugs.webkit.org/show_bug.cgi?id=78980\r\n      // and http://code.google.com/p/chromium/issues/detail?id=231626 where even removing\r\n      // the attribute can cause this bug\r\n      if ( !svgPath ) { svgPath = 'M0 0'; }\r\n      \r\n      if ( svgPath ) {\r\n        // only set the SVG path if it's not the empty string\r\n        path.setAttribute( 'd', svgPath );\r\n      } else if ( path.hasAttribute( 'd' ) ) {\r\n        path.removeAttribute( 'd' );\r\n      }\r\n      \r\n      path.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );\r\n    },\r\n    \r\n    // support patterns, gradients, and anything else we need to put in the <defs> block\r\n    updateSVGDefs: function( svg, defs ) {\r\n      // remove old definitions if they exist\r\n      this.removeSVGDefs( svg, defs );\r\n      \r\n      // add new ones if applicable\r\n      this.addSVGFillDef( svg, defs );\r\n      this.addSVGStrokeDef( svg, defs );\r\n    },\r\n    \r\n    // cleans up references created with udpateSVGDefs()\r\n    removeSVGDefs: function( svg, defs ) {\r\n      this.removeSVGFillDef( svg, defs );\r\n      this.removeSVGStrokeDef( svg, defs );\r\n    },\r\n    \r\n    isPainted: function() {\r\n      return true;\r\n    },\r\n    \r\n    // override for computation of whether a point is inside the self content\r\n    // point is considered to be in the local coordinate frame\r\n    containsPointSelf: function( point ) {\r\n      if ( !this.hasShape() ) {\r\n        return false;\r\n      }\r\n      \r\n      var result = this._shape.containsPoint( point );\r\n      \r\n      // also include the stroked region in the hit area if applicable\r\n      if ( !result && this._includeStrokeInHitRegion && this.hasStroke() ) {\r\n        result = this._shape.getStrokedShape( this._lineDrawingStyles ).containsPoint( point );\r\n      }\r\n      return result;\r\n    },\r\n    \r\n    // whether this node's self intersects the specified bounds, in the local coordinate frame\r\n    intersectsBoundsSelf: function( bounds ) {\r\n      // TODO: should a shape's stroke be included?\r\n      return this.hasShape() ? this._shape.intersectsBounds( bounds ) : false;\r\n    },\r\n    \r\n    set shape( value ) { this.setShape( value ); },\r\n    get shape() { return this.getShape(); },\r\n    \r\n    getBasicConstructor: function( propLines ) {\r\n      return 'new scenery.Path( {' + propLines + '} )';\r\n    },\r\n    \r\n    getPropString: function( spaces, includeChildren ) {\r\n      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );\r\n      result = this.appendFillablePropString( spaces, result );\r\n      result = this.appendStrokablePropString( spaces, result );\r\n      if ( this._shape ) {\r\n        if ( result ) {\r\n          result += ',\\n';\r\n        }\r\n        result += spaces + 'shape: ' + this._shape.toString();\r\n      }\r\n      return result;\r\n    }\r\n  } );\r\n  \r\n  Path.prototype._mutatorKeys = [ 'shape' ].concat( Node.prototype._mutatorKeys );\r\n  \r\n  Path.prototype._supportedRenderers = [ Renderer.Canvas, Renderer.SVG ];\r\n  \r\n  // mix in fill/stroke handling code. for now, this is done after 'shape' is added to the mutatorKeys so that stroke parameters\r\n  // get set first\r\n  /* jshint -W064 */\r\n  Fillable( Path );\r\n  Strokable( Path );\r\n  \r\n  return Path;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * HBox arranges the child nodes horizontally, and they can be centered, left or right justified.\r\n * Horizontal spacing can be set as a constant or a function which depends on the adjacent nodes.\r\n * TODO: add an option (not enabled by default) to update layout when children or children bounds change\r\n *\r\n * @author Sam Reid\r\n */\r\n\r\ndefine( 'SCENERY/nodes/HBox',['require','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/util/Util'],function( require ) {\r\n  'use strict';\r\n\r\n  var scenery = require( 'SCENERY/scenery' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var objectCreate = require( 'SCENERY/util/Util' ).objectCreate; // i.e. Object.create\r\n\r\n  /**\r\n   *\r\n   * @param options Same as Node.constructor.options with the following additions:\r\n   *\r\n   * spacing: can be a number or a function.  If a number, then it will be the vertical spacing between each object.\r\n   *              If a function, then the function will have the signature function(top,bottom){} which returns the spacing between adjacent pairs of items.\r\n   * align:   How to line up the items horizontally.  One of 'center', 'top' or 'bottom'.  Defaults to 'center'.\r\n   *\r\n   * @constructor\r\n   */\r\n  scenery.HBox = function HBox( options ) {\r\n    // ensure we have a parameter object\r\n    this.options = options = _.extend( {\r\n      // defaults\r\n      spacing: function() { return 0; },\r\n      align: 'center'\r\n    }, options );\r\n\r\n    if ( typeof options.spacing === 'number' ) {\r\n      var spacingConstant = options.spacing;\r\n      options.spacing = function() { return spacingConstant; };\r\n    }\r\n\r\n    Node.call( this, options );\r\n    this.updateLayout();\r\n\r\n    //TODO: perhaps not all options must be passed to Node.call AND this.mutate.  On 7/17/2013, layout problems occurred when using only mutate() or only Node.call(this,options)\r\n    //See VBox.js\r\n    if ( options ) {\r\n      this.mutate( options );\r\n    }\r\n  };\r\n  var HBox = scenery.HBox;\r\n\r\n  HBox.prototype = objectCreate( Node.prototype );\r\n\r\n  HBox.prototype.updateLayout = function() {\r\n    var minY = _.min( _.map( this.children, function( child ) {return child.top;} ) );\r\n    var maxY = _.max( _.map( this.children, function( child ) {return child.top + child.height;} ) );\r\n    var centerY = (maxY + minY) / 2;\r\n\r\n    //Start at x=0 in the coordinate frame of this node.  Not possible to set this through the spacing option, instead just set it with the {y:number} option.\r\n    var x = 0;\r\n    for ( var i = 0; i < this.children.length; i++ ) {\r\n      var child = this.children[i];\r\n      child.left = x;\r\n\r\n      //Set the position horizontally\r\n      if ( this.options.align === 'top' ) {\r\n        child.top = minY;\r\n      }\r\n      else if ( this.options.align === 'bottom' ) {\r\n        child.bottom = maxY;\r\n      }\r\n      else {//default to center\r\n        child.centerY = centerY;\r\n      }\r\n\r\n      //Move to the next vertical position.\r\n      x += child.width + this.options.spacing( child, this.children[i + 1] );\r\n    }\r\n  };\r\n  HBox.prototype.constructor = HBox;\r\n\r\n  return HBox;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * VBox arranges the child nodes vertically, and they can be centered, left or right justified.\r\n * Vertical spacing can be set as a constant or a function which depends on the adjacent nodes.\r\n * TODO: add an option (not enabled by default) to update layout when children or children bounds change\r\n *\r\n * @author Sam Reid\r\n */\r\n\r\ndefine( 'SCENERY/nodes/VBox',['require','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/util/Util'],function( require ) {\r\n  'use strict';\r\n\r\n  var scenery = require( 'SCENERY/scenery' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var objectCreate = require( 'SCENERY/util/Util' ).objectCreate; // i.e. Object.create\r\n\r\n  /**\r\n   *\r\n   * @param options Same as Node.constructor.options with the following additions:\r\n   *\r\n   * spacing: can be a number or a function.  If a number, then it will be the vertical spacing between each object.\r\n   *              If a function, then the function will have the signature function(top,bottom){} which returns the spacing between adjacent pairs of items.\r\n   * align:   How to line up the items horizontally.  One of 'center', 'left' or 'right'.  Defaults to 'center'.\r\n   *\r\n   * @constructor\r\n   */\r\n  scenery.VBox = function VBox( options ) {\r\n    // ensure we have a parameter object\r\n    this.options = options = _.extend( {\r\n      // defaults\r\n      spacing: function() { return 0; },\r\n      align: 'center'\r\n    }, options );\r\n\r\n    if ( typeof options.spacing === 'number' ) {\r\n      var spacingConstant = options.spacing;\r\n      options.spacing = function() { return spacingConstant; };\r\n    }\r\n\r\n    Node.call( this, options );\r\n    this.updateLayout();\r\n\r\n    //TODO: perhaps not all options must be passed to Node.call AND this.mutate.  On 7/17/2013, layout problems occurred when using only mutate() or only Node.call(this,options)\r\n    //See HBox.js\r\n    if ( options ) {\r\n      this.mutate( options );\r\n    }\r\n  };\r\n  var VBox = scenery.VBox;\r\n\r\n  VBox.prototype = objectCreate( Node.prototype );\r\n\r\n  VBox.prototype.updateLayout = function() {\r\n    var minX = _.min( _.map( this.children, function( child ) {return child.left;} ) );\r\n    var maxX = _.max( _.map( this.children, function( child ) {return child.left + child.width;} ) );\r\n    var centerX = (maxX + minX) / 2;\r\n\r\n    //Start at y=0 in the coordinate frame of this node.  Not possible to set this through the spacing option, instead just set it with the {y:number} option.\r\n    var y = 0;\r\n    for ( var i = 0; i < this.children.length; i++ ) {\r\n      var child = this.children[i];\r\n      child.top = y;\r\n\r\n      //Set the position horizontally\r\n      if ( this.options.align === 'left' ) {\r\n        child.left = minX;\r\n      }\r\n      else if ( this.options.align === 'right' ) {\r\n        child.right = maxX;\r\n      }\r\n      else {//default to center\r\n        child.centerX = centerX;\r\n      }\r\n\r\n      //Move to the next vertical position.\r\n      y += child.height + this.options.spacing( child, this.children[i + 1] );\r\n    }\r\n  };\r\n  VBox.prototype.constructor = VBox;\r\n\r\n  return VBox;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Escaping of HTML content that will be placed in the body, inside an element as a node.\r\n *\r\n * This is NOT for escaping something in other HTML contexts, for example as an attribute value\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\ndefine( 'PHET_CORE/escapeHTML',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  return function escapeHTML( str ) {\r\n    // see https://www.owasp.org/index.php/XSS_(Cross_Site_Scripting)_Prevention_Cheat_Sheet\r\n    // HTML Entity Encoding\r\n    return str.replace( /&/g, '&amp;' )\r\n              .replace( /</g, '&lt;' )\r\n              .replace( />/g, '&gt;' )\r\n              .replace( /\\\"/g, '&quot;' )\r\n              .replace( /\\'/g, '&#x27;' )\r\n              .replace( /\\//g, '&#x2F;' );\r\n  };\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Font handling for text drawing\r\n *\r\n * Examples:\r\n * new scenery.Font().font                      // \"10px sans-serif\" (the default)\r\n * new scenery.Font( { family: 'serif' } ).font // \"10px serif\"\r\n * new scenery.Font( { weight: 'bold' } ).font  // \"bold 10px sans-serif\"\r\n * new scenery.Font( { size: 16 } ).font        // \"16px sans-serif\"\r\n * var font = new scenery.Font( {\r\n *   family: '\"Times New Roman\", serif',\r\n *   style: 'italic',\r\n *   lineHeight: 10\r\n * } );\r\n * font.font;                                   // \"italic 10px/10 'Times New Roman', serif\"\r\n * font.family;                                 // \"'Times New Roman', serif\"\r\n * font.weight;                                 // 400 (the default)\r\n *\r\n * Useful specs:\r\n * http://www.w3.org/TR/css3-fonts/\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/Font',['require','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  // constants used for detection (since styles/variants/weights/stretches can be mixed in the preamble of the shorthand string)\r\n  var styles = [ 'normal', 'italic', 'oblique' ];\r\n  var variants = [ 'normal', 'small-caps' ];\r\n  var weights = [ 'normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '700', '800', '900' ];\r\n  var stretches = [ 'normal', 'ultra-condensed', 'extra-condensed', 'condensed', 'semi-condensed', 'semi-expanded', 'expanded', 'extra-expanded', 'ultra-expanded' ];\r\n  \r\n  // size constants used for detection\r\n  var sizes = [ 'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large', 'larger', 'smaller' ];\r\n  \r\n  function castSize( size ) {\r\n    if ( typeof size === 'number' ) {\r\n      return size + 'px'; // add the pixels suffix by default for numbers\r\n    } else {\r\n      return size; // assume that it's a valid to-spec string\r\n    }\r\n  }\r\n  \r\n  scenery.Font = function Font( options ) {\r\n    // options from http://www.w3.org/TR/css3-fonts/\r\n    this._style = 'normal';      // normal | italic | oblique\r\n    this._variant = 'normal';    // normal | small-caps\r\n    this._weight = 'normal';     // normal | bold | bolder | lighter | 100 | 200 | 300 | 400 | 500 | 600 | 700 | 800 | 900\r\n    this._stretch = 'normal';    // normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded\r\n    this._size = '10px';         // <absolute-size> | <relative-size> | <length> | <percentage> -- unitless number interpreted as px. absolute suffixes: cm, mm, in, pt, pc, px. relative suffixes: em, ex, ch, rem, vw, vh, vmin, vmax.\r\n    this._lineHeight = 'normal'; // normal | <number> | <length> | <percentage> -- NOTE: Canvas spec forces line-height to normal\r\n    this._family = 'sans-serif'; // comma-separated list of families, including generic families (serif, sans-serif, cursive, fantasy, monospace). ideally escape with double-quotes\r\n    \r\n    // font  [ [ <‘font-style’> || <font-variant-css21> || <‘font-weight’> || <‘font-stretch’> ]? <‘font-size’> [ / <‘line-height’> ]? <‘font-family’> ] | caption | icon | menu | message-box | small-caption | status-bar\r\n    // <font-variant-css21> = [normal | small-caps]\r\n    \r\n    var type = typeof options;\r\n    if ( type === 'string' ) {\r\n      // parse a somewhat proper CSS3 form (not guaranteed to handle it precisely the same as browsers yet)\r\n      \r\n      // split based on whitespace allowed by CSS spec (more restrictive than regular regexp whitespace)\r\n      var tokens = _.filter( options.split( /[\\x09\\x0A\\x0C\\x0D\\x20]/ ), function( token ) { return token.length > 0; } );\r\n      \r\n      // pull tokens out until we reach something that doesn't match. that must be the font size (according to spec)\r\n      for ( var i = 0; i < tokens.length; i++ ) {\r\n        var token = tokens[i];\r\n        if ( token === 'normal' ) {\r\n          // nothing has to be done, everything already normal as default\r\n        } else if ( _.contains( styles, token ) ) {\r\n          sceneryAssert && sceneryAssert( this._style === 'normal', 'Style cannot be applied twice. Already set to \"' + this._style + '\", attempt to replace with \"' + token + '\"' );\r\n          this._style = token;\r\n        } else if ( _.contains( variants, token ) ) {\r\n          sceneryAssert && sceneryAssert( this._variant === 'normal', 'Variant cannot be applied twice. Already set to \"' + this._variant + '\", attempt to replace with \"' + token + '\"' );\r\n          this._variant = token;\r\n        } else if ( _.contains( weights, token ) ) {\r\n          sceneryAssert && sceneryAssert( this._weight === 'normal', 'Weight cannot be applied twice. Already set to \"' + this._weight + '\", attempt to replace with \"' + token + '\"' );\r\n          this._weight = token;\r\n        } else if ( _.contains( stretches, token ) ) {\r\n          sceneryAssert && sceneryAssert( this._stretch === 'normal', 'Stretch cannot be applied twice. Already set to \"' + this._stretch + '\", attempt to replace with \"' + token + '\"' );\r\n          this._stretch = token;\r\n        } else {\r\n          // not a style/variant/weight/stretch, must be a font size, possibly with an included line-height\r\n          var subtokens = token.split( /\\// ); // extract font size from any line-height\r\n          this._size = subtokens[0];\r\n          if ( subtokens[1] ) {\r\n            this._lineHeight = subtokens[1];\r\n          }\r\n          // all future tokens are guaranteed to be part of the font-family if it is given according to spec\r\n          this._family = tokens.slice( i + 1 ).join( ' ' );\r\n          break;\r\n        }\r\n      }\r\n    } else if ( type === 'object' ) {\r\n      if ( options.style !== undefined ) {\r\n        this._style = options.style;\r\n      }\r\n      if ( options.variant !== undefined ) {\r\n        this._variant = options.variant;\r\n      }\r\n      if ( options.weight !== undefined ) {\r\n        this._weight = '' + options.weight; // cast it to a string explicitly\r\n      }\r\n      if ( options.stretch !== undefined ) {\r\n        this._stretch = options.stretch;\r\n      }\r\n      if ( options.size !== undefined ) {\r\n        this._size = castSize( options.size );\r\n      }\r\n      if ( options.lineHeight !== undefined ) {\r\n        this._lineHeight = options.lineHeight;\r\n      }\r\n      if ( options.family !== undefined ) {\r\n        this._family = options.family;\r\n      }\r\n    }\r\n    \r\n    // sanity checks to prevent errors in interpretation or in the font shorthand usage\r\n    sceneryAssert && sceneryAssert( typeof this._style === 'string' &&\r\n                                    _.contains( styles, this._style ),\r\n                                    'Font style must be one of \"normal\", \"italic\", or \"oblique\"' );\r\n    sceneryAssert && sceneryAssert( typeof this._variant === 'string' &&\r\n                                    _.contains( variants, this._variant ),\r\n                                    'Font variant must be \"normal\" or \"small-caps\"' );\r\n    sceneryAssert && sceneryAssert( typeof this._weight === 'string' &&\r\n                                    _.contains( weights, this._weight ),\r\n                                    'Font weight must be one of \"normal\", \"bold\", \"bolder\", \"lighter\", \"100\", \"200\", \"300\", \"400\", \"500\", \"600\", \"700\", \"800\", or \"900\"' );\r\n    sceneryAssert && sceneryAssert( typeof this._stretch === 'string' &&\r\n                                    _.contains( stretches, this._stretch ),\r\n                                    'Font stretch must be one of \"normal\", \"ultra-condensed\", \"extra-condensed\", \"condensed\", \"semi-condensed\", \"semi-expanded\", \"expanded\", \"extra-expanded\", or \"ultra-expanded\"' );\r\n    sceneryAssert && sceneryAssert( typeof this._size === 'string' &&\r\n                                    !_.contains( [ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' ], this._size[this._size.length - 1] ),\r\n                                    'Font size must be either passed as a number (not a string, interpreted as px), or must contain a suffix for percentage, absolute or relative units, or an explicit size constant' );\r\n    sceneryAssert && sceneryAssert( typeof this._lineHeight === 'string' );\r\n    sceneryAssert && sceneryAssert( typeof this._family === 'string' );\r\n    \r\n    // initialize the shorthand font property (stored as _font)\r\n    this._font = this.computeShorthand();\r\n  };\r\n  var Font = scenery.Font;\r\n  \r\n  Font.prototype = {\r\n    constructor: Font,\r\n    \r\n    getFont:       function() { return this._font; },\r\n    getStyle:      function() { return this._style; },\r\n    getVariant:    function() { return this._variant; },\r\n    getWeight:     function() { return this._weight; },\r\n    getStretch:    function() { return this._stretch; },\r\n    getSize:       function() { return this._size; },\r\n    getLineHeight: function() { return this._lineHeight; },\r\n    getFamily:     function() { return this._family; },\r\n    \r\n    get font()       { return this.getFont(); },\r\n    get style()      { return this.getStyle(); },\r\n    get variant()    { return this.getVariant(); },\r\n    get weight()     { return this.getWeight(); },\r\n    get stretch()    { return this.getStretch(); },\r\n    get size()       { return this.getSize(); },\r\n    get lineHeight() { return this.getLineHeight(); },\r\n    get family()     { return this.getFamily(); },\r\n    \r\n    copy: function( options ) {\r\n      return new Font( _.extend( {\r\n        style: this._style,\r\n        variant: this._variant,\r\n        weight: this._weight,\r\n        stretch: this._stretch,\r\n        size: this._size,\r\n        lineHeight: this._lineHeight,\r\n        family: this._family\r\n      }, options ) );\r\n    },\r\n    \r\n    computeShorthand: function() {\r\n      var ret = '';\r\n      if ( this._style !== 'normal' ) { ret += this._style + ' '; }\r\n      if ( this._variant !== 'normal' ) { ret += this._variant + ' '; }\r\n      if ( this._weight !== 'normal' ) { ret += this._weight + ' '; }\r\n      if ( this._stretch !== 'normal' ) { ret += this._stretch + ' '; }\r\n      ret += this._size;\r\n      if ( this._lineHeight !== 'normal' ) { ret += '/' + this._lineHeight; }\r\n      ret += ' ' + this._family;\r\n      return ret;\r\n    },\r\n    \r\n    toCSS: function() {\r\n      return this.getFont();\r\n    }\r\n  };\r\n  \r\n  Font.DEFAULT = new Font();\r\n  \r\n  return Font;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Text\r\n *\r\n * TODO: newlines (multiline)\r\n * TODO: htmlText support (and DOM renderer)\r\n * TODO: don't get bounds until the Text node is fully mutated?\r\n * TODO: remove some support for centering, since Scenery's Node already handles that better?\r\n *\r\n * Useful specs:\r\n * http://www.w3.org/TR/css3-text/\r\n * http://www.w3.org/TR/css3-fonts/\r\n * http://www.w3.org/TR/SVG/text.html\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/nodes/Text',['require','PHET_CORE/inherit','PHET_CORE/escapeHTML','DOT/Bounds2','DOT/Matrix3','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/nodes/Fillable','SCENERY/nodes/Strokable','SCENERY/util/Util','SCENERY/util/Font','SCENERY/util/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var escapeHTML = require( 'PHET_CORE/escapeHTML' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Node = require( 'SCENERY/nodes/Node' ); // inherits from Node\r\n  var Renderer = require( 'SCENERY/layers/Renderer' );\r\n  var Fillable = require( 'SCENERY/nodes/Fillable' );\r\n  var Strokable = require( 'SCENERY/nodes/Strokable' );\r\n  var objectCreate = require( 'SCENERY/util/Util' ).objectCreate; // i.e. Object.create\r\n  require( 'SCENERY/util/Font' );\r\n  require( 'SCENERY/util/Util' ); // for canvasAccurateBounds and CSS transforms\r\n  \r\n  // set up the container and text for testing text bounds quickly (using approximateSVGBounds)\r\n  var svgTextSizeContainer = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' );\r\n  svgTextSizeContainer.setAttribute( 'width', '2' );\r\n  svgTextSizeContainer.setAttribute( 'height', '2' );\r\n  svgTextSizeContainer.setAttribute( 'style', 'display: hidden; pointer-events: none; position: absolute; left: -65535; right: -65535;' ); // so we don't flash it in a visible way to the user\r\n  var svgTextSizeElement = document.createElementNS( 'http://www.w3.org/2000/svg', 'text' );\r\n  svgTextSizeElement.appendChild( document.createTextNode( '' ) );\r\n  svgTextSizeContainer.appendChild( svgTextSizeElement );\r\n  \r\n  // SVG bounds seems to be malfunctioning for Safari 5. Since we don't have a reproducible test machine for\r\n  // fast iteration, we'll guess the user agent and use DOM bounds instead of SVG.\r\n  // Hopefully the two contraints rule out any future Safari versions (fairly safe, but not impossible!)\r\n  var useDOMAsFastBounds = window.navigator.userAgent.indexOf( 'like Gecko) Version/5' ) !== -1 &&\r\n                           window.navigator.userAgent.indexOf( 'Safari/' ) !== -1;\r\n  \r\n  var hybridTextNode; // a node that is used to measure SVG text top/height for hybrid caching purposes\r\n  var initializingHybridTextNode = false;\r\n  \r\n  scenery.Text = function Text( text, options ) {\r\n    this._text         = '';                   // filled in with mutator\r\n    this._font         = scenery.Font.DEFAULT; // default font, usually 10px sans-serif\r\n    this._direction    = 'ltr';                // ltr, rtl, inherit -- consider inherit deprecated, due to how we compute text bounds in an off-screen canvas\r\n    this._boundsMethod = 'hybrid';             // fast (SVG/DOM, no canvas rendering allowed), fastCanvas (SVG/DOM, canvas rendering allowed without dirty regions),\r\n                                               // accurate (Canvas accurate recursive), or hybrid (cache SVG height, use canvas measureText for width)\r\n    \r\n    // whether the text is rendered as HTML or not. if defined (in a subtype constructor), use that value instead\r\n    this._isHTML = this._isHTML === undefined ? false : this._isHTML;\r\n    \r\n    // we will dynamically change renderers, so they are initialized per-instance instead of per-type\r\n    this._supportedRenderers = [ Renderer.Canvas, Renderer.SVG, Renderer.DOM ];\r\n    \r\n    var thisFont = this;\r\n    \r\n    // ensure we have a parameter object\r\n    options = options || {};\r\n    \r\n    // default to black filled text\r\n    if ( options.fill === undefined ) {\r\n      options.fill = '#000000';\r\n    }\r\n    \r\n    if ( text !== undefined ) {\r\n      // set the text parameter so that setText( text ) is effectively called in the mutator from the super call\r\n      options.text = text;\r\n    }\r\n    \r\n    this.initializeStrokable();\r\n    \r\n    Node.call( this, options );\r\n    \r\n    this.updateTextFlags();\r\n  };\r\n  var Text = scenery.Text;\r\n  \r\n  inherit( Node, Text, {\r\n    domUpdateTransformOnRepaint: true, // since we have to integrate the baseline offset into the CSS transform, signal to DOMLayer\r\n    \r\n    setText: function( text ) {\r\n      if ( text !== this._text ) {\r\n        this._text = text;\r\n        this.invalidateText();\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    getText: function() {\r\n      return this._text;\r\n    },\r\n    \r\n    setBoundsMethod: function( method ) {\r\n      sceneryAssert && sceneryAssert( method === 'fast' || method === 'fastCanvas' || method === 'accurate' || method === 'hybrid', 'Unknown Text boundsMethod' );\r\n      if ( method !== this._boundsMethod ) {\r\n        this._boundsMethod = method;\r\n        this.updateTextFlags();\r\n        this.dispatchEvent( 'boundsAccuracy', { node: this } ); // TODO: consider standardizing this, or attaching listeners in a different manner?\r\n        this.invalidateText();\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    getBoundsMethod: function() {\r\n      return this._boundsMethod;\r\n    },\r\n    \r\n    updateTextFlags: function() {\r\n      var thisText = this;\r\n      this.boundsInaccurate = this._boundsMethod !== 'accurate';\r\n      \r\n      var renderersChanged = false;\r\n      function check( predicateValue, renderer ) {\r\n        var inSupportedRenderers = _.contains( thisText._supportedRenderers, renderer );\r\n        if ( predicateValue !== inSupportedRenderers ) {\r\n          renderersChanged = true;\r\n          if ( predicateValue ) {\r\n            // add the renderer\r\n            thisText._supportedRenderers.push( renderer );\r\n          } else {\r\n            // remove the renderer\r\n            thisText._supportedRenderers.splice( _.indexOf( thisText._supportedRenderers, renderer ), 1 );\r\n            if ( thisText.renderer === renderer ) {\r\n              // our set renderer is incompatible. set to null to disable this. TODO: investigate rendering system to prevent overrides like this?\r\n              thisText.renderer = null;\r\n              \r\n              // for now, error out\r\n              throw new Error( 'The explicitly specified Text renderer: ' + renderer.name + ' is not supported by this operation (probably invalid stroke, fill, or boundsMethod)' );\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      check( this._boundsMethod !== 'fast' && !this._isHTML, Renderer.Canvas );\r\n      check( !this._isHTML, Renderer.SVG );\r\n      check( !this.hasStroke() && this.isFillDOMCompatible(), Renderer.DOM );\r\n      \r\n      if ( this._supportedRenderers.length === 0 ) {\r\n        throw new Error( 'No renderers are able to support this Text node (probably HTML text with a stroke or incompatible fill)' );\r\n      }\r\n      \r\n      if ( renderersChanged ) {\r\n        this.markLayerRefreshNeeded();\r\n      }\r\n    },\r\n    \r\n    invalidateText: function() {\r\n      // investigate http://mudcu.be/journal/2011/01/html5-typographic-metrics/\r\n      if ( this._isHTML || ( useDOMAsFastBounds && this._boundsMethod !== 'accurate' ) ) {\r\n        this.invalidateSelf( this.approximateDOMBounds() );\r\n      } else if ( this._boundsMethod === 'hybrid' ) {\r\n        this.invalidateSelf( this.approximateHybridBounds() );\r\n      } else if ( this._boundsMethod === 'fast' || this._boundsMethod === 'fastCanvas' ) {\r\n        this.invalidateSelf( this.approximateSVGBounds() );\r\n      } else {\r\n        this.invalidateSelf( this.accurateCanvasBounds() );\r\n      }\r\n      \r\n      // we may have changed renderers if parameters were changed!\r\n      this.updateTextFlags();\r\n    },\r\n    \r\n    // overrides from Strokable\r\n    invalidateStroke: function() {\r\n      // stroke can change both the bounds and renderer\r\n      this.invalidateText();\r\n    },\r\n    \r\n    // overrides from Fillable\r\n    invalidateFill: function() {\r\n      // fill type can change the renderer (gradient/fill not supported by DOM)\r\n      this.invalidateText();\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Canvas support\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    paintCanvas: function( wrapper ) {\r\n      var context = wrapper.context;\r\n      \r\n      // extra parameters we need to set, but should avoid setting if we aren't drawing anything\r\n      if ( this.hasFill() || this.hasStroke() ) {\r\n        wrapper.setFont( this._font.getFont() );\r\n        wrapper.setDirection( this._direction );\r\n      }\r\n      \r\n      if ( this.hasFill() ) {\r\n        this.beforeCanvasFill( wrapper ); // defined in Fillable\r\n        context.fillText( this._text, 0, 0 );\r\n        this.afterCanvasFill( wrapper ); // defined in Fillable\r\n      }\r\n      if ( this.hasStroke() ) {\r\n        this.beforeCanvasStroke( wrapper ); // defined in Strokable\r\n        context.strokeText( this._text, 0, 0 );\r\n        this.afterCanvasStroke( wrapper ); // defined in Strokable\r\n      }\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * WebGL support\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    paintWebGL: function( state ) {\r\n      throw new Error( 'Text.prototype.paintWebGL unimplemented' );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * SVG support\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    createSVGFragment: function( svg, defs, group ) {\r\n      var element = document.createElementNS( 'http://www.w3.org/2000/svg', 'text' );\r\n      element.appendChild( document.createTextNode( '' ) );\r\n      return element;\r\n    },\r\n    \r\n    updateSVGFragment: function( element ) {\r\n      var isRTL = this._direction === 'rtl';\r\n      \r\n      // update the text-node's value\r\n      element.lastChild.nodeValue = this._text;\r\n      \r\n      element.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );\r\n      \r\n      // element.setAttribute( 'text-anchor', 'start' ); // not needed right now (default is inherit)\r\n      element.setAttribute( 'dominant-baseline', 'alphabetic' ); // to match Canvas right now\r\n      element.setAttribute( 'direction', this._direction );\r\n      \r\n      // set all of the font attributes, since we can't use the combined one\r\n      element.setAttribute( 'font-family', this._font.getFamily() );\r\n      element.setAttribute( 'font-size', this._font.getSize() );\r\n      element.setAttribute( 'font-style', this._font.getStyle() );\r\n      element.setAttribute( 'font-weight', this._font.getWeight() );\r\n      element.setAttribute( 'font-stretch', this._font.getStretch() );\r\n    },\r\n    \r\n    // support patterns, gradients, and anything else we need to put in the <defs> block\r\n    updateSVGDefs: function( svg, defs ) {\r\n      // remove old definitions if they exist\r\n      this.removeSVGDefs( svg, defs );\r\n      \r\n      // add new ones if applicable\r\n      this.addSVGFillDef( svg, defs );\r\n      this.addSVGStrokeDef( svg, defs );\r\n    },\r\n    \r\n    // cleans up references created with udpateSVGDefs()\r\n    removeSVGDefs: function( svg, defs ) {\r\n      this.removeSVGFillDef( svg, defs );\r\n      this.removeSVGStrokeDef( svg, defs );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * DOM support\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    allowsMultipleDOMInstances: true,\r\n    \r\n    getDOMElement: function() {\r\n      return document.createElement( 'div' );\r\n    },\r\n    \r\n    updateDOMElement: function( div ) {\r\n      var $div = $( div );\r\n      div.style.font = this.getFont();\r\n      div.style.color = this.getCSSFill();\r\n      $div.width( this.getSelfBounds().width );\r\n      $div.height( this.getSelfBounds().height );\r\n      $div.empty(); // remove all children, including previously-created text nodes\r\n      div.appendChild( this.getDOMTextNode() );\r\n      div.setAttribute( 'dir', this._direction );\r\n    },\r\n    \r\n    updateCSSTransform: function( transform, element ) {\r\n      // since the DOM origin of the text is at the upper-left, and our Scenery origin is at the lower-left, we need to\r\n      // shift the text vertically, postmultiplied with the entire transform.\r\n      var yOffset = this.getSelfBounds().minY;\r\n      var matrix = transform.getMatrix().timesMatrix( Matrix3.translation( 0, yOffset ) );\r\n      scenery.Util.applyCSSTransform( matrix, element );\r\n    },\r\n    \r\n    // a DOM node (not a Scenery DOM node, but an actual DOM node) with the text\r\n    getDOMTextNode: function() {\r\n      if ( this._isHTML ) {\r\n        var span = document.createElement( 'span' );\r\n        span.innerHTML = this.text;\r\n        return span;\r\n      } else {\r\n        return document.createTextNode( this.text );\r\n      }\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Bounds\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    accurateCanvasBounds: function() {\r\n      var node = this;\r\n      var svgBounds = this.approximateSVGBounds(); // this seems to be slower than expected, mostly due to Font getters\r\n\r\n      //If svgBounds are zero, then return the zero bounds\r\n      if (svgBounds.width===0 && svgBounds.height===0){\r\n        return svgBounds;\r\n      }\r\n      return scenery.Util.canvasAccurateBounds( function( context ) {\r\n        context.font = node.font;\r\n        context.direction = node.direction;\r\n        context.fillText( node.text, 0, 0 );\r\n      }, {\r\n        precision: 0.5,\r\n        resolution: 128,\r\n        initialScale: 32 / Math.max( Math.abs( svgBounds.minX ), Math.abs( svgBounds.minY ), Math.abs( svgBounds.maxX ), Math.abs( svgBounds.maxY ) )\r\n      } );\r\n    },\r\n    \r\n    approximateCanvasWidth: function() {\r\n      var context = scenery.scratchContext;\r\n      context.font = this.font;\r\n      context.direction = this.direction;\r\n      return context.measureText( this.text ).width;\r\n    },\r\n    \r\n    approximateSVGBounds: function() {\r\n      if ( !svgTextSizeContainer.parentNode ) {\r\n        if ( document.body ) {\r\n          document.body.appendChild( svgTextSizeContainer );\r\n        } else {\r\n          // TODO: better way to handle the hybridTextNode being added inside the HEAD? Requiring a body for proper operation might be a problem.\r\n          if ( initializingHybridTextNode ) {\r\n            // if this is almost assuredly the hybridTextNode, return nothing for now. TODO: better way of handling this! it's a hack!\r\n            return Bounds2.NOTHING;\r\n          } else {\r\n            throw new Error( 'No document.body and trying to get approximate SVG bounds of a Text node' );\r\n          }\r\n        }\r\n      }\r\n      this.updateSVGFragment( svgTextSizeElement );\r\n      var rect = svgTextSizeElement.getBBox();\r\n      return new Bounds2( rect.x, rect.y, rect.x + rect.width, rect.y + rect.height );\r\n    },\r\n    \r\n    approximateHybridBounds: function() {\r\n      if ( !hybridTextNode ) {\r\n        return Bounds2.NOTHING; // we are the hybridTextNode, ignore us\r\n      }\r\n      \r\n      if ( this._font._cachedSVGBounds === undefined ) {\r\n        hybridTextNode.setFont( this._font );\r\n        this._font._cachedSVGBounds = hybridTextNode.getBounds();\r\n      }\r\n      \r\n      var canvasWidth = this.approximateCanvasWidth();\r\n      var verticalBounds = this._font._cachedSVGBounds;\r\n      \r\n      // it seems that SVG bounds generally have x=0, so we hard code that here\r\n      return new Bounds2( 0, verticalBounds.minY, canvasWidth, verticalBounds.maxY );\r\n    },\r\n    \r\n    approximateDOMBounds: function() {\r\n      var maxHeight = 1024; // technically this will fail if the font is taller than this!\r\n      var isRTL = this.direction === 'rtl';\r\n      \r\n      // <div style=\"position: absolute; left: 0; top: 0; padding: 0 !important; margin: 0 !important;\"><span id=\"baselineSpan\" style=\"font-family: Verdana; font-size: 25px;\">QuipTaQiy</span><div style=\"vertical-align: baseline; display: inline-block; width: 0; height: 500px; margin: 0 important!; padding: 0 important!;\"></div></div>\r\n      \r\n      var div = document.createElement( 'div' );\r\n      $( div ).css( {\r\n        position: 'absolute',\r\n        left: 0,\r\n        top: 0,\r\n        padding: '0 !important',\r\n        margin: '0 !important',\r\n        display: 'hidden'\r\n      } );\r\n      \r\n      var span = document.createElement( 'span' );\r\n      $( span ).css( 'font', this.getFont() );\r\n      span.appendChild( this.getDOMTextNode() );\r\n      span.setAttribute( 'direction', this._direction );\r\n      \r\n      var fakeImage = document.createElement( 'div' );\r\n      $( fakeImage ).css( {\r\n        'vertical-align': 'baseline',\r\n        display: 'inline-block',\r\n        width: 0,\r\n        height: maxHeight + 'px',\r\n        margin: '0 !important',\r\n        padding: '0 !important'\r\n      } );\r\n      \r\n      div.appendChild( span );\r\n      div.appendChild( fakeImage );\r\n      \r\n      document.body.appendChild( div );\r\n      var rect = span.getBoundingClientRect();\r\n      var divRect = div.getBoundingClientRect();\r\n      // add 1 pixel to rect.right to prevent HTML text wrapping\r\n      var result = new Bounds2( rect.left, rect.top - maxHeight, rect.right + 1, rect.bottom - maxHeight ).shifted( -divRect.left, -divRect.top );\r\n      // console.log( 'result: ' + result );\r\n      document.body.removeChild( div );\r\n      \r\n      var width = rect.right - rect.left;\r\n      return result.shiftedX( isRTL ? -width : 0 ); // should we even swap here?\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Self setters / getters\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    setFont: function( font ) {\r\n      if ( this.font !== font ) {\r\n        this._font = font instanceof scenery.Font ? font : new scenery.Font( font );\r\n        this.invalidateText();\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    // NOTE: returns mutable copy for now, consider either immutable version, defensive copy, or note about invalidateText()\r\n    getFont: function() {\r\n      return this._font.getFont();\r\n    },\r\n    \r\n    setDirection: function( direction ) {\r\n      this._direction = direction;\r\n      this.invalidateText();\r\n      return this;\r\n    },\r\n    \r\n    getDirection: function() {\r\n      return this._direction;\r\n    },\r\n    \r\n    isPainted: function() {\r\n      return true;\r\n    },\r\n    \r\n    getBasicConstructor: function( propLines ) {\r\n      return 'new scenery.Text( \\'' + escapeHTML( this._text.replace( /'/g, '\\\\\\'' ) ) + '\\', {' + propLines + '} )';\r\n    },\r\n    \r\n    getPropString: function( spaces, includeChildren ) {\r\n      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );\r\n      result = this.appendFillablePropString( spaces, result );\r\n      result = this.appendStrokablePropString( spaces, result );\r\n      \r\n      // TODO: if created again, deduplicate with Node's getPropString\r\n      function addProp( key, value, nowrap ) {\r\n        if ( result ) {\r\n          result += ',\\n';\r\n        }\r\n        if ( !nowrap && typeof value === 'string' ) {\r\n          result += spaces + key + ': \\'' + value + '\\'';\r\n        } else {\r\n          result += spaces + key + ': ' + value;\r\n        }\r\n      }\r\n      \r\n      if ( this.font !== new scenery.Font().getFont() ) {\r\n        addProp( 'font', this.font.replace( /'/g, '\\\\\\'' ) );\r\n      }\r\n      \r\n      if ( this._direction !== 'ltr' ) {\r\n        addProp( 'direction', this._direction );\r\n      }\r\n      \r\n      return result;\r\n    }\r\n  } );\r\n  \r\n  /*---------------------------------------------------------------------------*\r\n  * Font setters / getters\r\n  *----------------------------------------------------------------------------*/\r\n  \r\n  function addFontForwarding( propertyName, fullCapitalized, shortUncapitalized ) {\r\n    var getterName = 'get' + fullCapitalized;\r\n    var setterName = 'set' + fullCapitalized;\r\n    \r\n    Text.prototype[getterName] = function() {\r\n      // use the ES5 getter to retrieve the property. probably somewhat slow.\r\n      return this._font[ shortUncapitalized ];\r\n    };\r\n    \r\n    Text.prototype[setterName] = function( value ) {\r\n      // create a full copy of our font instance\r\n      var ob = {};\r\n      ob[shortUncapitalized] = value;\r\n      var newFont = this._font.copy( ob );\r\n      \r\n      // apply the new Font. this should call invalidateText() as normal\r\n      this.setFont( newFont );\r\n      return this;\r\n    };\r\n    \r\n    Object.defineProperty( Text.prototype, propertyName, { set: Text.prototype[setterName], get: Text.prototype[getterName] } );\r\n  }\r\n  \r\n  addFontForwarding( 'fontWeight', 'FontWeight', 'weight' );\r\n  addFontForwarding( 'fontFamily', 'FontFamily', 'family' );\r\n  addFontForwarding( 'fontStretch', 'FontStretch', 'stretch' );\r\n  addFontForwarding( 'fontStyle', 'FontStyle', 'style' );\r\n  addFontForwarding( 'fontSize', 'FontSize', 'size' );\r\n  addFontForwarding( 'lineHeight', 'LineHeight', 'lineHeight' );\r\n  \r\n  Text.prototype._mutatorKeys = [ 'boundsMethod', 'text', 'font', 'fontWeight', 'fontFamily', 'fontStretch', 'fontStyle', 'fontSize', 'lineHeight',\r\n                                  'direction' ].concat( Node.prototype._mutatorKeys );\r\n  \r\n  Text.prototype._supportedRenderers = [ Renderer.Canvas, Renderer.SVG, Renderer.DOM ];\r\n  Text.prototype._supportedRenderersWithFastBounds = [ Renderer.SVG, Renderer.DOM ]; // renderers for fast (SVG/DOM) bounds, since canvas dirty regions would present issues\r\n  \r\n  // font-specific ES5 setters and getters are defined using addFontForwarding above\r\n  Object.defineProperty( Text.prototype, 'font', { set: Text.prototype.setFont, get: Text.prototype.getFont } );\r\n  Object.defineProperty( Text.prototype, 'text', { set: Text.prototype.setText, get: Text.prototype.getText } );\r\n  Object.defineProperty( Text.prototype, 'direction', { set: Text.prototype.setDirection, get: Text.prototype.getDirection } );\r\n  Object.defineProperty( Text.prototype, 'boundsMethod', { set: Text.prototype.setBoundsMethod, get: Text.prototype.getBoundsMethod } );\r\n  \r\n  // mix in support for fills and strokes\r\n  /* jshint -W064 */\r\n  Fillable( Text );\r\n  Strokable( Text );\r\n  \r\n  initializingHybridTextNode = true;\r\n  hybridTextNode = new Text( 'm', { boundsMethod: 'fast' } );\r\n  initializingHybridTextNode = false;\r\n\r\n  return Text;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Images\r\n *\r\n * TODO: setImage / getImage and the whole toolchain that uses that\r\n * TODO: allow multiple DOM instances (create new HTMLImageElement elements)\r\n * TODO: SVG support\r\n * TODO: support rendering a Canvas to DOM (single instance)\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/nodes/Image',['require','PHET_CORE/inherit','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/util/Util','SCENERY/util/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Node = require( 'SCENERY/nodes/Node' ); // Image inherits from Node\r\n  var Renderer = require( 'SCENERY/layers/Renderer' ); // we need to specify the Renderer in the prototype\r\n  var objectCreate = require( 'SCENERY/util/Util' ).objectCreate;\r\n  require( 'SCENERY/util/Util' );\r\n  \r\n  /*\r\n   * Canvas renderer supports the following as 'image':\r\n   *     URL (string)             // works, but does NOT support bounds-based parameter object keys like 'left', 'centerX', etc.\r\n   *                              // also necessary to force updateScene() after it has loaded\r\n   *     HTMLImageElement         // works\r\n   *     HTMLVideoElement         // not tested\r\n   *     HTMLCanvasElement        // works, and forces the canvas renderer\r\n   *     CanvasRenderingContext2D // not tested, but bad luck in past\r\n   *     ImageBitmap              // good luck creating this. currently API for window.createImageBitmap not implemented\r\n   * SVG renderer supports the following as 'image':\r\n   *     URL (string)\r\n   *     HTMLImageElement\r\n   */\r\n  scenery.Image = function Image( image, options ) {\r\n    sceneryAssert && sceneryAssert( image, \"image should be available\" );\r\n    \r\n    // allow not passing an options object\r\n    options = options || {};\r\n    \r\n    // rely on the setImage call from the super constructor to do the setup\r\n    if ( image ) {\r\n      options.image = image;\r\n    }\r\n    \r\n    var self = this;\r\n    // allows us to invalidate our bounds whenever an image is loaded\r\n    this.loadListener = function( event ) {\r\n      self.invalidateImage();\r\n      \r\n      // don't leak memory!\r\n      self._image.removeEventListener( 'load', self.loadListener );\r\n    };\r\n    \r\n    Node.call( this, options );\r\n  };\r\n  var Image = scenery.Image;\r\n  \r\n  inherit( Node, Image, {\r\n    allowsMultipleDOMInstances: false, // TODO: support multiple instances\r\n    \r\n    invalidateImage: function() {\r\n      this.invalidateSelf( new Bounds2( 0, 0, this.getImageWidth(), this.getImageHeight() ) );\r\n    },\r\n    \r\n    getImage: function() {\r\n      return this._image;\r\n    },\r\n    \r\n    setImage: function( image ) {\r\n      var self = this;\r\n      \r\n      if ( this._image !== image && ( typeof image !== 'string' || !this._image || image !== this._image.src ) ) {\r\n        // don't leak memory by referencing old images\r\n        if ( this._image ) {\r\n          this._image.removeEventListener( 'load', this.loadListener );\r\n        }\r\n        \r\n        if ( typeof image === 'string' ) {\r\n          // create an image with the assumed URL\r\n          var src = image;\r\n          image = document.createElement( 'img' );\r\n          image.addEventListener( 'load', this.loadListener );\r\n          image.src = src;\r\n        } else if ( image instanceof HTMLImageElement ) {\r\n          // only add a listener if we probably haven't loaded yet\r\n          if ( !image.width || !image.height ) {\r\n            image.addEventListener( 'load', this.loadListener );\r\n          }\r\n        }\r\n        \r\n        // swap supported renderers if necessary TODO: share this code dealing with compatible renderer changes\r\n        if ( image instanceof HTMLCanvasElement ) {\r\n          if ( !this.hasOwnProperty( '_supportedRenderers' ) ) {\r\n            this._supportedRenderers = [ Renderer.Canvas ];\r\n            this.markLayerRefreshNeeded();\r\n          }\r\n        } else {\r\n          if ( this.hasOwnProperty( '_supportedRenderers' ) ) {\r\n            delete this._supportedRenderers; // will leave prototype intact\r\n            this.markLayerRefreshNeeded();\r\n          }\r\n        }\r\n        \r\n        this._image = image;\r\n        this.invalidateImage(); // yes, if we aren't loaded yet this will give us 0x0 bounds\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    getImageWidth: function() {\r\n      return this._image.width;\r\n    },\r\n    \r\n    getImageHeight: function() {\r\n      return this._image.height;\r\n    },\r\n    \r\n    getImageURL: function() {\r\n      return this._image.src;\r\n    },\r\n    \r\n    // signal that we are actually rendering something\r\n    isPainted: function() {\r\n      return true;\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Canvas support\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // TODO: add SVG / DOM support\r\n    paintCanvas: function( wrapper ) {\r\n      wrapper.context.drawImage( this._image, 0, 0 );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * WebGL support\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    paintWebGL: function( state ) {\r\n      throw new Error( 'paintWebGL:nimplemented' );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * SVG support\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    createSVGFragment: function( svg, defs, group ) {\r\n      var element = document.createElementNS( 'http://www.w3.org/2000/svg', 'image' );\r\n      element.setAttribute( 'x', 0 );\r\n      element.setAttribute( 'y', 0 );\r\n      return element;\r\n    },\r\n    \r\n    updateSVGFragment: function( element ) {\r\n      // like <image xlink:href='http://phet.colorado.edu/images/phet-logo-yellow.png' x='0' y='0' height='127px' width='242px'/>\r\n      var xlinkns = 'http://www.w3.org/1999/xlink';\r\n      \r\n      element.setAttribute( 'width', this.getImageWidth() + 'px' );\r\n      element.setAttribute( 'height', this.getImageHeight() + 'px' );\r\n      element.setAttributeNS( xlinkns, 'xlink:href', this.getImageURL() );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * DOM support\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    getDOMElement: function() {\r\n      this._image.style.display = 'block';\r\n      this._image.style.position = 'absolute';\r\n      this._image.style.left = '0';\r\n      this._image.style.top = '0';\r\n      return this._image;\r\n    },\r\n    \r\n    updateDOMElement: function( image ) {\r\n      if ( image.src !== this._image.src ) {\r\n        image.src = this._image.src;\r\n      }\r\n    },\r\n    \r\n    updateCSSTransform: function( transform, element ) {\r\n      // TODO: extract this out, it's completely shared!\r\n      scenery.Util.applyCSSTransform( transform.getMatrix(), element );\r\n    },\r\n    \r\n    set image( value ) { this.setImage( value ); },\r\n    get image() { return this.getImage(); },\r\n    \r\n    getBasicConstructor: function( propLines ) {\r\n      return 'new scenery.Image( \\'' + ( this._image.src ? this._image.src.replace( /'/g, '\\\\\\'' ) : 'other' ) + '\\', {' + propLines + '} )';\r\n    }\r\n  } );\r\n  \r\n  Image.prototype._mutatorKeys = [ 'image' ].concat( Node.prototype._mutatorKeys );\r\n  \r\n  Image.prototype._supportedRenderers = [ Renderer.Canvas, Renderer.SVG, Renderer.DOM ];\r\n  \r\n  // utility for others\r\n  Image.createSVGImage = function( url, width, height ) {\r\n    var xlinkns = 'http://www.w3.org/1999/xlink';\r\n    var svgns = 'http://www.w3.org/2000/svg';\r\n    \r\n    var element = document.createElementNS( svgns, 'image' );\r\n    element.setAttribute( 'x', 0 );\r\n    element.setAttribute( 'y', 0 );\r\n    element.setAttribute( 'width', width + 'px' );\r\n    element.setAttribute( 'height', height + 'px' );\r\n    element.setAttributeNS( xlinkns, 'xlink:href', url );\r\n    \r\n    return element;\r\n  };\r\n  \r\n  return Image;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * DOM nodes. Currently lightweight handling\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/nodes/DOM',['require','PHET_CORE/inherit','PHET_CORE/escapeHTML','DOT/Bounds2','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/layers/Renderer','SCENERY/util/Util','SCENERY/util/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var escapeHTML = require( 'PHET_CORE/escapeHTML' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Node = require( 'SCENERY/nodes/Node' ); // DOM inherits from Node\r\n  var Renderer = require( 'SCENERY/layers/Renderer' );\r\n  var objectCreate = require( 'SCENERY/util/Util' ).objectCreate;\r\n  require( 'SCENERY/util/Util' );\r\n  \r\n  scenery.DOM = function DOM( element, options ) {\r\n    options = options || {};\r\n    \r\n    this._interactive = false;\r\n    \r\n    // unwrap from jQuery if that is passed in, for consistency\r\n    if ( element && element.jquery ) {\r\n      element = element[0];\r\n    }\r\n    \r\n    this._container = document.createElement( 'div' );\r\n    this._$container = $( this._container );\r\n    this._$container.css( 'position', 'absolute' );\r\n    this._$container.css( 'left', 0 );\r\n    this._$container.css( 'top', 0 );\r\n    \r\n    this.invalidateDOMLock = false;\r\n    \r\n    // so that the mutator will call setElement()\r\n    options.element = element;\r\n    \r\n    // will set the element after initializing\r\n    Node.call( this, options );\r\n  };\r\n  var DOM = scenery.DOM;\r\n  \r\n  inherit( Node, DOM, {\r\n    // we use a single DOM instance, so this flag should indicate that we don't support duplicating it\r\n    allowsMultipleDOMInstances: false,\r\n    \r\n    // needs to be attached to the DOM tree for this to work\r\n    calculateDOMBounds: function() {\r\n      // var boundingRect = this._element.getBoundingClientRect();\r\n      // return new Bounds2( 0, 0, boundingRect.width, boundingRect.height );\r\n      var $element = $( this._element );\r\n      return new Bounds2( 0, 0, $element.width(), $element.height() );\r\n    },\r\n    \r\n    createTemporaryContainer: function() {\r\n      var temporaryContainer = document.createElement( 'div' );\r\n      $( temporaryContainer ).css( {\r\n        display: 'hidden',\r\n        padding: '0 !important',\r\n        margin: '0 !important',\r\n        position: 'absolute',\r\n        left: 0,\r\n        top: 0,\r\n        width: 65535,\r\n        height: 65535\r\n      } );\r\n      return temporaryContainer;\r\n    },\r\n    \r\n    invalidateDOM: function() {\r\n      // prevent this from being executed as a side-effect from inside one of its own calls\r\n      if ( this.invalidateDOMLock ) {\r\n        return;\r\n      }\r\n      this.invalidateDOMLock = true;\r\n      \r\n      // we will place ourselves in a temporary container to get our real desired bounds\r\n      var temporaryContainer = this.createTemporaryContainer();\r\n      \r\n      // move to the temporary container\r\n      this._container.removeChild( this._element );\r\n      temporaryContainer.appendChild( this._element );\r\n      document.body.appendChild( temporaryContainer );\r\n      \r\n      // bounds computation and resize our container to fit precisely\r\n      var selfBounds = this.calculateDOMBounds();\r\n      this.invalidateSelf( selfBounds );\r\n      this._$container.width( selfBounds.getWidth() );\r\n      this._$container.height( selfBounds.getHeight() );\r\n      \r\n      // move back to the main container\r\n      document.body.removeChild( temporaryContainer );\r\n      temporaryContainer.removeChild( this._element );\r\n      this._container.appendChild( this._element );\r\n      \r\n      this.invalidateDOMLock = false;\r\n    },\r\n    \r\n    getDOMElement: function() {\r\n      return this._container;\r\n    },\r\n    \r\n    updateDOMElement: function( container ) {\r\n      // nothing needed, since we are just displaying a single DOM element\r\n    },\r\n    \r\n    updateCSSTransform: function( transform, element ) {\r\n      // faster to use our jQuery reference instead of wrapping element\r\n      scenery.Util.applyCSSTransform( transform.getMatrix(), this._container );\r\n    },\r\n    \r\n    isPainted: function() {\r\n      return true;\r\n    },\r\n    \r\n    setElement: function( element ) {\r\n      if ( this._element !== element ) {\r\n        if ( this._element ) {\r\n          this._container.removeChild( this._element );\r\n        }\r\n        \r\n        this._element = element;\r\n        this._$element = $( element );\r\n        \r\n        this._container.appendChild( this._element );\r\n        \r\n        // TODO: bounds issue, since this will probably set to empty bounds and thus a repaint may not draw over it\r\n        this.invalidateDOM();  \r\n      }\r\n\r\n      return this; // allow chaining\r\n    },\r\n    \r\n    getElement: function() {\r\n      return this._element;\r\n    },\r\n    \r\n    setInteractive: function( interactive ) {\r\n      if ( this._interactive !== interactive ) {\r\n        this._interactive = interactive;\r\n        \r\n        // TODO: anything needed here?\r\n      }\r\n    },\r\n    \r\n    isInteractive: function() {\r\n      return this._interactive;\r\n    },\r\n    \r\n    set element( value ) { this.setElement( value ); },\r\n    get element() { return this.getElement(); },\r\n    \r\n    set interactive( value ) { this.setInteractive( value ); },\r\n    get interactive() { return this.isInteractive(); },\r\n    \r\n    getBasicConstructor: function( propLines ) {\r\n      return 'new scenery.DOM( $( \\'' + escapeHTML( this._container.innerHTML.replace( /'/g, '\\\\\\'' ) ) + '\\' ), {' + propLines + '} )';\r\n    },\r\n    \r\n    getPropString: function( spaces, includeChildren ) {\r\n      var result = Node.prototype.getPropString.call( this, spaces, includeChildren );\r\n      if ( this.interactive ) {\r\n        if ( result ) {\r\n          result += ',\\n';\r\n        }\r\n        result += spaces + 'interactive: true';\r\n      }\r\n      return result;\r\n    }\r\n  } );\r\n  \r\n  DOM.prototype._mutatorKeys = [ 'element', 'interactive' ].concat( Node.prototype._mutatorKeys );\r\n  \r\n  DOM.prototype._supportedRenderers = [ Renderer.DOM ];\r\n  \r\n  return DOM;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Creates an array of results from an iterator that takes a callback.\r\n *\r\n * For instance, if calling a function f( g ) will call g( 1 ), g( 2 ), and g( 3 ),\r\n * collect( function( callback ) { f( callback ); } );\r\n * will return [1,2,3].\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'PHET_CORE/collect',['require'],function( require ) {\r\n  'use strict';\r\n  \r\n  return function collect( iterate ) {\r\n    var result = [];\r\n    iterate( function( ob ) {\r\n      result.push( ob );\r\n    } );\r\n    return result;\r\n  };\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Accessibility peer, which is added to the dom for focus and keyboard navigation.\r\n *\r\n * @author Sam Reid\r\n */\r\n\r\ndefine( 'SCENERY/util/AccessibilityPeer',['require','PHET_CORE/inherit','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var AccessibilityPeer = scenery.AccessibilityPeer = function AccessibilityPeer( instance, element, options ) {\r\n    var peer = this;\r\n    \r\n    options = options || {};\r\n\r\n    //Defaulting to 0 would mean using the document order, which can easily be incorrect for a PhET simulation.\r\n    //For any of the nodes to use a nonzero tabindex, they must all use a nonzero tabindex, see #40\r\n    options.tabIndex = options.tabIndex || 1;\r\n    \r\n    // TODO: if element is a DOM element, verify that no other accessibility peer is using it! (add a flag, and remove on disposal)\r\n    this.element = ( typeof element === 'string' ) ? $( element )[0] : element;\r\n\r\n    if ( options.label ) {\r\n      this.peerElement = document.createElement( 'div' );\r\n      this.element.id = 'peer-' + instance.trail.getUniqueId();\r\n      var label = document.createElement('label');\r\n      label.appendChild(document.createTextNode(options.label));\r\n      label.setAttribute('for',this.element.id);\r\n      this.peerElement.appendChild(label);\r\n      this.peerElement.appendChild(this.element);\r\n    } else{\r\n      this.peerElement = this.element;\r\n    }\r\n\r\n    this.instance = instance;\r\n    this.trail = instance.trail;\r\n    \r\n    this.element.setAttribute( 'tabindex', options.tabIndex );\r\n    this.element.style.position = 'absolute';\r\n    \r\n    // TODO: batch these also if the Scene is batching events\r\n    var scene = instance.getScene();\r\n    this.clickListener = function PeerClickListener( event ) {\r\n      sceneryAccessibilityLog && sceneryAccessibilityLog( 'peer click on ' + instance.toString() + ': ' + instance.getNode().constructor.name );\r\n      if ( options.click ) { options.click( event ); }\r\n    };\r\n    this.focusListener = function PeerFocusListener( event ) {\r\n      sceneryAccessibilityLog && sceneryAccessibilityLog( 'peer focused: ' + instance.toString() + ': ' + instance.getNode().constructor.name );\r\n      scene.focusPeer( peer );\r\n    };\r\n    this.blurListener = function PeerBlurListener( event ) {\r\n      sceneryAccessibilityLog && sceneryAccessibilityLog( 'peer blurred: ' + instance.toString() + ': ' + instance.getNode().constructor.name );\r\n      scene.blurPeer( peer );\r\n    };\r\n    this.element.addEventListener( 'click', this.clickListener );\r\n    this.element.addEventListener( 'focus', this.focusListener );\r\n    this.element.addEventListener( 'blur', this.blurListener );\r\n\r\n    this.keepPeerBoundsInSync = true;\r\n    if ( this.keepPeerBoundsInSync ) {\r\n      this.boundsSyncListener = this.syncBounds.bind( this );\r\n\r\n      instance.getNode().addEventListener( 'bounds', this.boundsSyncListener );\r\n      this.syncBounds();\r\n\r\n      //When the scene resizes, update the peer bounds\r\n      instance.getScene().addEventListener( 'resize', this.boundsSyncListener );\r\n\r\n      //Initial layout\r\n      window.setTimeout( this.syncBounds.bind( this ), 30 );\r\n    }\r\n  };\r\n\r\n  AccessibilityPeer.prototype = {\r\n    constructor: AccessibilityPeer,\r\n    \r\n    dispose: function() {\r\n      this.element.removeEventListener( 'click', this.clickListener );\r\n      this.element.removeEventListener( 'focus', this.focusListener );\r\n      this.element.removeEventListener( 'blur', this.blurListener );\r\n      \r\n      // don't leak memory\r\n      if ( this.keepPeerBoundsInSync ) {\r\n        this.instance.getNode().removeEventListener( 'bounds', this.boundsSyncListener );\r\n        this.instance.getScene().removeEventListener( 'resize', this.boundsSyncListener );\r\n      }\r\n    },\r\n    \r\n    getGlobalBounds: function() {\r\n      return this.trail.parentToGlobalBounds( this.trail.lastNode().getBounds() ).roundedOut();\r\n    },\r\n    \r\n    syncBounds: function() {\r\n      var globalBounds = this.getGlobalBounds();\r\n      this.element.style.left = globalBounds.x + 'px';\r\n      this.element.style.top = globalBounds.y + 'px';\r\n      this.element.style.width = globalBounds.width + 'px';\r\n      this.element.style.height = globalBounds.height + 'px';\r\n    }\r\n  };\r\n  \r\n  return AccessibilityPeer;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Live region is used with accessibility to read out changes in model state.\r\n * Should conform to the Axon property interface to make it easy to interchange.\r\n *\r\n * @author Sam Reid\r\n */\r\n\r\ndefine( 'SCENERY/util/LiveRegion',['require','PHET_CORE/inherit','PHET_CORE/escapeHTML','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var escapeHTML = require( 'PHET_CORE/escapeHTML' );\r\n\r\n  var scenery = require( 'SCENERY/scenery' );\r\n\r\n  var LiveRegion = scenery.LiveRegion = function LiveRegion( instance, property, options ) {\r\n    var liveRegion = this;\r\n    this.property = property;\r\n    options = options || {};\r\n\r\n    //Defaulting to 0 would mean using the document order, which can easily be incorrect for a PhET simulation.\r\n    //For any of the nodes to use a nonzero tabindex, they must all use a nonzero tabindex, see #40\r\n    options.tabIndex = options.tabIndex || 1;\r\n\r\n    // TODO: if element is a DOM element, verify that no other accessibility liveRegion is using it! (add a flag, and remove on disposal)\r\n//    this.element = '<div role=\"region\" id=\"bird-info\" aria-live=\"polite\">';\r\n    this.element = document.createElement( 'div' );\r\n    this.element.setAttribute( 'aria-live', 'polite' );\r\n    this.element.setAttribute( 'role', 'region' );\r\n    this.textNode = document.createTextNode( '' );\r\n    this.element.appendChild( this.textNode );\r\n\r\n    //Just setting the text causes NVDA to read deltas, you have to replace the node to have it read the text\r\n    this.listener = function( newText ) {\r\n      liveRegion.element.removeChild( liveRegion.textNode );\r\n      liveRegion.textNode = document.createTextNode( newText );\r\n      liveRegion.element.appendChild( liveRegion.textNode );\r\n    };\r\n    property.link( this.listener );\r\n  };\r\n\r\n  LiveRegion.prototype = {\r\n    constructor: scenery.LiveRegion,\r\n    dispose: function() { this.property.unlink( this.listener ); }\r\n  };\r\n\r\n  return LiveRegion;\r\n} );","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * An Instance of a Node in the expanded tree form.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/Instance',['require','SCENERY/scenery','SCENERY/util/AccessibilityPeer','SCENERY/util/LiveRegion'],function( require ) {\r\n  \"use strict\";\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  require( 'SCENERY/util/AccessibilityPeer' );\r\n  require( 'SCENERY/util/LiveRegion' );\r\n  \r\n  var accessibility = window.has && window.has( 'scenery.accessibility' );\r\n  \r\n  // layer should be null if the trail isn't to a painted node\r\n  scenery.Instance = function Instance( trail, layer, parent ) {\r\n    this.trail = trail; // trail may be assumed to be stale, for performance reasons\r\n    this.layer = layer;\r\n    this.oldLayer = layer; // used during stitching\r\n    \r\n    // assertion not enabled, since at the start we don't specify a layer (it will be constructed later)\r\n    // sceneryAssert && sceneryAssert( trail.lastNode().isPainted() === ( layer !== null ), 'Has a layer iff is painted' );\r\n    \r\n    // TODO: SVG layer might want to put data (group/fragment) references here (indexed by layer ID)\r\n    this.data = {};\r\n    \r\n    // TODO: ensure that we can track this? otherwise remove it for memory and speed\r\n    this.parent = parent;\r\n    this.children = [];\r\n    \r\n    this.peers = []; // list of AccessibilityPeer instances attached to this trail\r\n    this.liveRegions = []; // list of LiveRegion instances attached to this trail\r\n    \r\n    // TODO: track these? should significantly accelerate subtree-changing operations\r\n    this.startAffectedLayer = null;\r\n    this.endAffectedLayer = null;\r\n    \r\n    trail.setImmutable(); // make sure our Trail doesn't change from under us\r\n    \r\n    if ( accessibility ) {\r\n      this.addPeers();\r\n      this.addLiveRegions();\r\n    }\r\n  };\r\n  var Instance = scenery.Instance;\r\n  \r\n  Instance.prototype = {\r\n    constructor: Instance,\r\n    \r\n    getScene: function() {\r\n      return this.trail.rootNode();\r\n    },\r\n    get scene() { return this.getScene(); },\r\n    \r\n    getNode: function() {\r\n      return this.trail.lastNode();\r\n    },\r\n    get node() { return this.getNode(); },\r\n    \r\n    changeLayer: function( newLayer ) {\r\n      // NOTE: DO NOT change _layerTrails somehow in this function. we don't make a defensive copy of that array during stitching!\r\n      if ( newLayer !== this.layer ) {\r\n        sceneryLayerLog && sceneryLayerLog( 'changing instance ' + this.trail.toString() + ' to layer ' + ( newLayer ? '#' + newLayer.id : 'null' ) );\r\n        this.layer && ( this.layer._instanceCount -= 1 );\r\n        this.layer = newLayer;\r\n        this.layer && ( this.layer._instanceCount += 1 );\r\n      }\r\n    },\r\n    \r\n    updateLayer: function() {\r\n      if ( this.layer !== this.oldLayer ) {\r\n        // we may have stale indices\r\n        this.reindex();\r\n        \r\n        if ( sceneryLayerLog ) {\r\n          if ( this.oldLayer && this.layer ) {\r\n            sceneryLayerLog( 'moving instance ' + this.trail.toString() + ' from layer #' + this.oldLayer.id + ' to layer #' + this.layer.id );\r\n          } else if ( this.layer ) {\r\n            sceneryLayerLog( 'adding instance ' + this.trail.toString() + ' to layer #' + this.layer.id );\r\n          } else {\r\n            sceneryLayerLog( 'remove instance ' + this.trail.toString() + ' from layer #' + this.oldLayer.id );\r\n          }\r\n        }\r\n        if ( this.oldLayer ) {\r\n          this.oldLayer.removeInstance( this );\r\n        }\r\n        if ( this.layer ) {\r\n          this.layer.addInstance( this );\r\n        }\r\n        this.oldLayer = this.layer;\r\n      }\r\n    },\r\n    \r\n    createChild: function( childNode, index ) {\r\n      var childTrail = this.trail.copy().addDescendant( childNode );\r\n      var childInstance = new scenery.Instance( childTrail, null, this );\r\n      sceneryLayerLog && sceneryLayerLog( 'Instance.createChild: ' + childInstance.toString() );\r\n      this.insertInstance( index, childInstance );\r\n      childInstance.getNode().addInstance( childInstance );\r\n      \r\n      return childInstance;\r\n    },\r\n    \r\n    addInstance: function( instance ) {\r\n      sceneryAssert && sceneryAssert( instance, 'Instance.addInstance cannot have falsy parameter' );\r\n      this.children.push( instance );\r\n    },\r\n    \r\n    insertInstance: function( index, instance ) {\r\n      sceneryAssert && sceneryAssert( instance, 'Instance.insert cannot have falsy instance parameter' );\r\n      sceneryAssert && sceneryAssert( index >= 0 && index <= this.children.length, 'Instance.insert has bad index ' + index + ' for length ' + this.children.length );\r\n      this.children.splice( index, 0, instance );\r\n    },\r\n    \r\n    removeInstance: function( index ) {\r\n      sceneryAssert && sceneryAssert( typeof index === 'number' );\r\n      this.children.splice( index, 1 );\r\n    },\r\n    \r\n    reindex: function() {\r\n      this.trail.reindex();\r\n    },\r\n    \r\n    // TODO: rename, so that it indicates that it removes the instance from the node\r\n    dispose: function() {\r\n      if ( this.layer ) {\r\n        this.changeLayer( null );\r\n        this.updateLayer();\r\n      }\r\n      this.parent = null;\r\n      this.children.length = 0;\r\n      this.getNode().removeInstance( this );\r\n      \r\n      if ( accessibility ) {\r\n        this.removePeers();\r\n        this.removeLiveRegions();\r\n      }\r\n    },\r\n    \r\n    equals: function( other ) {\r\n      sceneryAssert && sceneryAssert( ( this === other ) === this.trail.equals( other.trail ), 'We assume a 1-1 mapping from trails to instances' );\r\n      return this === other;\r\n    },\r\n    \r\n    // standard -1,0,1 comparison with another instance, as a total ordering from the render order\r\n    compare: function( other ) {\r\n      return this.trail.compare( other.trail );\r\n    },\r\n    \r\n    getLayerString: function() {\r\n      return this.layer ? ( this.layer.getName() + '#' + this.layer.getId() ) : '-';\r\n    },\r\n    \r\n    getTrailString: function() {\r\n      return this.trail.toString();\r\n    },\r\n    \r\n    toString: function() {\r\n      return '{' + this.getTrailString() + ', ' + this.getLayerString() + '}';\r\n    },\r\n    \r\n    getAffectedLayers: function() {\r\n      // TODO: optimize this using pre-recorded versions?\r\n      this.reindex();\r\n      return this.getScene().affectedLayers( this.trail );\r\n    },\r\n    \r\n    addPeers: function() {\r\n      var node = this.getNode();\r\n      var scene = this.getScene();\r\n      \r\n      var len = node._peers.length;\r\n      if ( len ) {\r\n        for ( var i = 0; i < len; i++ ) {\r\n          var desc = node._peers[i];\r\n          var peer = new scenery.AccessibilityPeer( this, desc.element, desc.options );\r\n          scene.addPeer( peer );\r\n          this.peers.push( peer );\r\n        }\r\n      }\r\n    },\r\n    \r\n    removePeers: function() {\r\n      var scene = this.getScene();\r\n      \r\n      var i = this.peers.length;\r\n      while ( i-- ) {\r\n        var peer = this.peers[i];\r\n        scene.removePeer( peer );\r\n        peer.dispose();\r\n      }\r\n      \r\n      this.peers.length = 0; // clear this.peers\r\n    },\r\n\r\n    addLiveRegions: function() {\r\n      var thisInstance = this;\r\n      var node = this.getNode();\r\n      var scene = this.getScene();\r\n\r\n      if ( node._liveRegions.length ) {\r\n        _.each( node._liveRegions, function( item ) {\r\n          var liveRegion = new scenery.LiveRegion( thisInstance, item.property, item.options );\r\n          scene.addLiveRegion( liveRegion );\r\n          thisInstance.liveRegions.push( liveRegion );\r\n        } );\r\n      }\r\n    },\r\n\r\n    removeLiveRegions: function() {\r\n      var scene = this.getScene();\r\n\r\n      _.each( this.liveRegions, function( liveRegion ) {\r\n        scene.removeLiveRegion( liveRegion );\r\n        liveRegion.dispose();\r\n      } );\r\n      \r\n      this.peers.length = 0; // clear this.peers\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Events from the Node\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    notifyVisibilityChange: function() {\r\n      sceneryEventLog && sceneryEventLog( 'notifyVisibilityChange: ' + this.trail.toString() + ', ' + this.getLayerString() );\r\n      \r\n      var affectedLayers = this.getAffectedLayers();\r\n      var i = affectedLayers.length;\r\n      while ( i-- ) {\r\n        affectedLayers[i].notifyVisibilityChange( this );\r\n      }\r\n    },\r\n    \r\n    notifyOpacityChange: function() {\r\n      sceneryEventLog && sceneryEventLog( 'notifyOpacityChange: ' + this.trail.toString() + ', ' + this.getLayerString() );\r\n      \r\n      var affectedLayers = this.getAffectedLayers();\r\n      var i = affectedLayers.length;\r\n      while ( i-- ) {\r\n        affectedLayers[i].notifyOpacityChange( this );\r\n      }\r\n    },\r\n    \r\n    notifyBeforeSelfChange: function() {\r\n      sceneryEventLog && sceneryEventLog( 'notifyBeforeSelfChange: ' + this.trail.toString() + ', ' + this.getLayerString() );\r\n      // TODO: Canvas will only need to be notified of these once in-between scene updates\r\n      // TODO: walk up the \"tree\" to see if any ancestors did this (in which case we don't need to)\r\n      // e.g. this.oldPaint = true, etc.\r\n      this.layer.notifyBeforeSelfChange( this );\r\n    },\r\n    \r\n    notifyBeforeSubtreeChange: function() {\r\n      sceneryEventLog && sceneryEventLog( 'notifyBeforeSubtreeChange: ' + this.trail.toString() + ', ' + this.getLayerString() );\r\n      \r\n      var affectedLayers = this.getAffectedLayers();\r\n      var i = affectedLayers.length;\r\n      while ( i-- ) {\r\n        affectedLayers[i].notifyBeforeSubtreeChange( this );\r\n      }\r\n    },\r\n    \r\n    notifyDirtySelfPaint: function() {\r\n      sceneryEventLog && sceneryEventLog( 'notifyDirtySelfPaint: ' + this.trail.toString() + ', ' + this.getLayerString() );\r\n      sceneryAssert && sceneryAssert( this.getNode().isPainted(), 'Instance needs to be painted for notifyDirtySelfPaint' );\r\n      this.layer.notifyDirtySelfPaint( this );\r\n    },\r\n    \r\n    // TODO: consider special post-transform type?\r\n    notifyDirtySubtreePaint: function() {\r\n      sceneryEventLog && sceneryEventLog( 'notifyDirtySubtreePaint: ' + this.trail.toString() + ', ' + this.getLayerString() );\r\n      \r\n      var affectedLayers = this.getAffectedLayers();\r\n      var i = affectedLayers.length;\r\n      while ( i-- ) {\r\n        affectedLayers[i].notifyDirtySubtreePaint( this );\r\n      }\r\n    },\r\n    \r\n    notifyDirtySubtreeBounds: function() {\r\n      sceneryEventLog && sceneryEventLog( 'notifyDirtySubtreeBounds: ' + this.trail.toString() + ', ' + this.getLayerString() );\r\n      \r\n      var affectedLayers = this.getAffectedLayers();\r\n      var i = affectedLayers.length;\r\n      while ( i-- ) {\r\n        affectedLayers[i].notifyDirtySubtreeBounds( this );\r\n      }\r\n    },\r\n    \r\n    notifyTransformChange: function() {\r\n      sceneryEventLog && sceneryEventLog( 'notifyTransformChange: ' + this.trail.toString() + ', ' + this.getLayerString() );\r\n      \r\n      var affectedLayers = this.getAffectedLayers();\r\n      var i = affectedLayers.length;\r\n      while ( i-- ) {\r\n        affectedLayers[i].notifyTransformChange( this );\r\n      }\r\n    },\r\n    \r\n    notifyBoundsAccuracyChange: function() {\r\n      sceneryEventLog && sceneryEventLog( 'notifyBoundsAccuracyChange: ' + this.trail.toString() + ', ' + this.getLayerString() );\r\n      this.layer.notifyBoundsAccuracyChange( this );\r\n    },\r\n    \r\n    notifyStitch: function( match ) {\r\n      sceneryEventLog && sceneryEventLog( 'notifyStitch: ' + this.trail.toString() + ' match:' + match + ', ' + this.getLayerString() );\r\n      this.getScene().stitch( match );\r\n    },\r\n    \r\n    markForLayerRefresh: function() {\r\n      sceneryEventLog && sceneryEventLog( 'markForLayerRefresh: ' + this.trail.toString() + ', ' + this.getLayerString() );\r\n      this.getScene().markSceneForLayerRefresh( this );\r\n    },\r\n    \r\n    markForInsertion: function( child, index ) {\r\n      sceneryEventLog && sceneryEventLog( 'markForInsertion: ' + this.trail.toString() + ' child:' + child.id + ', index: ' + index + ', ' + this.getLayerString() );\r\n      \r\n      this.reindex();\r\n      this.getScene().markSceneForInsertion( this, child, index );\r\n    },\r\n    \r\n    markForRemoval: function( child, index ) {\r\n      sceneryEventLog && sceneryEventLog( 'markForRemoval: ' + this.trail.toString() + ' child:' + child.id + ', index: ' + index + ', ' + this.getLayerString() );\r\n      \r\n      this.reindex();\r\n      this.getScene().markSceneForRemoval( this, child, index );\r\n    }\r\n  };\r\n  \r\n  return Instance;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * An interval between two Trails. A trail being null means either 'from the start' or 'to the end', depending\r\n * on whether it is the first or second parameter to the constructor.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/RenderInterval',['require','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  require( 'SCENERY/util/Trail' );\r\n  \r\n  // start and end are of type {Trail} or null (indicates all the way to the start / end)\r\n  scenery.RenderInterval = function RenderInterval( start, end ) {\r\n    sceneryAssert && sceneryAssert( !start || !end || start.compare( end ) <= 0, 'RenderInterval parameters must not be out of order' );\r\n    \r\n    this.start = start;\r\n    this.end = end;\r\n  };\r\n  var RenderInterval = scenery.RenderInterval;\r\n  \r\n  // assumes the intervals are disjoint, so we can just compare the start instance\r\n  RenderInterval.compareDisjoint = function( x, y ) {\r\n    // if they are both falsy, they should be the same\r\n    if ( !x.start && !y.start ) { return 0; }\r\n    \r\n    // otherwise, since we are comparing the starts, null would signify 'before anything'\r\n    if ( !x.start || !y.start ) { return x.start ? 1 : -1; }\r\n    \r\n    // otherwise our standard comparison\r\n    return x.start.compare( y.start );\r\n  };\r\n  \r\n  RenderInterval.prototype = {\r\n    constructor: RenderInterval,\r\n    \r\n    reindex: function() {\r\n      this.start && this.start.reindex();\r\n      this.end && this.end.reindex();\r\n    },\r\n    \r\n    isValidExclusive: function() {\r\n      // like construction, but with strict inequality\r\n      return !this.start || !this.end || this.start.compare( this.end ) < 0;\r\n    },\r\n    \r\n    /*\r\n     * Whether the union of this and the specified interval doesn't include any additional trails, when\r\n     * both are treated as exclusive endpoints (exclusive between a and b). We also make the assumption\r\n     * that a !== b || a === null for either interval, since otherwise it is not well defined.\r\n     */\r\n    exclusiveUnionable: function( interval ) {\r\n      sceneryAssert && sceneryAssert ( this.isValidExclusive(), 'exclusiveUnionable requires exclusive intervals' );\r\n      sceneryAssert && sceneryAssert ( interval.isValidExclusive(), 'exclusiveUnionable requires exclusive intervals' );\r\n      return ( !this.start || !interval.end || this.start.compare( interval.end ) === -1 ) &&\r\n             ( !this.end || !interval.start || this.end.compare( interval.start ) === 1 );\r\n    },\r\n    \r\n    exclusiveContains: function( trail ) {\r\n      sceneryAssert && sceneryAssert( trail );\r\n      return ( !this.start || this.start.compare( trail ) < 0 ) && ( !this.end || this.end.compare( trail ) > 0 );\r\n    },\r\n    \r\n    union: function( interval ) {\r\n      // falsy checks since if a or b is null, we want that bound to be null\r\n      var thisA = ( !this.start || ( interval.start && this.start.compare( interval.start ) === -1 ) );\r\n      var thisB = ( !this.end || ( interval.end && this.end.compare( interval.end ) === 1 ) );\r\n      \r\n      return new RenderInterval(\r\n        thisA ? this.start : interval.start,\r\n        thisB ? this.end : interval.end\r\n      );\r\n    },\r\n    \r\n    toString: function() {\r\n      return '[' + ( this.start ? this.start.toString() : this.start ) + ',' + ( this.end ? this.end.toString() : this.end ) + ']';\r\n    }\r\n  };\r\n  \r\n  return RenderInterval;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/*\r\n * A pointer is an abstraction that includes a mouse and touch points (and possibly keys).\r\n *\r\n * TODO: add state tracking (dragging/panning/etc.) to pointer for convenience\r\n * TODO: consider an 'active' flag?\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/input/Pointer',['require','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  scenery.Pointer = function Pointer() {\r\n    this.listeners = [];\r\n  };\r\n  var Pointer = scenery.Pointer;\r\n  \r\n  Pointer.prototype = {\r\n    constructor: Pointer,\r\n    \r\n    addInputListener: function( listener ) {\r\n      sceneryAssert && sceneryAssert( !_.contains( this.listeners, listener ) );\r\n      \r\n      this.listeners.push( listener );\r\n    },\r\n    \r\n    removeInputListener: function( listener ) {\r\n      var index = _.indexOf( this.listeners, listener );\r\n      sceneryAssert && sceneryAssert( index !== -1 );\r\n      \r\n      this.listeners.splice( index, 1 );\r\n    }\r\n  };\r\n  \r\n  return Pointer;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Tracks the mouse state\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/input/Mouse',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Pointer = require( 'SCENERY/input/Pointer' ); // inherits from Pointer\r\n  \r\n  scenery.Mouse = function Mouse() {\r\n    Pointer.call( this );\r\n    \r\n    this.point = null;\r\n    \r\n    this.leftDown = false;\r\n    this.middleDown = false;\r\n    this.rightDown = false;\r\n    \r\n    this.isMouse = true;\r\n    \r\n    this.trail = null;\r\n    \r\n    this.type = 'mouse';\r\n  };\r\n  var Mouse = scenery.Mouse;\r\n  \r\n  inherit( Pointer, Mouse, {\r\n    down: function( point, event ) {\r\n      this.point = point;\r\n      switch( event.button ) {\r\n        case 0: this.leftDown = true; break;\r\n        case 1: this.middleDown = true; break;\r\n        case 2: this.rightDown = true; break;\r\n      }\r\n    },\r\n    \r\n    up: function( point, event ) {\r\n      this.point = point;\r\n      switch( event.button ) {\r\n        case 0: this.leftDown = false; break;\r\n        case 1: this.middleDown = false; break;\r\n        case 2: this.rightDown = false; break;\r\n      }\r\n    },\r\n    \r\n    move: function( point, event ) {\r\n      this.point = point;\r\n    },\r\n    \r\n    over: function( point, event ) {\r\n      this.point = point;\r\n    },\r\n    \r\n    out: function( point, event ) {\r\n      // TODO: how to handle the mouse out-of-bounds\r\n      this.point = null;\r\n    },\r\n    \r\n    toString: function() {\r\n      return 'Mouse';\r\n    }\r\n  } );\r\n  \r\n  return Mouse;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Tracks a single touch point\r\n *\r\n * IE guidelines for Touch-friendly sites: http://blogs.msdn.com/b/ie/archive/2012/04/20/guidelines-for-building-touch-friendly-sites.aspx\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/input/Touch',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer\r\n  \r\n  scenery.Touch = function Touch( id, point, event ) {\r\n    Pointer.call( this );\r\n    \r\n    this.id = id;\r\n    this.point = point;\r\n    this.isTouch = true;\r\n    this.trail = null;\r\n    \r\n    this.type = 'touch';\r\n  };\r\n  var Touch = scenery.Touch;\r\n  \r\n  inherit( Pointer, Touch, {\r\n    move: function( point, event ) {\r\n      this.point = point;\r\n    },\r\n    \r\n    end: function( point, event ) {\r\n      this.point = point;\r\n    },\r\n    \r\n    cancel: function( point, event ) {\r\n      this.point = point;\r\n    },\r\n    \r\n    toString: function() {\r\n      return 'Touch#' + this.id;\r\n    }\r\n  } );\r\n  \r\n  return Touch;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Tracks a stylus ('pen') or something with tilt and pressure information\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/input/Pen',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Pointer = require( 'SCENERY/input/Pointer' ); // extends Pointer\r\n  \r\n  scenery.Pen = function Pen( id, point, event ) {\r\n    Pointer.call( this );\r\n    \r\n    this.id = id;\r\n    this.point = point;\r\n    this.isPen = true;\r\n    this.trail = null;\r\n    \r\n    this.type = 'pen';\r\n  };\r\n  var Pen = scenery.Pen;\r\n  \r\n  inherit( Pointer, Pen, {\r\n    move: function( point, event ) {\r\n      this.point = point;\r\n    },\r\n    \r\n    end: function( point, event ) {\r\n      this.point = point;\r\n    },\r\n    \r\n    cancel: function( point, event ) {\r\n      this.point = point;\r\n    },\r\n    \r\n    toString: function() {\r\n      return 'Pen#' + this.id;\r\n    }\r\n  } );\r\n  \r\n  return Pen;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Tracks a single key-press\r\n *\r\n * TODO: general key-press implementation\r\n * TODO: consider separate handling for keys in general.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/input/Key',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/input/Pointer'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Pointer = require( 'SCENERY/input/Pointer' ); // Inherits from Pointer\r\n  \r\n  scenery.Key = function Key( event ) {\r\n    Pointer.call( this );\r\n    \r\n    this.event = event; // event.keyCode event.charCode\r\n    this.isKey = true; // compared to isMouse/isPen/isTouch\r\n    this.trail = null;\r\n    this.type = 'key';\r\n  };\r\n  var Key = scenery.Key;\r\n  \r\n  inherit( Pointer, Key, {\r\n    \r\n  } );\r\n  \r\n  return Key;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/*\r\n * An event in Scenery that has similar event-handling characteristics to DOM events.\r\n * The original DOM event (if any) is available as event.domEvent.\r\n *\r\n * Multiple events can be triggered by a single domEvent, so don't assume it is unique.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n \r\ndefine( 'SCENERY/input/Event',['require','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  scenery.Event = function Event( args ) {\r\n    // ensure that all of the required args are supplied\r\n    sceneryAssert && sceneryAssert( args.trail &&\r\n                      args.type &&\r\n                      args.pointer &&\r\n                      args.target, 'Missing required scenery.Event argument' );\r\n    \r\n    this.handled = false;\r\n    this.aborted = false;\r\n    \r\n    // {Trail} path to the leaf-most node, ordered list, from root to leaf\r\n    this.trail = args.trail;\r\n    \r\n    // {String} what event was triggered on the listener\r\n    this.type = args.type;\r\n    \r\n    // {Pointer}\r\n    this.pointer = args.pointer;\r\n    \r\n    // raw DOM InputEvent (TouchEvent, PointerEvent, MouseEvent,...)\r\n    this.domEvent = args.domEvent;\r\n    \r\n    // {Node} whatever node you attached the listener to, or null when firing events on a Pointer\r\n    this.currentTarget = args.currentTarget;\r\n    \r\n    // {Node} leaf-most node in trail\r\n    this.target = args.target;\r\n    \r\n    // TODO: add extended information based on an event here?\r\n  };\r\n  var Event = scenery.Event;\r\n  \r\n  Event.prototype = {\r\n    constructor: Event,\r\n    \r\n    // like DOM Event.stopPropagation(), but named differently to indicate it doesn't fire that behavior on the underlying DOM event\r\n    handle: function() {\r\n      this.handled = true;\r\n    },\r\n    \r\n    // like DOM Event.stopImmediatePropagation(), but named differently to indicate it doesn't fire that behavior on the underlying DOM event\r\n    abort: function() {\r\n      this.handled = true;\r\n      this.aborted = true;\r\n    }\r\n  };\r\n  \r\n  return Event;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * API for handling mouse / touch / keyboard events.\r\n *\r\n * A 'pointer' is an abstract way of describing either the mouse, a single touch point, or a key being pressed.\r\n * touch points and key presses go away after being released, whereas the mouse 'pointer' is persistent.\r\n *\r\n * Events will be called on listeners with a single event object. Supported event types are:\r\n * 'up', 'down', 'out', 'over', 'enter', 'exit', 'move', and 'cancel'. Scenery also supports more specific event\r\n * types that constrain the type of pointer, so 'mouse' + type, 'touch' + type and 'pen' + type will fire\r\n * on each listener before the generic event would be fined. E.g. for mouse movement, listener.mousemove will be\r\n * fired before listener.move.\r\n *\r\n * DOM Level 3 events spec: http://www.w3.org/TR/DOM-Level-3-Events/\r\n * Touch events spec: http://www.w3.org/TR/touch-events/\r\n * Pointer events spec draft: https://dvcs.w3.org/hg/pointerevents/raw-file/tip/pointerEvents.html\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/input/Input',['require','SCENERY/scenery','SCENERY/util/Trail','SCENERY/input/Mouse','SCENERY/input/Touch','SCENERY/input/Pen','SCENERY/input/Key','SCENERY/input/Event'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  require( 'SCENERY/util/Trail' );\r\n  require( 'SCENERY/input/Mouse' );\r\n  require( 'SCENERY/input/Touch' );\r\n  require( 'SCENERY/input/Pen' );\r\n  require( 'SCENERY/input/Key' );\r\n  require( 'SCENERY/input/Event' );\r\n  \r\n  // listenerTarget is the DOM node (window/document/element) to which DOM event listeners will be attached\r\n  scenery.Input = function Input( scene, listenerTarget, batchDOMEvents ) {\r\n    this.scene = scene;\r\n    this.listenerTarget = listenerTarget;\r\n    this.batchDOMEvents = batchDOMEvents;\r\n    \r\n    this.batchedCallbacks = [];\r\n    \r\n    this.mouse = new scenery.Mouse();\r\n    \r\n    this.pointers = [ this.mouse ];\r\n    \r\n    this.listenerReferences = [];\r\n    \r\n    this.eventLog = [];     // written when recording event input. can be overwritten to the empty array to reset. Strings relative to this class (prefix \"scene.input.\")\r\n    this.logEvents = false; // can be set to true to cause Scenery to record all input calls to eventLog\r\n  };\r\n  var Input = scenery.Input;\r\n  \r\n  Input.prototype = {\r\n    constructor: Input,\r\n    \r\n    addPointer: function( pointer ) {\r\n      this.pointers.push( pointer );\r\n    },\r\n    \r\n    removePointer: function( pointer ) {\r\n      // sanity check version, will remove all instances\r\n      for ( var i = this.pointers.length - 1; i >= 0; i-- ) {\r\n        if ( this.pointers[i] === pointer ) {\r\n          this.pointers.splice( i, 1 );\r\n        }\r\n      }\r\n    },\r\n    \r\n    findTouchById: function( id ) {\r\n      var i = this.pointers.length;\r\n      while ( i-- ) {\r\n        var pointer = this.pointers[i];\r\n        if ( pointer.id === id ) {\r\n          return pointer;\r\n        }\r\n      }\r\n      return undefined;\r\n    },\r\n    \r\n    findKeyByEvent: function( event ) {\r\n      sceneryAssert && sceneryAssert( event.keyCode && event.charCode, 'Assumes the KeyboardEvent has keyCode and charCode properties' );\r\n      var result = _.find( this.pointers, function( pointer ) {\r\n        // TODO: also check location (if that exists), so we don't mix up left and right shift, etc.\r\n        return pointer.keyCode === event.keyCode && pointer.charCode === event.charCode;\r\n      } );\r\n      // sceneryAssert && sceneryAssert( result, 'No key found for the combination of key:' + event.key + ' and location:' + event.location );\r\n      return result;\r\n    },\r\n    \r\n    mouseDown: function( point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'mouseDown(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      this.mouse.down( point, event );\r\n      this.downEvent( this.mouse, event );\r\n    },\r\n    \r\n    mouseUp: function( point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'mouseUp(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      this.mouse.up( point, event );\r\n      this.upEvent( this.mouse, event );\r\n    },\r\n    \r\n    mouseUpImmediate: function( point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'mouseUpImmediate(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      this.upImmediateEvent( this.mouse, event );\r\n    },\r\n    \r\n    mouseMove: function( point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'mouseMove(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      this.mouse.move( point, event );\r\n      this.moveEvent( this.mouse, event );\r\n    },\r\n    \r\n    mouseOver: function( point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'mouseOver(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      this.mouse.over( point, event );\r\n      // TODO: how to handle mouse-over (and log it)\r\n    },\r\n    \r\n    mouseOut: function( point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'mouseOut(' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      this.mouse.out( point, event );\r\n      // TODO: how to handle mouse-out (and log it)\r\n    },\r\n    \r\n    keyDown: function( event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'keyDown(' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var key = new scenery.Key( event );\r\n      this.addPointer( key );\r\n      \r\n      var trail = this.scene.getTrailFromKeyboardFocus();\r\n      this.dispatchEvent( trail, 'keyDown', key, event, true );\r\n    },\r\n    \r\n    keyUp: function( event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'keyUp(' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var key = this.findKeyByEvent( event );\r\n      if ( key ) {\r\n        this.removePointer( key );\r\n        \r\n        var trail = this.scene.getTrailFromKeyboardFocus();\r\n        this.dispatchEvent( trail, 'keyUp', key, event, true );\r\n      }\r\n    },\r\n    \r\n    keyPress: function( event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'keyPress(' + Input.serializeDomEvent( event ) + ');' ); }\r\n      // NOTE: do we even need keyPress?\r\n    },\r\n    \r\n    // called for each touch point\r\n    touchStart: function( id, point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'touchStart(\\'' + id + '\\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var touch = new scenery.Touch( id, point, event );\r\n      this.addPointer( touch );\r\n      this.downEvent( touch, event );\r\n    },\r\n    \r\n    touchEnd: function( id, point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'touchEnd(\\'' + id + '\\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var touch = this.findTouchById( id );\r\n      if ( touch ) {\r\n        touch.end( point, event );\r\n        this.removePointer( touch );\r\n        this.upEvent( touch, event );\r\n      } else {\r\n        sceneryAssert && sceneryAssert( false, 'Touch not found for touchEnd: ' + id );\r\n      }\r\n    },\r\n    \r\n    touchEndImmediate: function( id, point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'touchEndImmediate(\\'' + id + '\\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var touch = this.findTouchById( id );\r\n      if ( touch ) {\r\n        this.upImmediateEvent( touch, event );\r\n      } else {\r\n        sceneryAssert && sceneryAssert( false, 'Touch not found for touchEndImmediate: ' + id );\r\n      }\r\n    },\r\n    \r\n    touchMove: function( id, point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'touchMove(\\'' + id + '\\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var touch = this.findTouchById( id );\r\n      if ( touch ) {\r\n        touch.move( point, event );\r\n        this.moveEvent( touch, event );\r\n      } else {\r\n        sceneryAssert && sceneryAssert( false, 'Touch not found for touchMove: ' + id );\r\n      }\r\n    },\r\n    \r\n    touchCancel: function( id, point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'touchCancel(\\'' + id + '\\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var touch = this.findTouchById( id );\r\n      if ( touch ) {\r\n        touch.cancel( point, event );\r\n        this.removePointer( touch );\r\n        this.cancelEvent( touch, event );\r\n      } else {\r\n        sceneryAssert && sceneryAssert( false, 'Touch not found for touchCancel: ' + id );\r\n      }\r\n    },\r\n    \r\n    // called for each touch point\r\n    penStart: function( id, point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'penStart(\\'' + id + '\\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var pen = new scenery.Pen( id, point, event );\r\n      this.addPointer( pen );\r\n      this.downEvent( pen, event );\r\n    },\r\n    \r\n    penEnd: function( id, point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'penEnd(\\'' + id + '\\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var pen = this.findTouchById( id );\r\n      if ( pen ) {\r\n        pen.end( point, event );\r\n        this.removePointer( pen );\r\n        this.upEvent( pen, event );\r\n      } else {\r\n        sceneryAssert && sceneryAssert( false, 'Pen not found for penEnd: ' + id );\r\n      }\r\n    },\r\n    \r\n    penEndImmediate: function( id, point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'penEndImmediate(\\'' + id + '\\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var pen = this.findTouchById( id );\r\n      if ( pen ) {\r\n        this.upImmediateEvent( pen, event );\r\n      } else {\r\n        sceneryAssert && sceneryAssert( false, 'Pen not found for penEndImmediate: ' + id );\r\n      }\r\n    },\r\n    \r\n    penMove: function( id, point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'penMove(\\'' + id + '\\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var pen = this.findTouchById( id );\r\n      if ( pen ) {\r\n        pen.move( point, event );\r\n        this.moveEvent( pen, event );\r\n      } else {\r\n        sceneryAssert && sceneryAssert( false, 'Pen not found for penMove: ' + id );\r\n      }\r\n    },\r\n    \r\n    penCancel: function( id, point, event ) {\r\n      if ( this.logEvents ) { this.eventLog.push( 'penCancel(\\'' + id + '\\',' + Input.serializeVector2( point ) + ',' + Input.serializeDomEvent( event ) + ');' ); }\r\n      var pen = this.findTouchById( id );\r\n      if ( pen ) {\r\n        pen.cancel( point, event );\r\n        this.removePointer( pen );\r\n        this.cancelEvent( pen, event );\r\n      } else {\r\n        sceneryAssert && sceneryAssert( false, 'Pen not found for penCancel: ' + id );\r\n      }\r\n    },\r\n    \r\n    pointerDown: function( id, type, point, event ) {\r\n      switch ( type ) {\r\n        case 'mouse':\r\n          this.mouseDown( point, event );\r\n          break;\r\n        case 'touch':\r\n          this.touchStart( id, point, event );\r\n          break;\r\n        case 'pen':\r\n          this.penStart( id, point, event );\r\n          break;\r\n        default:\r\n          if ( console.log ) {\r\n            console.log( 'Unknown pointer type: ' + type );\r\n          }\r\n      }\r\n    },\r\n    \r\n    pointerUp: function( id, type, point, event ) {\r\n      switch ( type ) {\r\n        case 'mouse':\r\n          this.mouseUp( point, event );\r\n          break;\r\n        case 'touch':\r\n          this.touchEnd( id, point, event );\r\n          break;\r\n        case 'pen':\r\n          this.penEnd( id, point, event );\r\n          break;\r\n        default:\r\n          if ( console.log ) {\r\n            console.log( 'Unknown pointer type: ' + type );\r\n          }\r\n      }\r\n    },\r\n    \r\n    pointerUpImmediate: function( id, type, point, event ) {\r\n      switch ( type ) {\r\n        case 'mouse':\r\n          this.mouseUpImmediate( point, event );\r\n          break;\r\n        case 'touch':\r\n          this.touchEndImmediate( id, point, event );\r\n          break;\r\n        case 'pen':\r\n          this.penEndImmediate( id, point, event );\r\n          break;\r\n        default:\r\n          if ( console.log ) {\r\n            console.log( 'Unknown pointer type: ' + type );\r\n          }\r\n      }\r\n    },\r\n    \r\n    pointerCancel: function( id, type, point, event ) {\r\n      switch ( type ) {\r\n        case 'mouse':\r\n          if ( console && console.log ) {\r\n            console.log( 'WARNING: Pointer mouse cancel was received' );\r\n          }\r\n          break;\r\n        case 'touch':\r\n          this.touchCancel( id, point, event );\r\n          break;\r\n        case 'pen':\r\n          this.penCancel( id, point, event );\r\n          break;\r\n        default:\r\n          if ( console.log ) {\r\n            console.log( 'Unknown pointer type: ' + type );\r\n          }\r\n      }\r\n    },\r\n    \r\n    pointerMove: function( id, type, point, event ) {\r\n      switch ( type ) {\r\n        case 'mouse':\r\n          this.mouseMove( point, event );\r\n          break;\r\n        case 'touch':\r\n          this.touchMove( id, point, event );\r\n          break;\r\n        case 'pen':\r\n          this.penMove( id, point, event );\r\n          break;\r\n        default:\r\n          if ( console.log ) {\r\n            console.log( 'Unknown pointer type: ' + type );\r\n          }\r\n      }\r\n    },\r\n    \r\n    pointerOver: function( id, type, point, event ) {\r\n      \r\n    },\r\n    \r\n    pointerOut: function( id, type, point, event ) {\r\n      \r\n    },\r\n    \r\n    pointerEnter: function( id, type, point, event ) {\r\n      \r\n    },\r\n    \r\n    pointerLeave: function( id, type, point, event ) {\r\n      \r\n    },\r\n    \r\n    upEvent: function( pointer, event ) {\r\n      var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );\r\n      \r\n      this.dispatchEvent( trail, 'up', pointer, event, true );\r\n      \r\n      // touch pointers are transient, so fire exit/out to the trail afterwards\r\n      if ( pointer.isTouch ) {\r\n        this.exitEvents( pointer, event, trail, 0, true );\r\n      }\r\n      \r\n      pointer.trail = trail;\r\n    },\r\n    \r\n    upImmediateEvent: function( pointer, event ) {\r\n      var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );\r\n      \r\n      this.dispatchEvent( trail, 'upImmediate', pointer, event, true );\r\n    },\r\n    \r\n    downEvent: function( pointer, event ) {\r\n      var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );\r\n      \r\n      // touch pointers are transient, so fire enter/over to the trail first\r\n      if ( pointer.isTouch ) {\r\n        this.enterEvents( pointer, event, trail, 0, true );\r\n      }\r\n      \r\n      this.dispatchEvent( trail, 'down', pointer, event, true );\r\n      \r\n      pointer.trail = trail;\r\n    },\r\n    \r\n    moveEvent: function( pointer, event ) {\r\n      this.branchChangeEvents( pointer, event, true );\r\n    },\r\n    \r\n    cancelEvent: function( pointer, event ) {\r\n      var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );\r\n      \r\n      this.dispatchEvent( trail, 'cancel', pointer, event, true );\r\n      \r\n      // touch pointers are transient, so fire exit/out to the trail afterwards\r\n      if ( pointer.isTouch ) {\r\n        this.exitEvents( pointer, event, trail, 0, true );\r\n      }\r\n      \r\n      pointer.trail = trail;\r\n    },\r\n    \r\n    branchChangeEvents: function( pointer, event, isMove ) {\r\n      var trail = this.scene.trailUnderPointer( pointer ) || new scenery.Trail( this.scene );\r\n      var oldTrail = pointer.trail || new scenery.Trail( this.scene ); // TODO: consider a static trail reference\r\n      \r\n      var lastNodeChanged = oldTrail.lastNode() !== trail.lastNode();\r\n      if ( !lastNodeChanged && !isMove ) {\r\n        // bail out if nothing needs to be done\r\n        return;\r\n      }\r\n      \r\n      var branchIndex;\r\n      \r\n      for ( branchIndex = 0; branchIndex < Math.min( trail.length, oldTrail.length ); branchIndex++ ) {\r\n        if ( trail.nodes[branchIndex] !== oldTrail.nodes[branchIndex] ) {\r\n          break;\r\n        }\r\n      }\r\n      \r\n      // event order matches http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order\r\n      if ( isMove ) {\r\n        this.dispatchEvent( trail, 'move', pointer, event, true );\r\n      }\r\n      \r\n      // we want to approximately mimic http://www.w3.org/TR/DOM-Level-3-Events/#events-mouseevent-event-order\r\n      // TODO: if a node gets moved down 1 depth, it may see both an exit and enter?\r\n      this.exitEvents( pointer, event, oldTrail, branchIndex, lastNodeChanged );\r\n      this.enterEvents( pointer, event, trail, branchIndex, lastNodeChanged );\r\n      \r\n      pointer.trail = trail;\r\n    },\r\n    \r\n    enterEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {\r\n      if ( trail.length > branchIndex ) {\r\n        for ( var newIndex = trail.length - 1; newIndex >= branchIndex; newIndex-- ) {\r\n          this.dispatchEvent( trail.slice( 0, newIndex + 1 ), 'enter', pointer, event, false );\r\n        }\r\n      }\r\n      \r\n      if ( lastNodeChanged ) {\r\n        this.dispatchEvent( trail, 'over', pointer, event, true );\r\n      }\r\n    },\r\n    \r\n    exitEvents: function( pointer, event, trail, branchIndex, lastNodeChanged ) {\r\n      if ( lastNodeChanged ) {\r\n        this.dispatchEvent( trail, 'out', pointer, event, true );\r\n      }\r\n      \r\n      if ( trail.length > branchIndex ) {\r\n        for ( var oldIndex = branchIndex; oldIndex < trail.length; oldIndex++ ) {\r\n          this.dispatchEvent( trail.slice( 0, oldIndex + 1 ), 'exit', pointer, event, false );\r\n        }\r\n      }\r\n    },\r\n    \r\n    validatePointers: function() {\r\n      var that = this;\r\n      \r\n      var i = this.pointers.length;\r\n      while ( i-- ) {\r\n        var pointer = this.pointers[i];\r\n        if ( pointer.point ) {\r\n          that.branchChangeEvents( pointer, null, false );\r\n        }\r\n      }\r\n    },\r\n    \r\n    dispatchEvent: function( trail, type, pointer, event, bubbles ) {\r\n      sceneryEventLog && sceneryEventLog( 'Input: ' + type + ' on ' + trail.toString() + ' for pointer ' + pointer.toString() );\r\n      if ( !trail ) {\r\n        try {\r\n          throw new Error( 'falsy trail for dispatchEvent' );\r\n        } catch ( e ) {\r\n          console.log( e.stack );\r\n          throw e;\r\n        }\r\n      }\r\n      \r\n      // TODO: is there a way to make this event immutable?\r\n      var inputEvent = new scenery.Event( {\r\n        trail: trail, // {Trail} path to the leaf-most node, ordered list, from root to leaf\r\n        type: type, // {String} what event was triggered on the listener\r\n        pointer: pointer, // {Pointer}\r\n        domEvent: event, // raw DOM InputEvent (TouchEvent, PointerEvent, MouseEvent,...)\r\n        currentTarget: null, // {Node} whatever node you attached the listener to, null when passed to a Pointer,\r\n        target: trail.lastNode() // {Node} leaf-most node in trail\r\n      } );\r\n      \r\n      // first run through the pointer's listeners to see if one of them will handle the event\r\n      this.dispatchToPointer( type, pointer, inputEvent );\r\n      \r\n      // if not yet handled, run through the trail in order to see if one of them will handle the event\r\n      // at the base of the trail should be the scene node, so the scene will be notified last\r\n      this.dispatchToTargets( trail, pointer, type, inputEvent, bubbles );\r\n      \r\n      // TODO: better interactivity handling?\r\n      if ( !trail.lastNode().interactive && !pointer.isKey && event && event.preventDefault ) {\r\n        event.preventDefault();\r\n      }\r\n    },\r\n    \r\n    // TODO: reduce code sharing between here and dispatchToTargets!\r\n    dispatchToPointer: function( type, pointer, inputEvent ) {\r\n      if ( inputEvent.aborted || inputEvent.handled ) {\r\n        return;\r\n      }\r\n      \r\n      var specificType = pointer.type + type; // e.g. mouseup, touchup, keyup\r\n      \r\n      var pointerListeners = pointer.listeners.slice( 0 ); // defensive copy\r\n      for ( var i = 0; i < pointerListeners.length; i++ ) {\r\n        var listener = pointerListeners[i];\r\n        \r\n        // if a listener returns true, don't handle any more\r\n        var aborted = false;\r\n        \r\n        if ( !aborted && listener[specificType] ) {\r\n          listener[specificType]( inputEvent );\r\n          aborted = inputEvent.aborted;\r\n        }\r\n        if ( !aborted && listener[type] ) {\r\n          listener[type]( inputEvent );\r\n          aborted = inputEvent.aborted;\r\n        }\r\n        \r\n        // bail out if the event is aborted, so no other listeners are triggered\r\n        if ( aborted ) {\r\n          return;\r\n        }\r\n      }\r\n    },\r\n    \r\n    dispatchToTargets: function( trail, pointer, type, inputEvent, bubbles ) {\r\n      if ( inputEvent.aborted || inputEvent.handled ) {\r\n        return;\r\n      }\r\n      \r\n      var specificType = pointer.type + type; // e.g. mouseup, touchup, keyup\r\n      \r\n      for ( var i = trail.length - 1; i >= 0; bubbles ? i-- : i = -1 ) {\r\n        var target = trail.nodes[i];\r\n        inputEvent.currentTarget = target;\r\n        \r\n        var listeners = target.getInputListeners();\r\n        \r\n        for ( var k = 0; k < listeners.length; k++ ) {\r\n          var listener = listeners[k];\r\n          \r\n          // if a listener returns true, don't handle any more\r\n          var aborted = false;\r\n          \r\n          if ( !aborted && listener[specificType] ) {\r\n            listener[specificType]( inputEvent );\r\n            aborted = inputEvent.aborted;\r\n          }\r\n          if ( !aborted && listener[type] ) {\r\n            listener[type]( inputEvent );\r\n            aborted = inputEvent.aborted;\r\n          }\r\n          \r\n          // bail out if the event is aborted, so no other listeners are triggered\r\n          if ( aborted ) {\r\n            return;\r\n          }\r\n        }\r\n        \r\n        // if the input event was handled, don't follow the trail down another level\r\n        if ( inputEvent.handled ) {\r\n          return;\r\n        }\r\n      }\r\n    },\r\n    \r\n    addListener: function( type, callback, useCapture ) {\r\n      var input = this;\r\n      \r\n      //Cancel propagation of mouse events but not key events.  Key Events need to propagate for tab navigability\r\n      var usePreventDefault = type !== 'keydown' && type !== 'keyup' && type !== 'keypress';\r\n      \r\n      if ( this.batchDOMEvents ) {\r\n        var batchedCallback = function batchedEvent( domEvent ) {\r\n          sceneryEventLog && sceneryEventLog( 'Batching event for ' + type );\r\n          \r\n          if ( usePreventDefault ) {\r\n            domEvent.preventDefault(); // TODO: should we batch the events in a different place so we don't preventDefault on something bad?\r\n          }\r\n          input.batchedCallbacks.push( function batchedEventCallback() {\r\n            // process whether anything under the pointers changed before running additional input events\r\n            input.validatePointers();\r\n            if ( input.logEvents ) { input.eventLog.push( 'validatePointers();' ); }\r\n            \r\n            callback( domEvent );\r\n          } );\r\n        };\r\n        this.listenerTarget.addEventListener( type, batchedCallback, useCapture );\r\n        this.listenerReferences.push( { type: type, callback: batchedCallback, useCapture: useCapture } );\r\n      } else {\r\n        this.listenerTarget.addEventListener( type, callback, useCapture );\r\n        this.listenerReferences.push( { type: type, callback: function synchronousEvent( domEvent ) {\r\n          sceneryEventLog && sceneryEventLog( 'Running event for ' + type );\r\n          \r\n          // process whether anything under the pointers changed before running additional input events\r\n          input.validatePointers();\r\n          if ( input.logEvents ) { input.eventLog.push( 'validatePointers();' ); }\r\n          \r\n          callback( domEvent );\r\n        }, useCapture: useCapture } );\r\n      }\r\n    },\r\n    \r\n    // temporary, for mouse events\r\n    addImmediateListener: function( type, callback, useCapture ) {\r\n      var input = this;\r\n      \r\n      this.listenerTarget.addEventListener( type, callback, useCapture );\r\n      this.listenerReferences.push( { type: type, callback: function immediateEvent( domEvent ) {\r\n        sceneryEventLog && sceneryEventLog( 'Running immediate event for ' + type );\r\n        \r\n        // process whether anything under the pointers changed before running additional input events\r\n        // input.validatePointers();\r\n        // if ( input.logEvents ) { input.eventLog.push( 'validatePointers();' ); }\r\n        \r\n        callback( domEvent );\r\n      }, useCapture: useCapture } );\r\n    },\r\n    \r\n    disposeListeners: function() {\r\n      var input = this;\r\n      _.each( this.listenerReferences, function( ref ) {\r\n        input.listenerTarget.removeEventListener( ref.type, ref.callback, ref.useCapture );\r\n      } );\r\n    },\r\n    \r\n    fireBatchedEvents: function() {\r\n      if ( this.batchedCallbacks.length ) {\r\n        sceneryEventLog && sceneryEventLog( 'Input.fireBatchedEvents length:' + this.batchedCallbacks.length );\r\n        var len = this.batchedCallbacks.length;\r\n        for ( var i = 0; i < len; i++ ) {\r\n          this.batchedCallbacks[i]();\r\n        }\r\n        this.batchedCallbacks = [];\r\n      }\r\n    }\r\n  };\r\n  \r\n  Input.serializeDomEvent = function serializeDomEvent( domEvent ) {\r\n    var lines = [];\r\n    for ( var prop in domEvent ) {\r\n      if ( domEvent.hasOwnProperty( prop ) ) {\r\n        // stringifying dom event object properties can cause circular references, so we avoid that completely\r\n        if ( prop === 'touches' || prop === 'targetTouches' || prop === 'changedTouches' ) {\r\n          var arr = [];\r\n          for ( var i = 0; i < domEvent[prop].length; i++ ) {\r\n            // according to spec (http://www.w3.org/TR/touch-events/), this is not an Array, but a TouchList\r\n            var touch = domEvent[prop].item( i );\r\n            \r\n            arr.push( serializeDomEvent( touch ) );\r\n          }\r\n          lines.push( prop + ':[' + arr.join( ',' ) + ']' );\r\n        } else {\r\n          lines.push( prop + ':' + ( ( typeof domEvent[prop] === 'object' ) && ( domEvent[prop] !== null ) ? '{}' : JSON.stringify( domEvent[prop] ) ) );\r\n        }\r\n      }\r\n    }\r\n    return '{' + lines.join( ',' ) + '}';\r\n  };\r\n  \r\n  Input.serializeVector2 = function( vector ) {\r\n    return 'dot(' + vector.x + ',' + vector.y + ')';\r\n  };\r\n  \r\n  return Input;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * A conceptual boundary between layers, where it is optional to have information about a previous or next layer.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/layers/LayerBoundary',['require','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  scenery.LayerBoundary = function LayerBoundary() {\r\n    // layer types before and after the boundary. null indicates the lack of information (first or last layer)\r\n    this.previousLayerType = null;\r\n    this.nextLayerType = null;\r\n    \r\n    // trails to the closest nodes with isPainted() === true before and after the boundary\r\n    this.previousPaintedTrail = null;\r\n    this.nextPaintedTrail = null;\r\n  };\r\n  var LayerBoundary = scenery.LayerBoundary;\r\n  \r\n  LayerBoundary.prototype = {\r\n    constructor: LayerBoundary,\r\n    \r\n    hasPrevious: function() {\r\n      return !!this.previousPaintedTrail;\r\n    },\r\n    \r\n    hasNext: function() {\r\n      return !!this.nextPaintedTrail;\r\n    },\r\n    \r\n    // reindexes the trails\r\n    reindex: function() {\r\n      this.previousPaintedTrail && this.previousPaintedTrail.reindex();\r\n      this.nextPaintedTrail && this.nextPaintedTrail.reindex();\r\n    },\r\n    \r\n    // assumes that trail is reindexed\r\n    equivalentPreviousTrail: function( trail ) {\r\n      if ( this.previousPaintedTrail && trail ) {\r\n        this.previousPaintedTrail.reindex();\r\n        return this.previousPaintedTrail.equals( trail );\r\n      } else {\r\n        // check that handles null versions properly\r\n        return this.previousPaintedTrail === trail;\r\n      }\r\n    },\r\n    \r\n    equivalentNextTrail: function( trail ) {\r\n      if ( this.nextPaintedTrail && trail ) {\r\n        this.nextPaintedTrail.reindex();\r\n        return this.nextPaintedTrail.equals( trail );\r\n      } else {\r\n        // check that handles null versions properly\r\n        return this.nextPaintedTrail === trail;\r\n      }\r\n    },\r\n    \r\n    toString: function() {\r\n      return 'boundary:' +\r\n             '\\n    types:    ' +\r\n                  ( this.previousLayerType ? this.previousLayerType.name : '' ) +\r\n                  ' => ' +\r\n                  ( this.nextLayerType ? this.nextLayerType.name : '' ) +\r\n             '\\n    trails:   ' +\r\n                  ( this.previousPaintedTrail ? this.previousPaintedTrail.getUniqueId() : '' ) +\r\n                  ' => ' +\r\n                  ( this.nextPaintedTrail ? this.nextPaintedTrail.getUniqueId() : '' );\r\n    }\r\n  };\r\n  \r\n  return LayerBoundary;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * A layer state is used to construct layer information (and later, layers), and is a state machine\r\n * that layer strategies from each node modify. Iterating through all of the nodes in a depth-first\r\n * manner will modify the LayerBuilder so that layer information can be retrieved.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/layers/LayerBuilder',['require','SCENERY/scenery','SCENERY/layers/LayerBoundary','SCENERY/util/Trail','SCENERY/util/TrailPointer'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  require( 'SCENERY/layers/LayerBoundary' );\r\n  require( 'SCENERY/util/Trail' );\r\n  require( 'SCENERY/util/TrailPointer' );\r\n  \r\n  /*\r\n   * Builds layer information between trails\r\n   *\r\n   * previousLayerType should be null if there is no previous layer.\r\n   */\r\n  scenery.LayerBuilder = function LayerBuilder( scene, previousLayerType, previousPaintedTrail, nextPaintedTrail ) {\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Initial state\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    this.layerTypeStack = [];\r\n    this.boundaries = [];\r\n    this.pendingBoundary = new scenery.LayerBoundary();\r\n    this.pendingBoundary.previousLayerType = previousLayerType;\r\n    this.pendingBoundary.previousPaintedTrail = previousPaintedTrail;\r\n    \r\n    /*\r\n     * The current layer type active, and whether it has been 'used' yet. A node with isPainted() will trigger a 'used' action,\r\n     * and if the layer hasn't been used, it will actually trigger a boundary creation. We want to collapse 'unused' layers\r\n     * and boundaries together, so that every created layer has a node that displays something.\r\n     */\r\n    this.currentLayerType = previousLayerType;\r\n    this.layerChangePending = previousPaintedTrail === null;\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Start / End pointers\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    if ( previousPaintedTrail ) {\r\n      // Move our start pointer just past the previousPaintedTrail, since our previousLayerType is presumably for that trail's node's self.\r\n      // Anything after that self could have been collapsed, so we need to start there.\r\n      this.startPointer = new scenery.TrailPointer( previousPaintedTrail.copy(), true );\r\n      this.startPointer.nestedForwards();\r\n    } else {\r\n      this.startPointer = new scenery.TrailPointer( new scenery.Trail( scene ), true );\r\n    }\r\n    \r\n    if ( nextPaintedTrail ) {\r\n      // include the nextPaintedTrail's 'before' in our iteration, so we can stitch properly with the next layer\r\n      this.endPointer = new scenery.TrailPointer( nextPaintedTrail.copy(), true );\r\n    } else {\r\n      this.endPointer = new scenery.TrailPointer( new scenery.Trail( scene ), false );\r\n    }\r\n    \r\n    this.includesEndTrail = nextPaintedTrail !== null;\r\n    \r\n    /*\r\n     * LayerBoundary properties and assurances:\r\n     *\r\n     * previousLayerType  - initialized in constructor (in case there are no layer changes)\r\n     *                      set in layerChange for \"fresh\" pending boundary\r\n     * nextLayerType      - set and overwrites in switchToType, for collapsing layers\r\n     *                      not set anywhere else, so we can leave it null\r\n     * previousPaintedTrail  - initialized in constructor\r\n     *                      updated in markPainted if there is no pending change (don't set if there is a pending change)\r\n     * nextPaintedTrail      - set on layerChange for \"stale\" boundary\r\n     *                      stays null if nextPaintedTrail === null\r\n     */\r\n  };\r\n  var LayerBuilder = scenery.LayerBuilder;\r\n  \r\n  LayerBuilder.prototype = {\r\n    constructor: LayerBuilder,\r\n    \r\n    // walks part of the state up to just before the startPointer. we want the preferred layer stack to be in place, but the rest is not important\r\n    prepareLayerStack: function() {\r\n      var pointer = new scenery.TrailPointer( new scenery.Trail( this.startPointer.trail.rootNode() ), true );\r\n      \r\n      // if the start pointer is going to execute an exit() instead of an enter() on its trail node, we need to bump up the layer stack an additional step\r\n      var targetLength = this.startPointer.trail.length - ( this.startPointer.isBefore ? 1 : 0 );\r\n      \r\n      while ( pointer.trail.length <= targetLength ) {\r\n        var node = pointer.trail.lastNode();\r\n        if ( node.layerStrategy.hasPreferredLayerType( pointer, this ) ) {\r\n          this.pushPreferredLayerType( node.layerStrategy.getPreferredLayerType( pointer, this ) );\r\n        }\r\n        if ( pointer.trail.length < this.startPointer.trail.nodes.length ) {\r\n          pointer.trail.addDescendant( this.startPointer.trail.nodes[pointer.trail.length] );\r\n        } else {\r\n          // TODO: a cleaner way of doing this, since we were adding undefined into a trail to cause the loop to exit\r\n          break;\r\n        }\r\n      }\r\n    },\r\n    \r\n    run: function() {\r\n      var builder = this;\r\n      \r\n      // push preferred layers for ancestors of our start pointer\r\n      this.prepareLayerStack();\r\n      \r\n      // console.log( '         stack: ' + _.map( builder.layerTypeStack, function( type ) { return type.name; } ).join( ', ' ) );\r\n      \r\n      builder.startPointer.depthFirstUntil( builder.endPointer, function( pointer ) {\r\n        var node = pointer.trail.lastNode();\r\n        \r\n        if ( pointer.isBefore ) {\r\n          // console.log( 'builder: enter ' + pointer.toString() );\r\n          node.layerStrategy.enter( pointer, builder );\r\n        } else {\r\n          // console.log( 'builder: exit ' + pointer.toString() );\r\n          node.layerStrategy.exit( pointer, builder );\r\n        }\r\n        // console.log( '         stack: ' + _.map( builder.layerTypeStack, function( type ) { return type.name; } ).join( ', ' ) );\r\n      }, false ); // include the endpoints\r\n      \r\n      // special case handling if we are at the 'end' of the scene, so that we create another 'wrapping' boundary\r\n      if ( !this.includesEndTrail ) {\r\n        // console.log( 'builder: not including end trail' );\r\n        this.layerChange( null );\r\n      }\r\n    },\r\n    \r\n    // allows paintedPointer === null at the end if the main iteration's nextPaintedTrail === null (i.e. we are at the end of the scene)\r\n    layerChange: function( paintedPointer ) {\r\n      this.layerChangePending = false;\r\n      \r\n      var confirmedBoundary = this.pendingBoundary;\r\n      \r\n      confirmedBoundary.nextPaintedTrail = paintedPointer ? paintedPointer.trail.copy() : null;\r\n      \r\n      this.boundaries.push( confirmedBoundary );\r\n      \r\n      this.pendingBoundary = new scenery.LayerBoundary();\r\n      this.pendingBoundary.previousLayerType = confirmedBoundary.nextLayerType;\r\n      this.pendingBoundary.previousPaintedTrail = confirmedBoundary.nextPaintedTrail;\r\n      // console.log( 'builder:   added boundary' );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * API for layer strategy or other interaction\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    switchToType: function( pointer, layerType ) {\r\n      this.currentLayerType = layerType;\r\n      \r\n      this.pendingBoundary.nextLayerType = layerType;\r\n      \r\n      this.layerChangePending = true; // we wait until the first markPainted() call to create a boundary\r\n    },\r\n    \r\n    // called so that we can finalize a layer switch (instead of collapsing unneeded layers)\r\n    markPainted: function( pointer ) {\r\n      if ( this.layerChangePending ) {\r\n        this.layerChange( pointer );\r\n      } else {\r\n        // TODO: performance-wise, don't lookup indices on this copy? make a way to create a lightweight copy?\r\n        this.pendingBoundary.previousPaintedTrail = pointer.trail.copy();\r\n      }\r\n    },\r\n    \r\n    // can be null to indicate that there is no current layer type\r\n    getCurrentLayerType: function() {\r\n      return this.currentLayerType;\r\n    },\r\n    \r\n    pushPreferredLayerType: function( layerType ) {\r\n      this.layerTypeStack.push( layerType );\r\n    },\r\n    \r\n    popPreferredLayerType: function() {\r\n      this.layerTypeStack.pop();\r\n    },\r\n    \r\n    getPreferredLayerType: function() {\r\n      if ( this.layerTypeStack.length !== 0 ) {\r\n        return this.layerTypeStack[this.layerTypeStack.length - 1];\r\n      } else {\r\n        return null;\r\n      }\r\n    },\r\n    \r\n    bestPreferredLayerTypeFor: function( renderers ) {\r\n      for ( var i = this.layerTypeStack.length - 1; i >= 0; i-- ) {\r\n        var preferredType = this.layerTypeStack[i];\r\n        \r\n        var k = renderers.length;\r\n        while ( k-- ) {\r\n          // if any renderer is supported by this type, use this type\r\n          if ( preferredType.supportsRenderer( renderers[k] ) ) {\r\n            return preferredType;\r\n          }\r\n        }\r\n      }\r\n      \r\n      // none of our stored preferred layer types are able to support any of the default type options\r\n      return null;\r\n    }\r\n  };\r\n  \r\n  return LayerBuilder;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Main scene, that is also a Node.\r\n *\r\n * TODO: documentation!\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/Scene',['require','PHET_CORE/collect','PHET_CORE/inherit','DOT/Bounds2','DOT/Vector2','DOT/Matrix3','KITE/Shape','SCENERY/scenery','SCENERY/nodes/Node','SCENERY/util/Instance','SCENERY/util/Trail','SCENERY/util/RenderInterval','SCENERY/util/TrailPointer','SCENERY/input/Input','SCENERY/layers/LayerBuilder','SCENERY/layers/Renderer','SCENERY/util/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var collect = require( 'PHET_CORE/collect' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  \r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  \r\n  var Shape = require( 'KITE/Shape' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Node = require( 'SCENERY/nodes/Node' ); // inherits from Node\r\n  require( 'SCENERY/util/Instance' );\r\n  require( 'SCENERY/util/Trail' );\r\n  require( 'SCENERY/util/RenderInterval' );\r\n  require( 'SCENERY/util/TrailPointer' );\r\n  require( 'SCENERY/input/Input' );\r\n  require( 'SCENERY/layers/LayerBuilder' );\r\n  require( 'SCENERY/layers/Renderer' );\r\n  \r\n  var Util = require( 'SCENERY/util/Util' );\r\n  var objectCreate = Util.objectCreate;\r\n  \r\n  var accessibility = window.has && window.has( 'scenery.accessibility' );\r\n  \r\n  // debug flag to disable matching of layers when in 'match' mode\r\n  var forceNewLayers = true; // DEBUG\r\n  \r\n  // constructs all sub-trees for the specified instance. used from markSceneForInsertion\r\n  function buildInstances( instance ) {\r\n    var node = instance.getNode();\r\n    var len = node._children.length;\r\n    for ( var i = 0; i < len; i++ ) {\r\n      buildInstances( instance.createChild( node._children[i], i ) );\r\n    }\r\n  }\r\n  \r\n  /*\r\n   * $main should be a block-level element with a defined width and height. scene.resize() should be called whenever\r\n   * it is resized.\r\n   *\r\n   * Valid parameters in the parameter object:\r\n   * {\r\n   *   allowSceneOverflow: false,           // usually anything displayed outside of this $main (DOM/CSS3 transformed SVG) is hidden with CSS overflow\r\n   *   allowCSSHacks: true,                 // applies styling that prevents mobile browser graphical issues\r\n   *   allowDevicePixelRatioScaling: false, // allows underlying canvases (Canvas, WebGL) to increase in size to maintain sharpness on high-density displays\r\n   *   enablePointerEvents: true,           // allows pointer events / MSPointerEvent to be used on supported platforms.\r\n   *   preferredSceneLayerType: ...,        // sets the preferred type of layer to be created if there are multiple options\r\n   *   width: <current main width>,         // override the main container's width\r\n   *   height: <current main height>,       // override the main container's height\r\n   * }\r\n   */\r\n  scenery.Scene = function Scene( $main, options ) {\r\n    sceneryAssert && sceneryAssert( $main[0], 'A main container is required for a scene' );\r\n    this.$main = $main;\r\n    this.main = $main[0];\r\n    \r\n    // add a self reference to aid in debugging. this generally shouldn't lead to a memory leak\r\n    this.main.scene = this;\r\n    \r\n    // add a reference to the API for debugging\r\n    this.scenery = scenery;\r\n    \r\n    // defaults\r\n    options = _.extend( {\r\n      allowSceneOverflow: false,\r\n      allowCSSHacks: true,\r\n      allowDevicePixelRatioScaling: false,\r\n      enablePointerEvents: true,\r\n      preferredSceneLayerType: scenery.CanvasDefaultLayerType,\r\n      width: $main.width(),\r\n      height: $main.height()\r\n    }, options || {} );\r\n    \r\n    // TODO: consider using a pushed preferred layer to indicate this information, instead of as a specific option\r\n    this.backingScale = options.allowDevicePixelRatioScaling ? Util.backingScale( document.createElement( 'canvas' ).getContext( '2d' ) ) : 1;\r\n    this.enablePointerEvents = options.enablePointerEvents;\r\n    \r\n    Node.call( this, options );\r\n    \r\n    var scene = this;\r\n    window.debugScene = scene;\r\n    \r\n    // layering data\r\n    this.layers = [];               // main layers in a scene\r\n    this.layerChangeIntervals = []; // array of {RenderInterval}s indicating what parts need to be stitched together. cleared after each stitching\r\n    \r\n    this.lastCursor = null;\r\n    this.defaultCursor = $main.css( 'cursor' );\r\n    \r\n    // resize the main container as a sanity check\r\n    this.setSize( options.width, options.height );\r\n    \r\n    this.sceneBounds = new Bounds2( 0, 0, options.width, options.height );\r\n    \r\n    // set up the root instance for this scene\r\n    // only do this after Node.call has been invoked, since Trail.addDescendant uses a few things\r\n    this.rootInstance = new scenery.Instance( new scenery.Trail( this ), null, null );\r\n    this.addInstance( this.rootInstance );\r\n    \r\n    // default to a canvas layer type, but this can be changed\r\n    this.preferredSceneLayerType = options.preferredSceneLayerType;\r\n    \r\n    applyCSSHacks( $main, options );\r\n    \r\n    if ( accessibility ) {\r\n      this.activePeer = null;\r\n      \r\n      this.accessibilityLayer = document.createElement( 'div' );\r\n      this.accessibilityLayer.className = \"accessibility-layer\";\r\n      \r\n      //Put the accessibility layer behind the background so it cannot be seen.  Change this to some high number like 9999 to show it for debugging purposes.\r\n      this.accessibilityLayer.style.zIndex = -1;\r\n      this.accessibilityLayer.style.position = 'relative';\r\n      $main[0].appendChild( this.accessibilityLayer );\r\n      \r\n      this.focusRingSVGContainer = document.createElementNS( 'http://www.w3.org/2000/svg', 'svg' );\r\n      this.focusRingSVGContainer.style.position = 'absolute';\r\n      this.focusRingSVGContainer.style.top = 0;\r\n      this.focusRingSVGContainer.style.left = 0;\r\n      this.focusRingSVGContainer.style['pointer-events'] = 'none';\r\n      this.resizeFocusRingSVGContainer( options.width, options.height );\r\n      this.focusRingPath = document.createElementNS( 'http://www.w3.org/2000/svg', 'path' );\r\n      this.focusRingPath.setAttribute( 'style', 'fill: none; stroke: blue; stroke-width: 5;' );\r\n      this.focusRingPath.setAttribute( 'id', 'p1' );\r\n      this.focusRingSVGContainer.appendChild( this.focusRingPath );\r\n      $main[0].appendChild( this.focusRingSVGContainer );\r\n      \r\n      this.updateFocusRing = function() {\r\n        // TODO: move into prototype definitions, this doesn't need to be private, and isn't a closure over anything in the constructor\r\n        sceneryAssert && sceneryAssert( scene.activePeer, 'scene should have an active peer when changing the focus ring bounds' );\r\n        scene.focusRingPath.setAttribute( 'd', Shape.bounds( scene.activePeer.getGlobalBounds() ).getSVGPath() );\r\n      };\r\n\r\n      //Put the live region layer behind the accessibility peer layer to make debugging easier (if we need to see the accessibility layer)\r\n      this.liveRegionLayer = document.createElement( 'div' );\r\n      this.liveRegionLayer.className = 'live-region-layer';\r\n      this.liveRegionLayer.style.zIndex = -2;\r\n      this.liveRegionLayer.style.position = 'relative';\r\n      $main[0].appendChild( this.liveRegionLayer );\r\n    }\r\n  };\r\n  var Scene = scenery.Scene;\r\n  \r\n  inherit( Node, Scene, {\r\n    \r\n    updateScene: function( args ) {\r\n      // sceneryLayerLog && sceneryLayerLog( 'Scene: updateScene' );\r\n      \r\n      var scene = this;\r\n      \r\n      // check to see whether contents under pointers changed (and if so, send the enter/exit events) to maintain consistent state\r\n      if ( this.input ) {\r\n        this.input.validatePointers();\r\n      }\r\n      \r\n      // validating bounds, similar to Piccolo2d\r\n      this.validateBounds();\r\n      this.validatePaint();\r\n      \r\n      // bail if there are no layers. consider a warning?\r\n      if ( !this.layers.length ) {\r\n        return;\r\n      }\r\n      \r\n      var i = this.layers.length;\r\n      while ( i-- ) {\r\n        this.layers[i].render( scene, args );\r\n      }\r\n      \r\n      this.updateCursor();\r\n      \r\n      // if ( this.accessibilityLayer ) {\r\n  //      for ( var i = 0; i < accessibleNodes.length; i++ ) {\r\n  //        if ( accessibleNodes[i]._element === activeElement ) {\r\n  //          if ( accessibleNodes[i].origin ) {\r\n  //            var b = accessibleNodes[i].origin.globalBounds;\r\n  //            var rect = Shape.bounds( b );\r\n  //\r\n  //            //Animation is a bit buggy, but I left this code in in case we want to pick it up later.\r\n  //            var animateTheRect = false;\r\n  //            if ( animateTheRect ) {\r\n  //              if ( !this.focusRingPath.lastSVGPath ) {\r\n  //                this.focusRingPath.setAttribute( 'd', rect.getSVGPath() );\r\n  //                this.focusRingPath.lastSVGPath = rect.getSVGPath();\r\n  //              } else {\r\n  //                var animate = document.createElementNS( 'http://www.w3.org/2000/svg', 'animate' );\r\n  //                animate.setAttribute( 'attributeType', 'XML' );\r\n  //                animate.setAttribute( 'xlink:href', '#p1' );\r\n  //                animate.setAttribute( 'attributeName', 'd' );\r\n  //                animate.setAttribute( 'from', this.focusRingPath.lastSVGPath );\r\n  //                animate.setAttribute( 'to', rect.getSVGPath() );\r\n  //                animate.setAttribute( 'dur', '4s' );\r\n  //\r\n  //                $( this.focusRingPath ).empty();\r\n  //                this.focusRingPath.appendChild( animate );\r\n  //                this.focusRingPath.lastSVGPath = rect.getSVGPath();\r\n  //              }\r\n  //            } else {\r\n  //              this.focusRingPath.setAttribute( 'd', rect.getSVGPath() );\r\n  //            }\r\n  //\r\n  //            found = true;\r\n  //          }\r\n  //        }\r\n  //        if ( !found ) {\r\n  //          this.focusRingPath.removeAttribute( 'd' );\r\n  //        }\r\n  //      }\r\n      // }\r\n    },\r\n    \r\n    renderScene: function() {\r\n      // TODO: for now, go with the same path. possibly add options later\r\n      this.updateScene();\r\n    },\r\n    \r\n    addPeer: function( peer ) {\r\n      this.accessibilityLayer.appendChild( peer.peerElement );\r\n    },\r\n    \r\n    removePeer: function( peer ) {\r\n      this.accessibilityLayer.removeChild( peer.peerElement );\r\n    },\r\n\r\n    addLiveRegion: function( liveRegion ) {\r\n      this.liveRegionLayer.appendChild( liveRegion.element );\r\n    },\r\n\r\n    removeLiveRegion: function( liveRegion ) {\r\n      this.liveRegionLayer.removeChild( liveRegion.element );\r\n    },\r\n    \r\n    setActivePeer: function( peer ) {\r\n      if ( this.activePeer !== peer ) {\r\n        var scene = this;\r\n        \r\n        //Remove bounds listener from old active peer\r\n        if ( this.activePeer ) {\r\n          this.activePeer.instance.node.removeEventListener( 'bounds', this.updateFocusRing );\r\n        }\r\n        \r\n        this.activePeer = peer;\r\n        \r\n        if ( peer ) {\r\n          this.activePeer.instance.node.addEventListener( 'bounds', this.updateFocusRing );\r\n          this.updateFocusRing();\r\n        } else {\r\n          this.focusRingPath.setAttribute( 'd', \"M 0 0\" );\r\n        }\r\n      }\r\n    },\r\n    \r\n    getActivePeer: function( peer ) {\r\n      return this.activePeer;\r\n    },\r\n    \r\n    focusPeer: function( peer ) {\r\n      this.setActivePeer( peer );\r\n    },\r\n    \r\n    blurPeer: function( peer ) {\r\n      sceneryAssert && sceneryAssert( this.getActivePeer() === peer, 'Can only blur an active peer' );\r\n      this.setActivePeer( null );\r\n    },\r\n    \r\n    markInterval: function( affectedTrail ) {\r\n      // TODO: maybe reindexing sooner is better? are we covering up a bug here?\r\n      affectedTrail.reindex();\r\n      \r\n      // since this is marked while the child is still connected, we can use our normal trail handling.\r\n      \r\n      // find the closest before and after self trails that are not affected\r\n      var beforeTrail = affectedTrail.previousPainted(); // easy for the before trail\r\n      \r\n      var afterTrailPointer = new scenery.TrailPointer( affectedTrail.copy(), false );\r\n      while ( afterTrailPointer.hasTrail() && ( !afterTrailPointer.isBefore || !afterTrailPointer.trail.isPainted() ) ) {\r\n        afterTrailPointer.nestedForwards();\r\n      }\r\n      var afterTrail = afterTrailPointer.trail;\r\n      \r\n      // sanity checks\r\n      sceneryAssert && sceneryAssert( !beforeTrail || beforeTrail.areIndicesValid(), 'beforeTrail needs to be valid' );\r\n      sceneryAssert && sceneryAssert( !afterTrail || afterTrail.areIndicesValid(), 'afterTrail needs to be valid' );\r\n      sceneryAssert && sceneryAssert( !beforeTrail || !afterTrail || beforeTrail.compare( afterTrail ) !== 0, 'Marked interval needs to be exclusive' );\r\n      \r\n      // store the layer of the before/after trails so that it is easy to access later\r\n      this.addLayerChangeInterval( new scenery.RenderInterval( beforeTrail, afterTrail ) );\r\n    },\r\n    \r\n    // convenience function for layer change intervals\r\n    addLayerChangeInterval: function( interval ) {\r\n      if ( sceneryLayerLog ) {\r\n        sceneryLayerLog( 'adding interval: ' + interval.toString() + ' to intervals:' );\r\n        _.each( this.layerChangeIntervals, function( interval ) {\r\n          sceneryLayerLog( '  ' + interval.toString() );\r\n        } );\r\n      }\r\n      \r\n      // TODO: replace with a binary-search-like version that may be faster. this includes a full scan\r\n      \r\n      // attempt to merge this interval with another if possible.\r\n      for ( var i = 0; i < this.layerChangeIntervals.length; i++ ) {\r\n        var other = this.layerChangeIntervals[i];\r\n        other.reindex(); // sanity check, although for most use-cases this should be unnecessary\r\n        \r\n        if ( interval.exclusiveUnionable( other ) ) {\r\n          // the interval can be unioned without including other nodes. do this, and remove the other interval from consideration\r\n          interval = interval.union( other );\r\n          this.layerChangeIntervals.splice( i--, 1 ); // decrement to stay at the same index\r\n          sceneryLayerLog && sceneryLayerLog( 'removing interval: ' + other.toString() );\r\n        }\r\n      }\r\n      \r\n      this.layerChangeIntervals.push( interval );\r\n      \r\n      if ( sceneryLayerLog ) {\r\n        sceneryLayerLog( 'new intervals: ' );\r\n        _.each( this.layerChangeIntervals, function( interval ) {\r\n          sceneryLayerLog( '  ' + interval.toString() );\r\n        } );\r\n        sceneryLayerLog( '---' );\r\n      }\r\n    },\r\n    \r\n    createLayer: function( layerType, layerArgs, startBoundary, endBoundary ) {\r\n      var layer = layerType.createLayer( _.extend( {\r\n        startBoundary: startBoundary,\r\n        endBoundary: endBoundary\r\n      }, layerArgs ) );\r\n      layer.type = layerType;\r\n      sceneryLayerLog && sceneryLayerLog( 'created layer: ' + layer.getId() + ' of type ' + layer.type.name );\r\n      return layer;\r\n    },\r\n    \r\n    // insert a layer into the proper place (from its starting boundary)\r\n    insertLayer: function( layer ) {\r\n      for ( var i = 0; i < this.layers.length; i++ ) {\r\n        if ( layer.endPaintedTrail.isBefore( this.layers[i].startPaintedTrail ) ) {\r\n          this.layers.splice( i, 0, layer ); // insert the layer here\r\n          return;\r\n        }\r\n      }\r\n      \r\n      // it is after all other layers\r\n      this.layers.push( layer );\r\n    },\r\n    \r\n    getBoundaries: function() {\r\n      // TODO: store these more efficiently!\r\n      return [ this.layers[0].startBoundary ].concat( _.pluck( this.layers, 'endBoundary' ) );\r\n    },\r\n    \r\n    calculateBoundaries: function( beforeLayerType, beforeTrail, afterTrail ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'build between ' + ( beforeTrail ? beforeTrail.toString() : beforeTrail ) + ',' + ( afterTrail ? afterTrail.toString() : afterTrail ) + ' with beforeType: ' + ( beforeLayerType ? beforeLayerType.name : null ) );\r\n      var builder = new scenery.LayerBuilder( this, beforeLayerType, beforeTrail, afterTrail );\r\n      \r\n      // push the preferred layer type before we push that for any nodes\r\n      if ( this.preferredSceneLayerType ) {\r\n        builder.pushPreferredLayerType( this.preferredSceneLayerType );\r\n      }\r\n      \r\n      builder.run();\r\n      \r\n      return builder.boundaries;\r\n    },\r\n    \r\n    stitch: function( match ) {\r\n      var scene = this;\r\n      \r\n      var i;\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( '-----------------------------------\\nbeginning stitch' );\r\n      \r\n      // bail out if there are no changes to stitch (stitch is called multiple times)\r\n      if ( !this.layerChangeIntervals.length ) {\r\n        return;\r\n      }\r\n      \r\n      // data to be shared across all of the individually stitched intervals\r\n      var stitchData = {\r\n        // all instances that are affected, in no particular order (and may contain duplicates)\r\n        affectedInstances: [],\r\n        \r\n        // fresh layers that should be added into the scene\r\n        newLayers: []\r\n      };\r\n      \r\n      // default arguments for constructing layers\r\n      var layerArgs = {\r\n        $main: this.$main,\r\n        scene: this,\r\n        baseNode: this\r\n      };\r\n      \r\n      // reindex intervals, since their endpoints indices may need to be updated\r\n      i = this.layerChangeIntervals.length;\r\n      while ( i-- ) {\r\n        this.layerChangeIntervals[i].reindex();\r\n      }\r\n      \r\n      /*\r\n       * Sort our intervals, so that when we need to 'unglue' a layer into two separate layers, we will have passed\r\n       * all of the parts where we would need to use the 'before' layer, so we can update our layer map with the 'after'\r\n       * layer.\r\n       */\r\n      this.layerChangeIntervals.sort( scenery.RenderInterval.compareDisjoint );\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( 'stitching on intervals: \\n' + this.layerChangeIntervals.join( '\\n' ) );\r\n      \r\n      for ( i = 0; i < this.layerChangeIntervals.length; i++ ) {\r\n        var interval = this.layerChangeIntervals[i];\r\n        \r\n        sceneryLayerLog && sceneryLayerLog( 'stitch on interval ' + interval.toString() );\r\n        var beforeTrail = interval.start;\r\n        var afterTrail = interval.end;\r\n        \r\n        var beforeInstance = beforeTrail ? beforeTrail.getInstance() : null;\r\n        var afterInstance = afterTrail ? afterTrail.getInstance() : null;\r\n        \r\n        var beforeLayer = beforeInstance ? beforeInstance.layer : null;\r\n        var afterLayer = afterInstance ? afterInstance.layer : null;\r\n        \r\n        // TODO: calculate boundaries based on the instances?\r\n        var boundaries = this.calculateBoundaries( beforeLayer ? beforeLayer.type : null, beforeTrail, afterTrail );\r\n        \r\n        this.stitchInterval( stitchData, layerArgs, beforeTrail, afterTrail, beforeLayer, afterLayer, boundaries, match );\r\n      }\r\n      \r\n      // clean up state that was set leading up to the stitching, and do it early so\r\n      // if we do things later that cause side-effects we won't clear intervals that haven't been stitched\r\n      this.layerChangeIntervals.length = 0;\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( '------ finished intervals in stitching' );\r\n      \r\n      // reindex all of the relevant layer trails, and dispose/add as necessary\r\n      i = this.layers.length;\r\n      while ( i-- ) {\r\n        var layer = this.layers[i];\r\n        layer.startBoundary.reindex();\r\n        layer.endBoundary.reindex(); // TODO: performance: this repeats some work, verify in layer audit that we are sharing boundaries properly, then only reindex end boundary on last layer\r\n        \r\n        // remove necessary layers. do this before adding layers, since insertLayer currently does not gracefully handle weird overlapping cases\r\n        // layers with zero trails should be removed\r\n        if ( layer._instanceCount === 0 ) {\r\n          sceneryLayerLog && sceneryLayerLog( 'disposing layer: ' + layer.getId() );\r\n          this.disposeLayer( layer );\r\n        }\r\n      }\r\n      i = stitchData.newLayers.length;\r\n      while ( i-- ) {\r\n        var newLayer = stitchData.newLayers[i];\r\n        newLayer.startBoundary.reindex();\r\n        newLayer.endBoundary.reindex(); // TODO: performance: this repeats some work, verify in layer audit that we are sharing boundaries properly, then only reindex end boundary on last layer\r\n        \r\n        // add new layers. we do this before the add/remove trails, since those can trigger layer side effects\r\n        sceneryAssert && sceneryAssert( newLayer._instanceCount, 'ensure we are not adding empty layers' );\r\n        \r\n        sceneryLayerLog && sceneryLayerLog( 'inserting layer: ' + newLayer.getId() );\r\n        scene.insertLayer( newLayer );\r\n      }\r\n      \r\n      // set the layers' elements' z-indices, and reindex their trails so they are in a consistent state\r\n      // TODO: performance: don't reindex layers if no layers were added or removed?\r\n      this.reindexLayers();\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( '------ updating layer references' );\r\n      \r\n      // add/remove trails from their necessary layers\r\n      var affectedLen = stitchData.affectedInstances.length;\r\n      for ( i = 0; i < affectedLen; i++ ) {\r\n        stitchData.affectedInstances[i].updateLayer();\r\n      }\r\n      \r\n      sceneryAssertExtra && sceneryAssertExtra( this.layerAudit() );\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( 'finished stitch\\n-----------------------------------' );\r\n    },\r\n    \r\n    /*\r\n     * Stitching intervals has essentially two specific modes:\r\n     * non-matching: handles added or removed nodes (and this can span multiple, even adjacent trails)\r\n     * matching: handles in-place layer refreshes (no nodes removed or added, but something like a renderer was changed)\r\n     *\r\n     * This separation occurs since for matching, we want to match old layers with possible new layers, so we can keep trails in their\r\n     * current layer instead of creating an identical layer and moving the trails to that layer.\r\n     *\r\n     * The stitching basically re-does the layering between a start and end trail, attempting to minimize the amount of changes made.\r\n     * It can include 'gluing' layers together (a node that caused layer splits was removed, and before/after layers are joined),\r\n     * 'ungluing' layers (an inserted node causes a layer split in an existing layer, and it is separated into a before/after),\r\n     * or normal updating of the interior.\r\n     *\r\n     * The beforeTrail and afterTrail should be outside the modifications, and if the modifications are to the start/end of the graph,\r\n     * they should be passed as null to indicate 'before everything' and 'after everything' respectively.\r\n     *\r\n     * Here be dragons!\r\n     */\r\n    stitchInterval: function( stitchData, layerArgs, beforeTrail, afterTrail, beforeLayer, afterLayer, boundaries, match ) {\r\n      var scene = this;\r\n      \r\n      // make sure our beforeTrail and afterTrail are immutable\r\n      beforeTrail && beforeTrail.setImmutable();\r\n      afterTrail && afterTrail.setImmutable();\r\n      \r\n      // need a reference to this, since it may change\r\n      var afterLayerEndBoundary = afterLayer ? afterLayer.endBoundary : null;\r\n      \r\n      var beforeLayerIndex = beforeLayer ? _.indexOf( this.layers, beforeLayer ) : -1;\r\n      var afterLayerIndex = afterLayer ? _.indexOf( this.layers, afterLayer ) : this.layers.length;\r\n      \r\n      var beforePointer = beforeTrail ? new scenery.TrailPointer( beforeTrail, true ) : new scenery.TrailPointer( new scenery.Trail( this ), true );\r\n      var afterPointer = afterTrail ? new scenery.TrailPointer( afterTrail, true ) : new scenery.TrailPointer( new scenery.Trail( this ), false );\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( '\\nstitching with boundaries:\\n' + _.map( boundaries, function( boundary ) { return boundary.toString(); } ).join( '\\n' ) );\r\n      sceneryLayerLog && sceneryLayerLog( '               layers: ' + ( beforeLayer ? beforeLayer.getId() : '-' ) + ' to ' + ( afterLayer ? afterLayer.getId() : '-' ) );\r\n      sceneryLayerLog && sceneryLayerLog( '               trails: ' + ( beforeTrail ? beforeTrail.toString() : '-' ) + ' to ' + ( afterTrail ? afterTrail.toString() : '-' ) );\r\n      sceneryLayerLog && sceneryLayerLog( '               match: ' + match );\r\n      \r\n      /*---------------------------------------------------------------------------*\r\n      * State\r\n      *----------------------------------------------------------------------------*/\r\n      \r\n      var nextBoundaryIndex = 0;\r\n      var nextBoundary = boundaries[nextBoundaryIndex];\r\n      var instancesToAddToLayer = [];\r\n      var currentTrail = beforeTrail;\r\n      var currentLayer = beforeLayer;\r\n      var currentLayerType = beforeLayer ? beforeLayer.type : null;\r\n      var currentStartBoundary = null;\r\n      var matchingLayer = null; // set whenever a trail has a matching layer, cleared after boundary\r\n      \r\n      function addPendingTrailsToLayer() {\r\n        // add the necessary nodes to the layer\r\n        var len = instancesToAddToLayer.length;\r\n        for ( var i = 0; i < len; i++ ) {\r\n          var instance = instancesToAddToLayer[i];\r\n          instance.changeLayer( currentLayer );\r\n          stitchData.affectedInstances.push( instance );\r\n        }\r\n        instancesToAddToLayer.length = 0;\r\n      }\r\n      \r\n      function addAndCreateLayer( startBoundary, endBoundary ) {\r\n        currentLayer = scene.createLayer( currentLayerType, layerArgs, startBoundary, endBoundary );\r\n        stitchData.newLayers.push( currentLayer );\r\n      }\r\n      \r\n      function step( trail, isEnd ) {\r\n        sceneryLayerLog && sceneryLayerLog( 'step: ' + ( trail ? trail.toString() : trail ) );\r\n        trail && trail.setImmutable(); // we don't want our trail to be modified, so we can store direct references to it\r\n        // check for a boundary at this step between currentTrail and trail\r\n        \r\n        // if there is no next boundary, don't bother checking anyways\r\n        if ( nextBoundary && nextBoundary.equivalentPreviousTrail( currentTrail ) ) { // at least one null check\r\n          sceneryAssert && sceneryAssert( nextBoundary.equivalentNextTrail( trail ) );\r\n          \r\n          sceneryLayerLog && sceneryLayerLog( nextBoundary.toString() );\r\n          \r\n          // we are at a boundary change. verify that we are at the end of a layer\r\n          if ( currentLayer || currentStartBoundary ) {\r\n            if ( currentLayer ) {\r\n              sceneryLayerLog && sceneryLayerLog( 'has currentLayer: ' + currentLayer.getId() );\r\n              // existing layer, reposition its endpoint\r\n              currentLayer.setEndBoundary( nextBoundary );\r\n            } else {\r\n              sceneryAssert && sceneryAssert( currentStartBoundary );\r\n              \r\n              if ( matchingLayer ) {\r\n                sceneryLayerLog && sceneryLayerLog( 'matching layer used: ' + matchingLayer.getId() );\r\n                matchingLayer.setStartBoundary( currentStartBoundary );\r\n                matchingLayer.setEndBoundary( nextBoundary );\r\n                currentLayer = matchingLayer;\r\n              } else {\r\n                sceneryLayerLog && sceneryLayerLog( 'creating layer' );\r\n                addAndCreateLayer( currentStartBoundary, nextBoundary ); // sets currentLayer\r\n              }\r\n            }\r\n            // sanity checks\r\n            sceneryAssert && sceneryAssert( currentLayer.startPaintedTrail );\r\n            sceneryAssert && sceneryAssert( currentLayer.endPaintedTrail );\r\n            \r\n            addPendingTrailsToLayer();\r\n          } else {\r\n            // if not at the end of a layer, sanity check that we should have no accumulated pending trails\r\n            sceneryLayerLog && sceneryLayerLog( 'was first layer' );\r\n            sceneryAssert && sceneryAssert( instancesToAddToLayer.length === 0 );\r\n          }\r\n          currentLayer = null;\r\n          currentLayerType = nextBoundary.nextLayerType;\r\n          currentStartBoundary = nextBoundary;\r\n          matchingLayer = null;\r\n          nextBoundaryIndex++;\r\n          nextBoundary = boundaries[nextBoundaryIndex];\r\n        }\r\n        if ( trail && !isEnd ) {\r\n          // TODO: performance: handle instances natively, don't just convert here\r\n          instancesToAddToLayer.push( trail.getInstance() );\r\n        }\r\n        if ( match && !isEnd ) { // TODO: verify this condition with test cases\r\n          // if the node's old layer is compatible\r\n          // TODO: performance: don't use getInstance() here, use instances natively\r\n          var layer = trail.getInstance().layer; // lookup should return the old layer from the system\r\n          if ( layer.type === currentLayerType && !forceNewLayers ) {\r\n            // TODO: we need to handle compatibility with layer splits. using forceNewLayers flag to temporarily disable\r\n            matchingLayer = layer;\r\n          }\r\n        }\r\n        currentTrail = trail;\r\n      }\r\n      \r\n      function startStep( trail ) {\r\n        sceneryLayerLog && sceneryLayerLog( 'startStep: ' + ( trail ? trail.toString() : trail ) );\r\n      }\r\n      \r\n      function middleStep( trail ) {\r\n        sceneryLayerLog && sceneryLayerLog( 'middleStep: ' + trail.toString() );\r\n        step( trail, false );\r\n      }\r\n      \r\n      function endStep( trail ) {\r\n        sceneryLayerLog && sceneryLayerLog( 'endStep: ' + ( trail ? trail.toString() : trail ) );\r\n        step( trail, true );\r\n        \r\n        if ( beforeLayer !== afterLayer && boundaries.length === 0 ) {\r\n          // glue the layers together\r\n          sceneryLayerLog && sceneryLayerLog( 'gluing layer' );\r\n          sceneryLayerLog && sceneryLayerLog( 'endBoundary: ' + afterLayer.endBoundary.toString() );\r\n          beforeLayer.setEndBoundary( afterLayer.endBoundary );\r\n          currentLayer = beforeLayer;\r\n          addPendingTrailsToLayer();\r\n          \r\n          // move over all of afterLayer's trails to beforeLayer\r\n          var len = afterLayer._layerTrails.length;\r\n          for ( var i = 0; i < len; i++ ) {\r\n            var endTrail = afterLayer._layerTrails[i];\r\n            \r\n            endTrail.reindex();\r\n            var instance = endTrail.getInstance();\r\n            instance.changeLayer( beforeLayer ); // TODO: performance: handle instances natively\r\n            stitchData.affectedInstances.push( instance );\r\n          }\r\n          \r\n        } else if ( beforeLayer && beforeLayer === afterLayer && boundaries.length > 0 ) {\r\n          // need to 'unglue' and split the layer\r\n          sceneryLayerLog && sceneryLayerLog( 'ungluing layer' );\r\n          sceneryAssert && sceneryAssert( currentStartBoundary );\r\n          addAndCreateLayer( currentStartBoundary, afterLayerEndBoundary ); // sets currentLayer\r\n          addPendingTrailsToLayer();\r\n          \r\n          currentLayer.endPaintedTrail.reindex(); // currentLayer's trails may be stale at this point\r\n          scenery.Trail.eachPaintedTrailBetween( afterTrail, currentLayer.endPaintedTrail, function( subtrail ) {\r\n            var instance = subtrail.getInstance();\r\n            instance.changeLayer( currentLayer );\r\n            stitchData.affectedInstances.push( instance );\r\n          }, false, scene );\r\n        } else if ( !beforeLayer && !afterLayer && boundaries.length === 1 && !boundaries[0].hasNext() && !boundaries[0].hasPrevious() ) {\r\n          // TODO: why are we generating a boundary here?!?\r\n        } else {\r\n          currentLayer = afterLayer;\r\n          // TODO: check concepts on this guard, since it seems sketchy\r\n          if ( currentLayer && currentStartBoundary ) {\r\n            currentLayer.setStartBoundary( currentStartBoundary );\r\n          }\r\n          \r\n          addPendingTrailsToLayer();\r\n        }\r\n      }\r\n      \r\n      // iterate from beforeTrail up to BEFORE the afterTrail. does not include afterTrail\r\n      startStep( beforeTrail );\r\n      beforePointer.eachTrailBetween( afterPointer, function( trail ) {\r\n        // ignore non-self trails\r\n        if ( !trail.isPainted() || ( beforeTrail && trail.equals( beforeTrail ) ) ) {\r\n          return;\r\n        }\r\n        \r\n        middleStep( trail.copy() );\r\n      } );\r\n      endStep( afterTrail );\r\n    },\r\n    \r\n    rebuildLayers: function() {\r\n      sceneryLayerLog && sceneryLayerLog( 'Scene: rebuildLayers' );\r\n      \r\n      // mark the entire scene \r\n      this.markInterval( new scenery.Trail( this ) );\r\n      \r\n      // then stitch with match=true\r\n      this.stitch( true );\r\n    },\r\n    \r\n    // after layer changes, the layers should have their zIndex updated, and updates their trails\r\n    reindexLayers: function() {\r\n      sceneryLayerLog && sceneryLayerLog( 'Scene: reindexLayers' );\r\n      \r\n      var index = 1; // don't start below 1\r\n      if ( accessibility && this.accessibiltyLayer ) {\r\n        this.accessibilityLayer.style.zIndex = 9999; // TODO: a better way than 9999, SR says probably unnecessary\r\n        index++;\r\n      }\r\n      \r\n      var len = this.layers.length;\r\n      for ( var i = 0; i < len; i++ ) {\r\n        index = this.layers[i].reindex( index );\r\n      }\r\n      \r\n      if ( accessibility ) {\r\n        if ( this.focusRingSVGContainer ) {\r\n          this.focusRingSVGContainer.style.zIndex = index;\r\n        }\r\n      }\r\n    },\r\n    \r\n    dispose: function() {\r\n      this.disposeLayers();\r\n      if ( this.input ) {\r\n        this.input.disposeListeners();\r\n      }\r\n      \r\n      // remove self reference from the container\r\n      delete this.main.scene;\r\n      \r\n      // TODO: clear event handlers if added\r\n      //throw new Error( 'unimplemented dispose: clear event handlers if added' );\r\n    },\r\n    \r\n    disposeLayer: function( layer ) {\r\n      // NOTE: stitching relies on this not changing this.layers except for removing the specific layer\r\n      layer.dispose();\r\n      this.layers.splice( _.indexOf( this.layers, layer ), 1 ); // TODO: better removal code!\r\n    },\r\n    \r\n    disposeLayers: function() {\r\n      var scene = this;\r\n      \r\n      var i = this.layers.length;\r\n      while ( i-- ) {\r\n        this.disposeLayer( this.layers[i] );\r\n      }\r\n    },\r\n    \r\n    // all layers whose start or end points lie inclusively in the range from the trail's before and after\r\n    affectedLayers: function( trail ) {\r\n      // midpoint search and result depends on the order of layers being in render order (bottom to top)\r\n      \r\n      sceneryAssert && sceneryAssert( !( trail.isEmpty() || trail.nodes[0] !== this ), 'layerLookup root matches' );\r\n      \r\n      var n = this.layers.length;\r\n      if ( n === 0 ) {\r\n        sceneryAssert && sceneryAssert( !trail.lastNode().isPainted(), 'There should be at least one layer for a painted trail' );\r\n        return [];\r\n      }\r\n      \r\n      sceneryAssert && sceneryAssert( trail.areIndicesValid() );\r\n      \r\n      // point to the beginning of the node, right before it would be rendered\r\n      var startPointer = new scenery.TrailPointer( trail, true );\r\n      var endPointer = new scenery.TrailPointer( trail, false );\r\n      \r\n      var layers = this.layers;\r\n      \r\n      // from layers 0 to n-1, notAfter goes from false to true, notBefore goes from true to false\r\n      var low = -1;\r\n      var high = n;\r\n      var mid;\r\n      \r\n      // midpoint search to see where our trail's start isn't after a layer's end\r\n      while ( high - 1 > low ) {\r\n        mid = ( high + low ) >> 1;\r\n        var endTrail = layers[mid].endPaintedTrail;\r\n        sceneryAssert && sceneryAssert( endTrail.areIndicesValid() );\r\n        // NOTE TO SELF: don't change this flag to true again. think it through\r\n        var notAfter = startPointer.compareNested( new scenery.TrailPointer( endTrail, true ) ) !== 1;\r\n        if ( notAfter ) {\r\n          high = mid;\r\n        } else {\r\n          low = mid;\r\n        }\r\n      }\r\n      \r\n      // store result and reset bound\r\n      var firstIndex = high;\r\n      low = -1;\r\n      high = n;\r\n      \r\n      // midpoint search to see where our trail's end isn't before a layer's start\r\n      while ( high - 1 > low ) {\r\n        mid = ( high + low ) >> 1;\r\n        var startTrail = layers[mid].startPaintedTrail;\r\n        startTrail.reindex();\r\n        sceneryAssert && sceneryAssert( startTrail.areIndicesValid() );\r\n        var notBefore = endPointer.compareNested( new scenery.TrailPointer( startTrail, true ) ) !== -1;\r\n        if ( notBefore ) {\r\n          low = mid;\r\n        } else {\r\n          high = mid;\r\n        }\r\n      }\r\n      \r\n      var lastIndex = low;\r\n      \r\n      return layers.slice( firstIndex, lastIndex + 1 );\r\n    },\r\n    \r\n    // attempt to render everything currently visible in the scene to an external canvas. allows copying from canvas layers straight to the other canvas\r\n    renderToCanvas: function( canvas, context, callback ) {\r\n      var count = 0;\r\n      var started = false; // flag guards against asynchronous tests that call back synchronously (immediate increment and decrement)\r\n      var delayCounts = {\r\n        increment: function() {\r\n          count++;\r\n        },\r\n        \r\n        decrement: function() {\r\n          count--;\r\n          if ( count === 0 && callback && started ) {\r\n            callback();\r\n          }\r\n        }\r\n      };\r\n      \r\n      context.clearRect( 0, 0, canvas.width, canvas.height );\r\n      var len = this.layers.length;\r\n      for ( var i = 0; i < len; i++ ) {\r\n        this.layers[i].renderToCanvas( canvas, context, delayCounts );\r\n      }\r\n      \r\n      if ( count === 0 ) {\r\n        // no asynchronous layers, callback immediately\r\n        if ( callback ) {\r\n          callback();\r\n        }\r\n      } else {\r\n        started = true;\r\n      }\r\n    },\r\n    \r\n    // TODO: consider SVG data URLs\r\n    canvasDataURL: function( callback ) {\r\n      this.canvasSnapshot( function( canvas ) {\r\n        callback( canvas.toDataURL() );\r\n      } );\r\n    },\r\n    \r\n    // renders what it can into a Canvas (so far, Canvas and SVG layers work fine)\r\n    canvasSnapshot: function( callback ) {\r\n      var canvas = document.createElement( 'canvas' );\r\n      canvas.width = this.sceneBounds.getWidth();\r\n      canvas.height = this.sceneBounds.getHeight();\r\n      \r\n      var context = canvas.getContext( '2d' );\r\n      this.renderToCanvas( canvas, context, function() {\r\n        callback( canvas, context.getImageData( 0, 0, canvas.width, canvas.height ) );\r\n      } );\r\n    },\r\n    \r\n    // TODO: Note that this is private, better name?\r\n    setSize: function( width, height ) {\r\n      // resize our main container\r\n      this.$main.width( width );\r\n      this.$main.height( height );\r\n      \r\n      // set the container's clipping so anything outside won't show up\r\n      // TODO: verify this clipping doesn't reduce performance!\r\n      this.$main.css( 'clip', 'rect(0px,' + width + 'px,' + height + 'px,0px)' );\r\n      \r\n      this.sceneBounds = new Bounds2( 0, 0, width, height );\r\n    },\r\n    \r\n    resize: function( width, height ) {\r\n      if ( this.sceneBounds.width !== width || this.sceneBounds.height !== height ) {\r\n        this.setSize( width, height );\r\n        this.rebuildLayers(); // TODO: why? - change this to resize individual layers\r\n        \r\n        if ( accessibility ) {\r\n          this.resizeAccessibilityLayer( width, height );\r\n          this.resizeFocusRingSVGContainer( width, height );\r\n          \r\n          //Update the focus ring when the scene resizes.  Note: as of 5/10/2013 this only works properly when scaling up, and is buggy (off by a translation) when scaling down\r\n          if ( this.updateFocusRing && this.activePeer) {\r\n            // this.updateScene();\r\n            this.updateFocusRing();\r\n          }\r\n        }\r\n        \r\n        if ( this.input ) {\r\n          this.input.validatePointers();\r\n        }\r\n        \r\n        this.fireEvent( 'resize', { width: width, height: height } );\r\n      }\r\n    },\r\n    \r\n    resizeAccessibilityLayer: function( width, height ) {\r\n      if ( this.accessibilityLayer ) {\r\n        this.accessibilityLayer.setAttribute( 'width', width );\r\n        this.accessibilityLayer.setAttribute( 'height', height );\r\n        this.accessibilityLayer.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';\r\n      }\r\n    },\r\n    \r\n    resizeFocusRingSVGContainer: function( width, height ) {\r\n      if ( this.focusRingSVGContainer ) {\r\n        this.focusRingSVGContainer.setAttribute( 'width', width );\r\n        this.focusRingSVGContainer.setAttribute( 'height', height );\r\n        this.focusRingSVGContainer.style.clip = 'rect(0px,' + width + 'px,' + height + 'px,0px)';\r\n      }\r\n    },\r\n    \r\n    getSceneWidth: function() {\r\n      return this.sceneBounds.getWidth();\r\n    },\r\n    \r\n    getSceneHeight: function() {\r\n      return this.sceneBounds.getHeight();\r\n    },\r\n    \r\n    markSceneForLayerRefresh: function( instance ) {\r\n      sceneryLayerLog && sceneryLayerLog( 'Scene: marking layer refresh: ' + instance.trail.toString() );\r\n      this.markInterval( instance.trail );\r\n    },\r\n    \r\n    markSceneForInsertion: function( instance, child, index ) {\r\n      var affectedTrail = instance.trail.copy().addDescendant( child );\r\n      sceneryLayerLog && sceneryLayerLog( 'Scene: marking insertion: ' + affectedTrail.toString() );\r\n      \r\n      sceneryLayerLog && sceneryLayerLog( 'inserting instances onto ' + instance.toString() + ' with child ' + child.id + ' and index ' + index );\r\n      var baseInstance = instance.createChild( child, index );\r\n      \r\n      buildInstances( baseInstance );\r\n      \r\n      this.markInterval( affectedTrail );\r\n    },\r\n    \r\n    markSceneForRemoval: function( instance, child, index ) {\r\n      // mark the interval\r\n      var affectedTrail = instance.trail.copy().addDescendant( child );\r\n      sceneryLayerLog && sceneryLayerLog( 'Scene: marking removal: ' + affectedTrail.toString() );\r\n      this.markInterval( affectedTrail );\r\n      \r\n      // remove the necessary instances\r\n      var toRemove = [ instance.children[index] ];\r\n      instance.removeInstance( index );\r\n      while ( toRemove.length ) {\r\n        var item = toRemove.pop();\r\n        sceneryAssert && sceneryAssert( item, 'item instance should always exist' );\r\n        \r\n        // add its children\r\n        Array.prototype.push.apply( toRemove, item.children );\r\n        \r\n        item.dispose(); // removes it from the node and sets it up for easy GC\r\n      }\r\n    },\r\n    \r\n    updateCursor: function() {\r\n      if ( this.input && this.input.mouse.point ) {\r\n        var mouseTrail = this.trailUnderPoint( this.input.mouse.point, { isMouse: true } );\r\n        \r\n        if ( mouseTrail ) {\r\n          for ( var i = mouseTrail.length - 1; i >= 0; i-- ) {\r\n            var cursor = mouseTrail.nodes[i].getCursor();\r\n            \r\n            if ( cursor ) {\r\n              this.setSceneCursor( cursor );\r\n              return;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      \r\n      // fallback case\r\n      this.setSceneCursor( this.defaultCursor );\r\n    },\r\n    \r\n    setSceneCursor: function( cursor ) {\r\n      if ( cursor !== this.lastCursor ) {\r\n        this.lastCursor = cursor;\r\n        this.$main.css( 'cursor', cursor );\r\n      }\r\n    },\r\n    \r\n    updateOnRequestAnimationFrame: function( element ) {\r\n      var scene = this;\r\n      (function step() {\r\n        window.requestAnimationFrame( step, element );\r\n        scene.updateScene();\r\n      })();\r\n    },\r\n    \r\n    initializeStandaloneEvents: function( parameters ) {\r\n      // TODO extract similarity between standalone and fullscreen!\r\n      var element = this.$main[0];\r\n      this.initializeEvents( _.extend( {}, {\r\n        listenerTarget: element,\r\n        pointFromEvent: function pointFromEvent( evt ) {\r\n          var mainBounds = element.getBoundingClientRect();\r\n          return new Vector2( evt.clientX - mainBounds.left, evt.clientY - mainBounds.top );\r\n        }\r\n      }, parameters ) );\r\n    },\r\n    \r\n    initializeFullscreenEvents: function( parameters ) {\r\n      var element = this.$main[0];\r\n      this.initializeEvents( _.extend( {}, {\r\n        listenerTarget: document,\r\n        pointFromEvent: function pointFromEvent( evt ) {\r\n          var mainBounds = element.getBoundingClientRect();\r\n          return new Vector2( evt.clientX - mainBounds.left, evt.clientY - mainBounds.top );\r\n        }\r\n      }, parameters ) );\r\n    },\r\n    \r\n    initializeWindowEvents: function( parameters ) {\r\n      var element = this.$main[0];\r\n      this.initializeEvents( _.extend( {}, {\r\n        listenerTarget: window,\r\n        pointFromEvent: function pointFromEvent( evt ) {\r\n          var mainBounds = element.getBoundingClientRect();\r\n          return new Vector2( evt.clientX - mainBounds.left, evt.clientY - mainBounds.top );\r\n        }\r\n      }, parameters ) );\r\n    },\r\n    \r\n    initializeEvents: function( parameters ) {\r\n      var scene = this;\r\n      \r\n      if ( scene.input ) {\r\n        throw new Error( 'Attempt to attach events twice to the scene' );\r\n      }\r\n      \r\n      // TODO: come up with more parameter names that have the same string length, so it looks creepier\r\n      var pointFromEvent = parameters.pointFromEvent;\r\n      var listenerTarget = parameters.listenerTarget;\r\n      var batchDOMEvents = parameters.batchDOMEvents;\r\n      \r\n      var input = new scenery.Input( scene, listenerTarget, !!batchDOMEvents );\r\n      scene.input = input;\r\n      \r\n      // maps the current MS pointer types onto the pointer spec\r\n      function msPointerType( evt ) {\r\n        if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_TOUCH ) {\r\n          return 'touch';\r\n        } else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_PEN ) {\r\n          return 'pen';\r\n        } else if ( evt.pointerType === window.MSPointerEvent.MSPOINTER_TYPE_MOUSE ) {\r\n          return 'mouse';\r\n        } else {\r\n          return evt.pointerType; // hope for the best\r\n        }\r\n      }\r\n      \r\n      function forEachChangedTouch( evt, callback ) {\r\n        for ( var i = 0; i < evt.changedTouches.length; i++ ) {\r\n          // according to spec (http://www.w3.org/TR/touch-events/), this is not an Array, but a TouchList\r\n          var touch = evt.changedTouches.item( i );\r\n          \r\n          callback( touch.identifier, pointFromEvent( touch ) );\r\n        }\r\n      }\r\n      \r\n      // TODO: massive boilerplate reduction! closures should help tons!\r\n      \r\n      var implementsPointerEvents = window.navigator && window.navigator.pointerEnabled; // W3C spec for pointer events\r\n      var implementsMSPointerEvents = window.navigator && window.navigator.msPointerEnabled; // MS spec for pointer event\r\n      if ( this.enablePointerEvents && implementsPointerEvents ) {\r\n        sceneryEventLog && sceneryEventLog( 'Detected pointer events support, using that instead of mouse/touch events' );\r\n        // accepts pointer events corresponding to the spec at http://www.w3.org/TR/pointerevents/\r\n        input.addListener( 'pointerdown', function pointerDownCallback( domEvent ) {\r\n          input.pointerDown( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'pointerup', function pointerUpCallback( domEvent ) {\r\n          input.pointerUp( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'pointermove', function pointerMoveCallback( domEvent ) {\r\n          input.pointerMove( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'pointerover', function pointerOverCallback( domEvent ) {\r\n          input.pointerOver( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'pointerout', function pointerOutCallback( domEvent ) {\r\n          input.pointerOut( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'pointercancel', function pointerCancelCallback( domEvent ) {\r\n          input.pointerCancel( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        // immediate version\r\n        input.addImmediateListener( 'pointerup', function pointerUpCallback( domEvent ) {\r\n          input.pointerUpImmediate( domEvent.pointerId, domEvent.pointerType, pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n      } else if ( this.enablePointerEvents && implementsMSPointerEvents ) {\r\n        sceneryEventLog && sceneryEventLog( 'Detected MS pointer events support, using that instead of mouse/touch events' );\r\n        input.addListener( 'MSPointerDown', function msPointerDownCallback( domEvent ) {\r\n          input.pointerDown( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'MSPointerUp', function msPointerUpCallback( domEvent ) {\r\n          input.pointerUp( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'MSPointerMove', function msPointerMoveCallback( domEvent ) {\r\n          input.pointerMove( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'MSPointerOver', function msPointerOverCallback( domEvent ) {\r\n          input.pointerOver( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'MSPointerOut', function msPointerOutCallback( domEvent ) {\r\n          input.pointerOut( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'MSPointerCancel', function msPointerCancelCallback( domEvent ) {\r\n          input.pointerCancel( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        // immediate version\r\n        input.addImmediateListener( 'MSPointerUp', function msPointerUpCallback( domEvent ) {\r\n          input.pointerUpImmediate( domEvent.pointerId, msPointerType( domEvent ), pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n      } else {\r\n        sceneryEventLog && sceneryEventLog( 'No pointer events support detected, using mouse/touch events' );\r\n        input.addListener( 'mousedown', function mouseDownCallback( domEvent ) {\r\n          input.mouseDown( pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'mouseup', function mouseUpCallback( domEvent ) {\r\n          input.mouseUp( pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'mousemove', function mouseMoveCallback( domEvent ) {\r\n          input.mouseMove( pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'mouseover', function mouseOverCallback( domEvent ) {\r\n          input.mouseOver( pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        input.addListener( 'mouseout', function mouseOutCallback( domEvent ) {\r\n          input.mouseOut( pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        // immediate version\r\n        input.addImmediateListener( 'mouseup', function mouseUpCallback( domEvent ) {\r\n          input.mouseUpImmediate( pointFromEvent( domEvent ), domEvent );\r\n        } );\r\n        \r\n        input.addListener( 'touchstart', function touchStartCallback( domEvent ) {\r\n          sceneryEventLog && sceneryEventLog( 'touchstart (multiple events)' );\r\n          forEachChangedTouch( domEvent, function touchStartTouch( id, point ) {\r\n            input.touchStart( id, point, domEvent );\r\n          } );\r\n        } );\r\n        input.addListener( 'touchend', function touchEndCallback( domEvent ) {\r\n          sceneryEventLog && sceneryEventLog( 'touchend (multiple events)' );\r\n          forEachChangedTouch( domEvent, function touchEndTouch( id, point ) {\r\n            input.touchEnd( id, point, domEvent );\r\n          } );\r\n        } );\r\n        input.addListener( 'touchmove', function touchMoveCallback( domEvent ) {\r\n          sceneryEventLog && sceneryEventLog( 'touchmove (multiple events)' );\r\n          forEachChangedTouch( domEvent, function touchMoveTouch( id, point ) {\r\n            input.touchMove( id, point, domEvent );\r\n          } );\r\n        } );\r\n        input.addListener( 'touchcancel', function touchCancelCallback( domEvent ) {\r\n          sceneryEventLog && sceneryEventLog( 'touchcancel (multiple events)' );\r\n          forEachChangedTouch( domEvent, function touchCancelTouch( id, point ) {\r\n            input.touchCancel( id, point, domEvent );\r\n          } );\r\n        } );\r\n        // immediate version\r\n        input.addImmediateListener( 'touchend', function touchEndCallback( domEvent ) {\r\n          sceneryEventLog && sceneryEventLog( 'touchend immediate (multiple events)' );\r\n          forEachChangedTouch( domEvent, function touchEndTouch( id, point ) {\r\n            input.touchEndImmediate( id, point, domEvent );\r\n          } );\r\n        } );\r\n      }\r\n      \r\n      input.addListener( 'keyup', function keyUpCallback( domEvent ) {\r\n        input.keyUp( domEvent );\r\n      } );\r\n      input.addListener( 'keydown', function keyDownCallback( domEvent ) {\r\n        input.keyDown( domEvent );\r\n      } );\r\n      input.addListener( 'keypress', function keyPressCallback( domEvent ) {\r\n        input.keyPress( domEvent );\r\n      } );\r\n    },\r\n    \r\n    getTrailFromKeyboardFocus: function() {\r\n      // return the root (scene) trail by default\r\n      // TODO: fill in with actual keyboard focus\r\n      return new scenery.Trail( this );\r\n    },\r\n    \r\n    fireBatchedEvents: function() {\r\n      this.input.fireBatchedEvents();\r\n    },\r\n    \r\n    resizeOnWindowResize: function() {\r\n      var scene = this;\r\n      \r\n      var resizer = function() {\r\n        scene.resize( window.innerWidth, window.innerHeight );\r\n      };\r\n      $( window ).resize( resizer );\r\n      resizer();\r\n    },\r\n    \r\n    // in-depth check to make sure everything is layered properly\r\n    layerAudit: function() {\r\n      var scene = this;\r\n      \r\n      var boundaries = this.calculateBoundaries( null, null, null );\r\n      sceneryAssert && sceneryAssert( boundaries.length === this.layers.length + 1, 'boundary count (' + boundaries.length + ') does not match layer count (' + this.layers.length + ') + 1' );\r\n      \r\n      // count how many 'self' trails there are\r\n      var eachTrailUnderPaintedCount = 0;\r\n      new scenery.Trail( this ).eachTrailUnder( function( trail ) {\r\n        if ( trail.isPainted() ) {\r\n          eachTrailUnderPaintedCount++;\r\n          \r\n          sceneryAssert && sceneryAssert( trail.getInstance(), 'every painted trail must have an instance' );\r\n        }\r\n        \r\n        sceneryAssert && sceneryAssert( trail.getInstance() && trail.getInstance().trail.equals( trail ), 'every trail must have a single corresponding instance' );\r\n      } );\r\n      \r\n      var layerPaintedCount = 0;\r\n      _.each( this.layers, function( layer ) {\r\n        layerPaintedCount += layer.getLayerTrails().length;\r\n        \r\n        // reindex now so we don't have problems later\r\n        layer.startPaintedTrail.reindex();\r\n        layer.endPaintedTrail.reindex();\r\n      } );\r\n      \r\n      var layerIterationPaintedCount = 0;\r\n      _.each( this.layers, function( layer ) {\r\n        var selfCount = 0;\r\n        scenery.Trail.eachPaintedTrailBetween( layer.startPaintedTrail, layer.endPaintedTrail, function( trail ) {\r\n          selfCount++;\r\n        }, false, scene );\r\n        sceneryAssert && sceneryAssert( selfCount > 0, 'every layer must have at least one self trail' );\r\n        layerIterationPaintedCount += selfCount;\r\n      } );\r\n      \r\n      sceneryAssert && sceneryAssert( eachTrailUnderPaintedCount === layerPaintedCount, 'cross-referencing self trail counts: layerPaintedCount, ' + eachTrailUnderPaintedCount + ' vs ' + layerPaintedCount );\r\n      sceneryAssert && sceneryAssert( eachTrailUnderPaintedCount === layerIterationPaintedCount, 'cross-referencing self trail counts: layerIterationPaintedCount, ' + eachTrailUnderPaintedCount + ' vs ' + layerIterationPaintedCount );\r\n      \r\n      _.each( this.layers, function( layer ) {\r\n        sceneryAssert && sceneryAssert( layer.startPaintedTrail.compare( layer.endPaintedTrail ) <= 0, 'proper ordering on layer trails' );\r\n      } );\r\n      \r\n      for ( var i = 1; i < this.layers.length; i++ ) {\r\n        sceneryAssert && sceneryAssert( this.layers[i-1].endPaintedTrail.compare( this.layers[i].startPaintedTrail ) === -1, 'proper ordering of layer trail boundaries in scene.layers array' );\r\n        sceneryAssert && sceneryAssert( this.layers[i-1].endBoundary === this.layers[i].startBoundary, 'proper sharing of boundaries' );\r\n      }\r\n      \r\n      _.each( this.layers, function( layer ) {\r\n        // a list of trails that the layer tracks\r\n        var layerTrails = layer.getLayerTrails();\r\n        \r\n        // a list of trails that the layer should be tracking (between painted trails)\r\n        var computedTrails = [];\r\n        scenery.Trail.eachPaintedTrailBetween( layer.startPaintedTrail, layer.endPaintedTrail, function( trail ) {\r\n          computedTrails.push( trail.copy() );\r\n        }, false, scene );\r\n        \r\n        // verify that the layer has an identical record of trails compared to the trails inside its boundaries\r\n        sceneryAssert && sceneryAssert( layerTrails.length === computedTrails.length, 'layer has incorrect number of tracked trails' );\r\n        _.each( layerTrails, function( trail ) {\r\n          sceneryAssert && sceneryAssert( _.some( computedTrails, function( otherTrail ) { return trail.equals( otherTrail ); } ), 'layer has a tracked trail discrepancy' );\r\n        } );\r\n        \r\n        // verify that each trail has the same (or null) renderer as the layer\r\n        scenery.Trail.eachTrailBetween( layer.startPaintedTrail, layer.endPaintedTrail, function( trail ) {\r\n          var node = trail.lastNode();\r\n          sceneryAssert && sceneryAssert( !node.renderer || node.renderer.name === layer.type.name, 'specified renderers should match the layer renderer' );\r\n        }, false, scene );\r\n      } );\r\n      \r\n      // verify layer splits\r\n      new scenery.Trail( this ).eachTrailUnder( function( trail ) {\r\n        var beforeSplitTrail;\r\n        var afterSplitTrail;\r\n        if ( trail.lastNode().layerSplitBefore ) {\r\n          beforeSplitTrail = trail.previousPainted();\r\n          afterSplitTrail = trail.lastNode().isPainted() ? trail : trail.nextPainted();\r\n          sceneryAssert && sceneryAssert( !beforeSplitTrail || !afterSplitTrail || beforeSplitTrail.getInstance().layer !== afterSplitTrail.getInstance().layer, 'layerSplitBefore layers need to be different' );\r\n        }\r\n        if ( trail.lastNode().layerSplitAfter ) {\r\n          // shift a pointer from the (nested) end of the trail to the next isBefore (if available)\r\n          var ptr = new scenery.TrailPointer( trail.copy(), false );\r\n          while ( ptr && ptr.isAfter ) {\r\n            ptr = ptr.nestedForwards();\r\n          }\r\n          \r\n          // if !ptr, we walked off the end of the graph (nothing after layer split, automatically ok)\r\n          if ( ptr ) {\r\n            beforeSplitTrail = ptr.trail.previousPainted();\r\n            afterSplitTrail = ptr.trail.lastNode().isPainted() ? ptr.trail : ptr.trail.nextPainted();\r\n            sceneryAssert && sceneryAssert( !beforeSplitTrail || !afterSplitTrail || beforeSplitTrail.getInstance().layer !== afterSplitTrail.getInstance().layer, 'layerSplitAfter layers need to be different' );\r\n          }\r\n        }\r\n      } );\r\n      \r\n      return true; // so we can assert( layerAudit() )\r\n    },\r\n    \r\n    getDebugHTML: function() {\r\n      var startPointer = new scenery.TrailPointer( new scenery.Trail( this ), true );\r\n      var endPointer = new scenery.TrailPointer( new scenery.Trail( this ), false );\r\n      \r\n      function str( ob ) {\r\n        return ob ? ob.toString() : ob;\r\n      }\r\n      \r\n      var depth = 0;\r\n      \r\n      var result = '';\r\n      \r\n      var layerStartEntries = {};\r\n      var layerEndEntries = {};\r\n      _.each( this.layers, function( layer ) {\r\n        var startIdx = layer.startPaintedTrail.getUniqueId();\r\n        var endIndex = layer.endPaintedTrail.getUniqueId();\r\n        layerStartEntries[startIdx] = '';\r\n        layerEndEntries[endIndex] = '';\r\n        layer.startPaintedTrail.reindex();\r\n        layer.endPaintedTrail.reindex();\r\n        var layerInfo = layer.getId() + ' <strong>' + layer.type.name + '</strong>' +\r\n                        ' trails: ' + ( layer.startPaintedTrail ? str( layer.startPaintedTrail ) : layer.startPaintedTrail ) +\r\n                        ',' + ( layer.endPaintedTrail ? str( layer.endPaintedTrail ) : layer.endPaintedTrail );\r\n        layerInfo += '<span style=\"color: #008\">';\r\n        if ( layer.canUseDirtyRegions && !layer.canUseDirtyRegions() ) { layerInfo += ' dirtyRegionsDisabled'; }\r\n        if ( layer.cssTranslation ) { layerInfo += ' cssTranslation'; }\r\n        if ( layer.cssRotation ) { layerInfo += ' cssTranslation'; }\r\n        if ( layer.cssScale ) { layerInfo += ' cssTranslation'; }\r\n        if ( layer.cssTransform ) { layerInfo += ' cssTranslation'; }\r\n        if ( layer.dirtyBounds && layer.dirtyBounds.isFinite() ) { layerInfo += ' dirtyBounds:' + layer.dirtyBounds.toString(); }\r\n        layerInfo += '</span>';\r\n        layerStartEntries[startIdx] += '<div style=\"color: #080\">+Layer ' + layerInfo + '</div>';\r\n        layerEndEntries[endIndex] += '<div style=\"color: #800\">-Layer ' + layerInfo + '</div>';\r\n      } );\r\n      \r\n      startPointer.depthFirstUntil( endPointer, function( pointer ) {\r\n        var div;\r\n        var ptr = str( pointer );\r\n        var node = pointer.trail.lastNode();\r\n        \r\n        function addQualifier( text ) {\r\n            div += ' <span style=\"color: #008\">' + text + '</span>';\r\n          }\r\n        \r\n        if ( pointer.isBefore && layerStartEntries[pointer.trail.getUniqueId()] ) {\r\n          result += layerStartEntries[pointer.trail.getUniqueId()];\r\n        }\r\n        if ( pointer.isBefore ) {\r\n          div = '<div style=\"margin-left: ' + ( depth * 20 ) + 'px\">';\r\n          if ( node.constructor.name ) {\r\n            div += ' ' + node.constructor.name; // see http://stackoverflow.com/questions/332422/how-do-i-get-the-name-of-an-objects-type-in-javascript\r\n          }\r\n          div += ' <span style=\"font-weight: ' + ( node.isPainted() ? 'bold' : 'normal' ) + '\">' + pointer.trail.lastNode().getId() + '</span>';\r\n          div += ' <span style=\"color: #888\">' + str( pointer.trail ) + '</span>';\r\n          if ( !node._visible ) {\r\n            addQualifier( 'invisible' );\r\n          }\r\n          if ( !node._pickable ) {\r\n            addQualifier( 'unpickable' );\r\n          }\r\n          if ( node._clipShape ) {\r\n            addQualifier( 'clipShape' );\r\n          }\r\n          if ( node._renderer ) {\r\n            addQualifier( 'renderer:' + node._renderer.name );\r\n          }\r\n          if ( node._rendererOptions ) {\r\n            // addQualifier( 'rendererOptions:' + _.each( node._rendererOptions, function( option, key ) { return key + ':' + str( option ); } ).join( ',' ) );\r\n          }\r\n          if ( node._layerSplitBefore ) {\r\n            addQualifier( 'layerSplitBefore' );\r\n          }\r\n          if ( node._layerSplitAfter ) {\r\n            addQualifier( 'layerSplitAfter' );\r\n          }\r\n          if ( node._opacity < 1 ) {\r\n            addQualifier( 'opacity:' + node._opacity );\r\n          }\r\n          \r\n          var transformType = '';\r\n          switch ( node.transform.getMatrix().type ) {\r\n            case Matrix3.Types.IDENTITY:       transformType = '';           break;\r\n            case Matrix3.Types.TRANSLATION_2D: transformType = 'translated'; break;\r\n            case Matrix3.Types.SCALING:        transformType = 'scale';      break;\r\n            case Matrix3.Types.AFFINE:         transformType = 'affine';     break;\r\n            case Matrix3.Types.OTHER:          transformType = 'other';      break;\r\n          }\r\n          if ( transformType ) {\r\n            div += ' <span style=\"color: #88f\" title=\"' + node.transform.getMatrix().toString().replace( '\\n', '&#10;' ) + '\">' + transformType + '</span>';\r\n          }\r\n          div += '</div>';\r\n          result += div;\r\n        }\r\n        if ( pointer.isAfter && layerEndEntries[pointer.trail.getUniqueId()] ) {\r\n          result += layerEndEntries[pointer.trail.getUniqueId()];\r\n        }\r\n        depth += pointer.isBefore ? 1 : -1;\r\n      }, false );\r\n      \r\n      return result;\r\n    },\r\n    \r\n    popupDebug: function() {\r\n      var htmlContent = '<!DOCTYPE html>' +\r\n                        '<html lang=\"en\">' +\r\n                        '<head><title>Scenery Debug Snapshot</title></head>' +\r\n                        '<body>' + this.getDebugHTML() + '</body>' +\r\n                        '</html>';\r\n      window.open( 'data:text/html;charset=utf-8,' + encodeURIComponent( htmlContent ) );\r\n    },\r\n    \r\n    getBasicConstructor: function( propLines ) {\r\n      return 'new scenery.Scene( $( \\'#main\\' ), {' + propLines + '} )';\r\n    },\r\n    \r\n    toStringWithChildren: function( mutateScene ) {\r\n      var scene = this;\r\n      var result = '';\r\n      \r\n      var nodes = this.getTopologicallySortedNodes().slice( 0 ).reverse(); // defensive slice, in case we store the order somewhere\r\n      \r\n      function name( node ) {\r\n        return node === scene ? 'scene' : node.constructor.name.toLowerCase() + node.id;\r\n      }\r\n      \r\n      _.each( nodes, function( node ) {\r\n        if ( result ) {\r\n          result += '\\n';\r\n        }\r\n        \r\n        if ( mutateScene && node === scene ) {\r\n          var props = scene.getPropString( '  ', false );\r\n          result += 'scene.mutate( {' + ( props ? ( '\\n' + props + '\\n' ) : '' ) + '} )';\r\n        } else {\r\n          result += 'var ' + name( node ) + ' = ' + node.toString( '', false );\r\n        }\r\n        \r\n        _.each( node.children, function( child ) {\r\n          result += '\\n' + name( node ) + '.addChild( ' + name( child ) + ' );';\r\n        } );\r\n      } );\r\n      \r\n      return result;\r\n    }\r\n  } );\r\n  \r\n  function applyCSSHacks( $main, options ) {\r\n    // to use CSS3 transforms for performance, hide anything outside our bounds by default\r\n    if ( !options.allowSceneOverflow ) {\r\n      $main.css( 'overflow', 'hidden' );\r\n    }\r\n    \r\n    // forward all pointer events\r\n    $main.css( '-ms-touch-action', 'none' );\r\n    \r\n    if ( options.allowCSSHacks ) {\r\n      // some css hacks (inspired from https://github.com/EightMedia/hammer.js/blob/master/hammer.js)\r\n      (function() {\r\n        var prefixes = [ '-webkit-', '-moz-', '-ms-', '-o-', '' ];\r\n        var properties = {\r\n          userSelect: 'none',\r\n          touchCallout: 'none',\r\n          touchAction: 'none',\r\n          userDrag: 'none',\r\n          tapHighlightColor: 'rgba(0,0,0,0)'\r\n        };\r\n        \r\n        _.each( prefixes, function( prefix ) {\r\n          _.each( properties, function( propertyValue, propertyName ) {\r\n            $main.css( prefix + propertyName, propertyValue );\r\n          } );\r\n        } );\r\n      })();\r\n    }\r\n  }\r\n  \r\n  return Scene;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * A rectangular node that inherits Path, and allows for optimized drawing,\r\n * and improved rectangle handling.\r\n *\r\n * TODO: add DOM support\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/nodes/Rectangle',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Path','KITE/Shape','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  \r\n  /**\r\n   * Currently, all numerical parameters should be finite.\r\n   * x:         x-position of the upper-left corner (left bound)\r\n   * y:         y-position of the upper-left corner (top bound)\r\n   * width:     width of the rectangle to the right of the upper-left corner, required to be >= 0\r\n   * height:    height of the rectangle below the upper-left corner, required to be >= 0\r\n   * arcWidth:  positive width of the rounded corner, or 0 to indicate the corner should be sharp\r\n   * arcHeight: positive height of the rounded corner, or 0 to indicate the corner should be sharp\r\n   */\r\n  scenery.Rectangle = function Rectangle( x, y, width, height, arcWidth, arcHeight, options ) {\r\n    if ( typeof x === 'object' ) {\r\n      // allow new Rectangle( { rectX: x, rectY: y, rectWidth: width, rectHeight: height, ... } )\r\n      // the mutators will call invalidateRectangle() and properly set the shape\r\n      options = x;\r\n    } else if ( arguments.length < 6 ) {\r\n      // new Rectangle( x, y, width, height, [options] )\r\n      this._rectX = x;\r\n      this._rectY = y;\r\n      this._rectWidth = width;\r\n      this._rectHeight = height;\r\n      this._rectArcWidth = 0;\r\n      this._rectArcHeight = 0;\r\n      \r\n      // ensure we have a parameter object\r\n      options = arcWidth || {};\r\n      \r\n      // fallback for non-canvas or non-svg rendering, and for proper bounds computation\r\n      options.shape = this.createRectangleShape();\r\n    } else {\r\n      // normal case with args (including arcWidth / arcHeight)\r\n      this._rectX = x;\r\n      this._rectY = y;\r\n      this._rectWidth = width;\r\n      this._rectHeight = height;\r\n      this._rectArcWidth = arcWidth;\r\n      this._rectArcHeight = arcHeight;\r\n      \r\n      // ensure we have a parameter object\r\n      options = options || {};\r\n      \r\n      // fallback for non-canvas or non-svg rendering, and for proper bounds computation\r\n      options.shape = this.createRectangleShape();\r\n    }\r\n    \r\n    Path.call( this, options );\r\n  };\r\n  var Rectangle = scenery.Rectangle;\r\n  \r\n  inherit( Path, Rectangle, {\r\n    setRect: function( x, y, width, height, arcWidth, arcHeight ) {\r\n      sceneryAssert && sceneryAssert( x !== undefined && y !== undefined && width !== undefined && height !== undefined, 'x/y/width/height need to be defined' );\r\n      \r\n      this._rectX = x;\r\n      this._rectY = y;\r\n      this._rectWidth = width;\r\n      this._rectHeight = height;\r\n      this._rectArcWidth = arcWidth || 0;\r\n      this._rectArcHeight = arcHeight || 0;\r\n      this.invalidateRectangle();\r\n    },\r\n    \r\n    isRounded: function() {\r\n      return this._rectArcWidth !== 0 && this._rectArcHeight !== 0;\r\n    },\r\n    \r\n    createRectangleShape: function() {\r\n      sceneryAssert && sceneryAssert( isFinite( this._rectX ), 'A rectangle needs to have a finite x (' + this._rectX + ')' );\r\n      sceneryAssert && sceneryAssert( isFinite( this._rectY ), 'A rectangle needs to have a finite x (' + this._rectY + ')' );\r\n      sceneryAssert && sceneryAssert( this._rectWidth >= 0 && isFinite( this._rectWidth ),\r\n                                      'A rectangle needs to have a non-negative finite width (' + this._rectWidth + ')' );\r\n      sceneryAssert && sceneryAssert( this._rectHeight >= 0 && isFinite( this._rectHeight ),\r\n                                      'A rectangle needs to have a non-negative finite height (' + this._rectHeight + ')' );\r\n      sceneryAssert && sceneryAssert( this._rectArcWidth >= 0 && isFinite( this._rectArcWidth ),\r\n                                      'A rectangle needs to have a non-negative finite arcWidth (' + this._rectArcWidth + ')' );\r\n      sceneryAssert && sceneryAssert( this._rectArcHeight >= 0 && isFinite( this._rectArcHeight ),\r\n                                      'A rectangle needs to have a non-negative finite arcHeight (' + this._rectArcHeight + ')' );\r\n      // sceneryAssert && sceneryAssert( !this.isRounded() || ( this._rectWidth >= this._rectArcWidth * 2 && this._rectHeight >= this._rectArcHeight * 2 ),\r\n      //                                 'The rounded sections of the rectangle should not intersect (the length of the straight sections shouldn\\'t be negative' );\r\n      \r\n      if ( this.isRounded() ) {\r\n        // copy border-radius CSS behavior in Chrome, where the arcs won't intersect, in cases where the arc segments at full size would intersect each other\r\n        var maximumArcSize = Math.min( this._rectWidth / 2, this._rectHeight / 2 );\r\n        return Shape.roundRectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight,\r\n                                     Math.min( maximumArcSize, this._rectArcWidth ), Math.min( maximumArcSize, this._rectArcHeight ) );\r\n      } else {\r\n        return Shape.rectangle( this._rectX, this._rectY, this._rectWidth, this._rectHeight );\r\n      }\r\n    },\r\n    \r\n    invalidateRectangle: function() {\r\n      // setShape should invalidate the path and ensure a redraw\r\n      this.setShape( this.createRectangleShape() );\r\n    },\r\n    \r\n    computeShapeBounds: function() {\r\n      // optimization, where we know our computed bounds will be just expanded by half the lineWidth if we are stroked (don't have to compute the stroke shape)\r\n      return this._stroke ? this._shape.bounds.dilated( this._lineDrawingStyles.lineWidth / 2 ) : this._shape.bounds;\r\n    },\r\n    \r\n    // accelerated hit detection for axis-aligned optionally-rounded rectangle\r\n    // fast computation if it isn't rounded. if rounded, we check if a corner computation is needed (usually isn't), and only check that one needed corner\r\n    containsPointSelf: function( point ) {\r\n      var result = point.x >= this._rectX &&\r\n                   point.x <= this._rectX + this._rectWidth &&\r\n                   point.y >= this._rectY &&\r\n                   point.y <= this._rectY + this._rectHeight;\r\n      \r\n      if ( !result || !this.isRounded() ) {\r\n        return result;\r\n      }\r\n      \r\n      // we are rounded and inside the logical rectangle (if it didn't have rounded corners)\r\n      \r\n      // closest corner arc's center (we assume the rounded rectangle's arcs are 90 degrees fully, and don't intersect)\r\n      var closestCornerX, closestCornerY, guaranteedInside = false;\r\n      \r\n      // if we are to the inside of the closest corner arc's center, we are guaranteed to be in the rounded rectangle (guaranteedInside)\r\n      if ( point.x < this._rectX + this._rectWidth / 2 ) {\r\n        closestCornerX = this._rectX + this._rectArcWidth;\r\n        guaranteedInside = guaranteedInside || point.x >= closestCornerX;\r\n      } else {\r\n        closestCornerX = this._rectX + this._rectWidth - this._rectArcWidth;\r\n        guaranteedInside = guaranteedInside || point.x <= closestCornerX;\r\n      }\r\n      if ( guaranteedInside ) { return true; }\r\n      \r\n      if ( point.y < this._rectY + this._rectHeight / 2 ) {\r\n        closestCornerY = this._rectY + this._rectArcHeight;\r\n        guaranteedInside = guaranteedInside || point.y >= closestCornerY;\r\n      } else {\r\n        closestCornerY = this._rectY + this._rectHeight - this._rectArcHeight;\r\n        guaranteedInside = guaranteedInside || point.y <= closestCornerY;\r\n      }\r\n      if ( guaranteedInside ) { return true; }\r\n      \r\n      // we are now in the rectangular region between the logical corner and the center of the closest corner's arc.\r\n      \r\n      // offset from the closest corner's arc center\r\n      var offsetX = point.x - closestCornerX;\r\n      var offsetY = point.y - closestCornerY;\r\n      \r\n      // normalize the coordinates so now we are dealing with a unit circle\r\n      // (technically arc, but we are guaranteed to be in the area covered by the arc, so we just consider the circle)\r\n      // NOTE: we are rounded, so both arcWidth and arcHeight are non-zero (this is well defined)\r\n      offsetX /= this._rectArcWidth;\r\n      offsetY /= this._rectArcHeight;\r\n      \r\n      offsetX *= offsetX;\r\n      offsetY *= offsetY;\r\n      return offsetX + offsetY <= 1; // return whether we are in the rounded corner. see the formula for an ellipse\r\n    },\r\n    \r\n    // override paintCanvas with a faster version, since fillRect and drawRect don't affect the current default path\r\n    paintCanvas: function( wrapper ) {\r\n      var context = wrapper.context;\r\n      \r\n      // use the standard version if it's a rounded rectangle, since there is no Canvas-optimized version for that\r\n      if ( this.isRounded() ) {\r\n        return Path.prototype.paintCanvas.call( this, wrapper );\r\n      }\r\n      \r\n      // TODO: how to handle fill/stroke delay optimizations here?\r\n      if ( this._fill ) {\r\n        this.beforeCanvasFill( wrapper ); // defined in Fillable\r\n        context.fillRect( this._rectX, this._rectY, this._rectWidth, this._rectHeight );\r\n        this.afterCanvasFill( wrapper ); // defined in Fillable\r\n      }\r\n      if ( this._stroke ) {\r\n        this.beforeCanvasStroke( wrapper ); // defined in Strokable\r\n        context.strokeRect( this._rectX, this._rectY, this._rectWidth, this._rectHeight );\r\n        this.afterCanvasStroke( wrapper ); // defined in Strokable\r\n      }\r\n    },\r\n    \r\n    // create a rect instead of a path, hopefully it is faster in implementations\r\n    createSVGFragment: function( svg, defs, group ) {\r\n      return document.createElementNS( 'http://www.w3.org/2000/svg', 'rect' );\r\n    },\r\n    \r\n    // optimized for the rect element instead of path\r\n    updateSVGFragment: function( rect ) {\r\n      // see http://www.w3.org/TR/SVG/shapes.html#RectElement\r\n      rect.setAttribute( 'x', this._rectX );\r\n      rect.setAttribute( 'y', this._rectY );\r\n      rect.setAttribute( 'width', this._rectWidth );\r\n      rect.setAttribute( 'height', this._rectHeight );\r\n      rect.setAttribute( 'rx', this._rectArcWidth );\r\n      rect.setAttribute( 'ry', this._rectArcHeight );\r\n      \r\n      rect.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );\r\n    },\r\n    \r\n    getBasicConstructor: function( propLines ) {\r\n      return 'new scenery.Rectangle( ' + this._rectX + ', ' + this._rectY + ', ' + \r\n                                         this._rectWidth + ', ' + this._rectHeight + ', ' +\r\n                                         this._rectArcWidth + ', ' + this._rectArcHeight + ', {' + propLines + '} )';\r\n    }\r\n    \r\n  } );\r\n  \r\n  function addRectProp( capitalizedShort ) {\r\n    var getName = 'getRect' + capitalizedShort;\r\n    var setName = 'setRect' + capitalizedShort;\r\n    var privateName = '_rect' + capitalizedShort;\r\n    \r\n    Rectangle.prototype[getName] = function() {\r\n      return this[privateName];\r\n    };\r\n    \r\n    Rectangle.prototype[setName] = function( value ) {\r\n      this[privateName] = value;\r\n      this.invalidateRectangle();\r\n      return this;\r\n    };\r\n    \r\n    Object.defineProperty( Rectangle.prototype, 'rect' + capitalizedShort, {\r\n      set: Rectangle.prototype[setName],\r\n      get: Rectangle.prototype[getName]\r\n    } );\r\n  }\r\n  \r\n  addRectProp( 'X' );\r\n  addRectProp( 'Y' );\r\n  addRectProp( 'Width' );\r\n  addRectProp( 'Height' );\r\n  addRectProp( 'ArcWidth' );\r\n  addRectProp( 'ArcHeight' );\r\n  \r\n  // not adding mutators for now\r\n  Rectangle.prototype._mutatorKeys = [ 'rectX', 'rectY', 'rectWidth', 'rectHeight', 'rectArcWidth', 'rectArcHeight' ].concat( Path.prototype._mutatorKeys );\r\n  \r\n  return Rectangle;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Basic dragging for a node.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/input/SimpleDragHandler',['require','DOT/Matrix3','SCENERY/scenery'],function( require ) {\r\n  'use strict';\r\n  \r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  /*\r\n   * Allowed options: {\r\n   *    allowTouchSnag: false // allow touch swipes across an object to pick it up,\r\n   *    mouseButton: 0        // allow changing the mouse button that activates the drag listener. -1 should activate on any mouse button, 0 on left, 1 for middle, 2 for right, etc.\r\n   *    start: null           // if non-null, called when a drag is started. start( event, trail )\r\n   *    drag: null            // if non-null, called when the user moves something with a drag (not a start or end event).\r\n   *                                                                         drag( event, trail )\r\n   *    end: null             // if non-null, called when a drag is ended.   end( event, trail )\r\n   *    translate:            // if this exists, translate( { delta: _, oldPosition: _, position: _ } ) will be called instead of directly translating the node\r\n   * }\r\n   */\r\n  scenery.SimpleDragHandler = function SimpleDragHandler( options ) {\r\n    var handler = this;\r\n    \r\n    this.options = _.extend( {\r\n      allowTouchSnag: false,\r\n      mouseButton: 0\r\n    }, options );\r\n    \r\n    this.dragging              = false;     // whether a node is being dragged with this handler\r\n    this.pointer               = null;      // the pointer doing the current dragging\r\n    this.trail                 = null;      // stores the path to the node that is being dragged\r\n    this.transform             = null;      // transform of the trail to our node (but not including our node, so we can prepend the deltas)\r\n    this.node                  = null;      // the node that we are handling the drag for\r\n    this.lastDragPoint         = null;      // the location of the drag at the previous event (so we can calculate a delta)\r\n    this.startTransformMatrix  = null;      // the node's transform at the start of the drag, so we can reset on a touch cancel\r\n    this.mouseButton           = undefined; // tracks which mouse button was pressed, so we can handle that specifically\r\n    // TODO: consider mouse buttons as separate pointers?\r\n    \r\n    // if an ancestor is transformed, pin our node\r\n    this.transformListener = {\r\n      transform: function( args ) {\r\n        if ( !handler.trail.isExtensionOf( args.trail, true ) ) {\r\n          return;\r\n        }\r\n        \r\n        var newMatrix = args.trail.getTransform().getMatrix();\r\n        var oldMatrix = handler.transform.getMatrix();\r\n        \r\n        // if A was the trail's old transform, B is the trail's new transform, we need to apply (B^-1 A) to our node\r\n        handler.node.prependMatrix( newMatrix.inverted().timesMatrix( oldMatrix ) );\r\n        \r\n        // store the new matrix so we can do deltas using it now\r\n        handler.transform.set( newMatrix );\r\n      }\r\n    };\r\n    \r\n    // this listener gets added to the pointer when it starts dragging our node\r\n    this.dragListener = {\r\n      // mouse/touch up\r\n      up: function( event ) {\r\n        sceneryAssert && sceneryAssert( event.pointer === handler.pointer );\r\n        if ( !event.pointer.isMouse || event.domEvent.button === handler.mouseButton ) {\r\n          handler.endDrag( event );\r\n        }\r\n      },\r\n      \r\n      // touch cancel\r\n      cancel: function( event ) {\r\n        sceneryAssert && sceneryAssert( event.pointer === handler.pointer );\r\n        handler.endDrag( event );\r\n        \r\n        // since it's a cancel event, go back!\r\n        handler.node.setMatrix( handler.startTransformMatrix );\r\n      },\r\n      \r\n      // mouse/touch move\r\n      move: function( event ) {\r\n        sceneryAssert && sceneryAssert( event.pointer === handler.pointer );\r\n        \r\n        var delta = handler.transform.inverseDelta2( handler.pointer.point.minus( handler.lastDragPoint ) );\r\n        \r\n        // move by the delta between the previous point, using the precomputed transform\r\n        // prepend the translation on the node, so we can ignore whatever other transform state the node has\r\n        if ( handler.options.translate ) {\r\n          var translation = handler.node.getTransform().getMatrix().getTranslation();\r\n          handler.options.translate( {\r\n            delta: delta,\r\n            oldPosition: translation,\r\n            position: translation.plus( delta )\r\n          } );\r\n        } else {\r\n          handler.node.translate( delta, true );\r\n        }\r\n        handler.lastDragPoint = handler.pointer.point;\r\n        \r\n        if ( handler.options.drag ) {\r\n          // TODO: consider adding in a delta to the listener\r\n          // TODO: add the position in to the listener\r\n          handler.options.drag( event, handler.trail ); // new position (old position?) delta\r\n        }\r\n      }\r\n    };\r\n  };\r\n  var SimpleDragHandler = scenery.SimpleDragHandler;\r\n  \r\n  SimpleDragHandler.prototype = {\r\n    constructor: SimpleDragHandler,\r\n    \r\n    startDrag: function( event ) {\r\n      // set a flag on the pointer so it won't pick up other nodes\r\n      event.pointer.dragging = true;\r\n      event.pointer.addInputListener( this.dragListener );\r\n      // event.trail.rootNode().addEventListener( this.transformListener ); // TODO: replace with new parent transform listening solution\r\n      \r\n      // set all of our persistent information\r\n      this.dragging = true;\r\n      this.pointer = event.pointer;\r\n      this.trail = event.trail.subtrailTo( event.currentTarget, true );\r\n      this.transform = this.trail.getTransform();\r\n      this.node = event.currentTarget;\r\n      this.lastDragPoint = event.pointer.point;\r\n      this.startTransformMatrix = event.currentTarget.getMatrix();\r\n      // event.domEvent may not exist if this is touch-to-snag\r\n      this.mouseButton = event.pointer.isMouse ? event.domEvent.button : undefined;\r\n      \r\n      if ( this.options.start ) {\r\n        this.options.start( event, this.trail );\r\n      }\r\n    },\r\n    \r\n    endDrag: function( event ) {\r\n      this.pointer.dragging = false;\r\n      this.pointer.removeInputListener( this.dragListener );\r\n      // this.trail.rootNode().removeEventListener( this.transformListener ); // TODO: replace with new parent transform listening solution\r\n      this.dragging = false;\r\n      \r\n      if ( this.options.end ) {\r\n        this.options.end( event, this.trail );\r\n      }\r\n    },\r\n    \r\n    tryToSnag: function( event ) {\r\n      // don't allow drag attempts that use the wrong mouse button (-1 indicates any mouse button works)\r\n      if ( event.pointer.isMouse && event.domEvent && this.options.mouseButton !== event.domEvent.button && this.options.mouseButton !== -1 ) {\r\n        return;\r\n      }\r\n      \r\n      // only start dragging if the pointer isn't dragging anything, we aren't being dragged, and if it's a mouse it's button is down\r\n      if ( !this.dragging && !event.pointer.dragging ) {\r\n        this.startDrag( event );\r\n      }\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * events called from the node input listener\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // mouse/touch down on this node\r\n    down: function( event ) {\r\n      this.tryToSnag( event );\r\n    },\r\n    \r\n    // touch enters this node\r\n    touchenter: function( event ) {\r\n      // allow touches to start a drag by moving \"over\" this node\r\n      if ( this.options.allowTouchSnag ) {\r\n        this.tryToSnag( event );\r\n      }\r\n    }\r\n  };\r\n  \r\n  return SimpleDragHandler;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Provides access to font-awesome glyphs as scenery nodes.\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'SUN/FontAwesomeNode',['require','SCENERY/nodes/Image','SCENERY/nodes/VBox','SCENERY/nodes/DOM','SCENERY/nodes/Node','SCENERY/nodes/HBox','SCENERY/Scene','SCENERY/nodes/Text','SCENERY/nodes/Path','SCENERY/nodes/Rectangle','KITE/Shape','SCENERY/input/SimpleDragHandler','DOT/Bounds2','DOT/Matrix3','PHET_CORE/inherit'],function( require ) {\r\n  'use strict';\r\n\r\n  var Image = require( 'SCENERY/nodes/Image' );\r\n  var VBox = require( 'SCENERY/nodes/VBox' );\r\n  var DOM = require( 'SCENERY/nodes/DOM' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var HBox = require( 'SCENERY/nodes/HBox' );\r\n  var Scene = require( 'SCENERY/Scene' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n\r\n  // Generated using chipper.FontAwesomeToScenery\r\n  var icons = {\r\n    fullscreen: \"M1283 995l-355 -355l355 -355l144 144q29 31 70 14q39 -17 39 -59v-448q0 -26 -19 -45t-45 -19h-448q-42 0 -59 40q-17 39 14 69l144 144l-355 355l-355 -355l144 -144q31 -30 14 -69q-17 -40 -59 -40h-448q-26 0 -45 19t-19 45v448q0 42 40 59q39 17 69 -14l144 -144 l355 355l-355 355l-144 -144q-19 -19 -45 -19q-12 0 -24 5q-40 17 -40 59v448q0 26 19 45t45 19h448q42 0 59 -40q17 -39 -14 -69l-144 -144l355 -355l355 355l-144 144q-31 30 -14 69q17 40 59 40h448q26 0 45 -19t19 -45v-448q0 -42 -39 -59q-13 -5 -25 -5q-26 0 -45 19z\",\r\n    reorder: \"M1536 192v-128q0 -26 -19 -45t-45 -19h-1408q-26 0 -45 19t-19 45v128q0 26 19 45t45 19h1408q26 0 45 -19t19 -45zM1536 704v-128q0 -26 -19 -45t-45 -19h-1408q-26 0 -45 19t-19 45v128q0 26 19 45t45 19h1408q26 0 45 -19t19 -45zM1536 1216v-128q0 -26 -19 -45 t-45 -19h-1408q-26 0 -45 19t-19 45v128q0 26 19 45t45 19h1408q26 0 45 -19t19 -45z\",\r\n    home: \"M1408 544v-480q0 -26 -19 -45t-45 -19h-384v384h-256v-384h-384q-26 0 -45 19t-19 45v480q0 1 0.5 3t0.5 3l575 474l575 -474q1 -2 1 -6zM1631 613l-62 -74q-8 -9 -21 -11h-3q-13 0 -21 7l-692 577l-692 -577q-12 -8 -24 -7q-13 2 -21 11l-62 74q-8 10 -7 23.5t11 21.5 l719 599q32 26 76 26t76 -26l244 -204v195q0 14 9 23t23 9h192q14 0 23 -9t9 -23v-408l219 -182q10 -8 11 -21.5t-7 -23.5z\",\r\n    volume_off: \"M768 1184v-1088q0 -26 -19 -45t-45 -19t-45 19l-333 333h-262q-26 0 -45 19t-19 45v384q0 26 19 45t45 19h262l333 333q19 19 45 19t45 -19t19 -45z\",\r\n    volume_up: \"M768 1184v-1088q0 -26 -19 -45t-45 -19t-45 19l-333 333h-262q-26 0 -45 19t-19 45v384q0 26 19 45t45 19h262l333 333q19 19 45 19t45 -19t19 -45zM1152 640q0 -76 -42.5 -141.5t-112.5 -93.5q-10 -5 -25 -5q-26 0 -45 18.5t-19 45.5q0 21 12 35.5t29 25t34 23t29 35.5 t12 57t-12 57t-29 35.5t-34 23t-29 25t-12 35.5q0 27 19 45.5t45 18.5q15 0 25 -5q70 -27 112.5 -93t42.5 -142zM1408 640q0 -153 -85 -282.5t-225 -188.5q-13 -5 -25 -5q-27 0 -46 19t-19 45q0 39 39 59q56 29 76 44q74 54 115.5 135.5t41.5 173.5t-41.5 173.5 t-115.5 135.5q-20 15 -76 44q-39 20 -39 59q0 26 19 45t45 19q13 0 26 -5q140 -59 225 -188.5t85 -282.5zM1664 640q0 -230 -127 -422.5t-338 -283.5q-13 -5 -26 -5q-26 0 -45 19t-19 45q0 36 39 59q7 4 22.5 10.5t22.5 10.5q46 25 82 51q123 91 192 227t69 289t-69 289 t-192 227q-36 26 -82 51q-7 4 -22.5 10.5t-22.5 10.5q-39 23 -39 59q0 26 19 45t45 19q13 0 26 -5q211 -91 338 -283.5t127 -422.5z\",\r\n    check: \"M1408 606v-318q0 -119 -84.5 -203.5t-203.5 -84.5h-832q-119 0 -203.5 84.5t-84.5 203.5v832q0 119 84.5 203.5t203.5 84.5h832q63 0 117 -25q15 -7 18 -23q3 -17 -9 -29l-49 -49q-10 -10 -23 -10q-3 0 -9 2q-23 6 -45 6h-832q-66 0 -113 -47t-47 -113v-832 q0 -66 47 -113t113 -47h832q66 0 113 47t47 113v254q0 13 9 22l64 64q10 10 23 10q6 0 12 -3q20 -8 20 -29zM1639 1095l-814 -814q-24 -24 -57 -24t-57 24l-430 430q-24 24 -24 57t24 57l110 110q24 24 57 24t57 -24l263 -263l647 647q24 24 57 24t57 -24l110 -110 q24 -24 24 -57t-24 -57z\",\r\n    check_empty: \"M1120 1280h-832q-66 0 -113 -47t-47 -113v-832q0 -66 47 -113t113 -47h832q66 0 113 47t47 113v832q0 66 -47 113t-113 47zM1408 1120v-832q0 -119 -84.5 -203.5t-203.5 -84.5h-832q-119 0 -203.5 84.5t-84.5 203.5v832q0 119 84.5 203.5t203.5 84.5h832 q119 0 203.5 -84.5t84.5 -203.5z\"\r\n  };\r\n\r\n  function FontAwesomeNode( iconName, options ) {\r\n\r\n    // default values\r\n    options = _.extend( {\r\n      fill: \"#000\",\r\n      //Font awesome nodes are expensive to pick (and have a lot of holes in them which you may wish to pick anyways, such as the door of the 'home' icon, so don't pick by default\r\n      pickable: false\r\n    }, options );\r\n\r\n    // add internal values required by supertype constructor\r\n    options = _.extend( options, {\r\n      shape: new Shape( icons[iconName] ),\r\n      matrix: new Matrix3( 0.025, 0, 0, 0, -0.025, 0, 0, 0, 1 )\r\n    } );\r\n\r\n    Path.call( this, options );\r\n  }\r\n\r\n  inherit( Path, FontAwesomeNode );\r\n\r\n  return FontAwesomeNode;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Control panel around a content node.\r\n * Dynamically adjusts its size to fit its contents.\r\n *\r\n * @author Sam Reid\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'SUN/Panel',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle'],function( require ) {\r\n  'use strict';\r\n\r\n  // imports\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n\r\n  /**\r\n   * @param {Node} content\r\n   * @param {object} options\r\n   * @constructor\r\n   */\r\n  function Panel( content, options ) {\r\n\r\n    var thisNode = this;\r\n\r\n    // default options\r\n    options = _.extend( {\r\n      fill: 'white',\r\n      stroke: 'black',\r\n      lineWidth: 1, // width of the background border\r\n      xMargin: 5,\r\n      yMargin: 5,\r\n      cornerRadius: 10, // radius of the rounded corners on the background\r\n      resize: true // dynamically resize when content bounds change?\r\n    }, options );\r\n\r\n    Node.call( thisNode );\r\n\r\n    // correct size will be set by updateBackground\r\n    var background = new Rectangle( 0, 0, 1, 1, {stroke: options.stroke, lineWidth: options.lineWidth, fill: options.fill} );\r\n    this.addChild( background );\r\n    this.addChild( content );\r\n\r\n    // Adjust the background size to match the content.\r\n    var updateBackground = function() {\r\n      background.setRect( 0, 0, content.width + ( 2 * options.xMargin ), content.height + ( 2 * options.yMargin ), options.cornerRadius, options.cornerRadius );\r\n      content.centerX = background.centerX;\r\n      content.centerY = background.centerY;\r\n    };\r\n    if ( options.resize ) {\r\n      content.addEventListener( 'bounds', function() {\r\n        updateBackground();\r\n      } );\r\n    }\r\n    updateBackground();\r\n\r\n    // Apply options after the layout is done, so that options that use the bounds will work properly.\r\n    this.mutate( options );\r\n  }\r\n\r\n  inherit( Node, Panel );\r\n\r\n  return Panel;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n//TODO this should extend sun.Button\r\n//TODO this should handle wiring up the callback that goes to the home screen, currently done in NavigationBar\r\n/**\r\n * The Home button that appears in the navigation bar.\r\n */\r\ndefine( 'SCENERY_PHET/HomeButton',['require','SUN/FontAwesomeNode','PHET_CORE/inherit','SCENERY/nodes/Node','KITE/Shape'],function( require ) {\r\n  'use strict';\r\n\r\n  // imports\r\n  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Shape = require( 'KITE/Shape' );\r\n\r\n  function HomeButton( options ) {\r\n\r\n    options = _.extend( { cursor: 'pointer' }, options );\r\n\r\n    Node.call( this, options );\r\n\r\n    var icon = new FontAwesomeNode( 'home', { fill: '#fff', scale: 0.75 } );\r\n    this.mouseArea = this.touchArea = Shape.rectangle( icon.bounds.minX, icon.bounds.minY, icon.bounds.width, icon.bounds.height );\r\n    this.addChild( icon );\r\n  }\r\n\r\n  inherit( Node, HomeButton );\r\n\r\n  return HomeButton;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n//TODO #4: add support for consecutive line breaks, eg 'Hello\\n\\nWorld'\r\n//TODO #4: add support for leading (vertical space) between lines\r\n/**\r\n * MultiLine plain text, with alignment.\r\n * The line break character is '\\n'.\r\n * Specify alignment via the 'align' option.\r\n * Text node options can be specified to style the text.\r\n * <p>\r\n * Example: new MultiLineText( 'Hello\\nWorld', { align: 'left', font: new PhetFont(20), fill: 'red' } );\r\n *\r\n * @author Sam Reid\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'SCENERY_PHET/MultiLineText',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Text','SCENERY/nodes/VBox'],function( require ) {\r\n  'use strict';\r\n\r\n  // imports\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var VBox = require( 'SCENERY/nodes/VBox' );\r\n\r\n  function MultiLineText( text, options ) {\r\n\r\n    var thisNode = this;\r\n\r\n    thisNode._options = options = _.extend( {\r\n      align: 'center' // 'center', 'left' or 'right' (as supported by VBox)\r\n    }, options );\r\n\r\n    Node.call( thisNode );\r\n    thisNode.text = text;\r\n    thisNode.mutate( _.omit( options, 'align' ) ); // mutate after removing options that are specific to this subtype\r\n  }\r\n\r\n  inherit( Node, MultiLineText, {\r\n      get text() {\r\n        return this._text;\r\n      },\r\n      set text( string ) {\r\n        var thisNode = this;\r\n        thisNode._text = string;\r\n        thisNode.children = [ new VBox( {\r\n          children: string.split( '\\n' ).map( function( line ) {\r\n            return new Text( line, _.omit( thisNode._options, 'align' ) );\r\n          } ),\r\n          align: thisNode._options.align\r\n        } )];\r\n      }\r\n    }\r\n  );\r\n\r\n  return MultiLineText;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Shape handling\r\n *\r\n * Shapes are internally made up of Subpaths, which contain a series of segments, and are optionally closed.\r\n * Familiarity with how Canvas handles subpaths is helpful for understanding this code.\r\n *\r\n * Canvas spec: http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html\r\n * SVG spec: http://www.w3.org/TR/SVG/expanded-toc.html\r\n *           http://www.w3.org/TR/SVG/paths.html#PathData (for paths)\r\n * Notes for elliptical arcs: http://www.w3.org/TR/SVG/implnote.html#PathElementImplementationNotes\r\n * Notes for painting strokes: https://svgwg.org/svg2-draft/painting.html\r\n *\r\n * TODO: add nonzero / evenodd support when browsers support it\r\n * TODO: docs\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'KITE/shape',['require','ASSERT/assert','ASSERT/assert','KITE/kite','DOT/Vector2','DOT/Bounds2','DOT/Ray2','DOT/Matrix3','DOT/Transform3','DOT/Util','DOT/Util','KITE/util/Subpath','KITE/../parser/svgPath','KITE/util/LineStyles','KITE/segments/Arc','KITE/segments/Cubic','KITE/segments/EllipticalArc','KITE/segments/Line','KITE/segments/Quadratic'],function( require ) {\r\n  'use strict';\r\n  \r\n  var assert = require( 'ASSERT/assert' )( 'kite' );\r\n  var assertExtra = require( 'ASSERT/assert' )( 'kite.extra', true );\r\n  \r\n  var kite = require( 'KITE/kite' );\r\n  \r\n  // TODO: clean up imports\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Ray2 = require( 'DOT/Ray2' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var Transform3 = require( 'DOT/Transform3' );\r\n  var toDegrees = require( 'DOT/Util' ).toDegrees;\r\n  var lineLineIntersection = require( 'DOT/Util' ).lineLineIntersection;\r\n  \r\n  var Subpath = require( 'KITE/util/Subpath' );\r\n  \r\n  var svgPath = require( 'KITE/../parser/svgPath' );\r\n  require( 'KITE/util/LineStyles' );\r\n  require( 'KITE/segments/Arc' );\r\n  require( 'KITE/segments/Cubic' );\r\n  require( 'KITE/segments/EllipticalArc' );\r\n  require( 'KITE/segments/Line' );\r\n  require( 'KITE/segments/Quadratic' );\r\n  \r\n  // for brevity\r\n  function p( x,y ) { return new Vector2( x, y ); }\r\n  function v( x,y ) { return new Vector2( x, y ); } // TODO: use this version in general, it makes more sense and is easier to type\r\n  \r\n  // a normalized vector for non-zero winding checks\r\n  // var weirdDir = p( Math.PI, 22 / 7 );\r\n  \r\n  // all arguments optional, they are for the copy() method. if used, ensure that 'bounds' is consistent with 'subpaths'\r\n  kite.Shape = function Shape( subpaths, bounds ) {\r\n    // lower-level piecewise mathematical description using segments, also individually immutable\r\n    this.subpaths = ( typeof subpaths === 'object' ) ? subpaths : [];\r\n    assert && assert( this.subpaths.length === 0 || this.subpaths[0].constructor.name !== 'Array' );\r\n    \r\n    // computed bounds for all pieces added so far\r\n    this.bounds = bounds || Bounds2.NOTHING;\r\n    \r\n    var that = this;\r\n    if ( subpaths && typeof subpaths !== 'object' ) {\r\n      assert && assert( typeof subpaths === 'string', 'if subpaths is not an object, it must be a string' )\r\n      ;\r\n      // parse the SVG path\r\n      _.each( svgPath.parse( subpaths ), function( item ) {\r\n        assert && assert( Shape.prototype[item.cmd] !== undefined, 'method ' + item.cmd + ' from parsed SVG does not exist' );\r\n        that[item.cmd].apply( that, item.args );\r\n      } );\r\n    }\r\n  };\r\n  var Shape = kite.Shape;\r\n  \r\n  Shape.prototype = {\r\n    constructor: Shape,\r\n    \r\n    moveTo: function( x, y ) { return this.moveToPoint( v( x, y ) ); },\r\n    moveToRelative: function( x, y ) { return this.moveToPointRelative( v( x, y ) ); },\r\n    moveToPointRelative: function( point ) { return this.moveToPoint( this.getRelativePoint().plus( point ) ); },\r\n    moveToPoint: function( point ) {\r\n      return this.addSubpath( new kite.Subpath().addPoint( point ) );\r\n    },\r\n    \r\n    lineTo: function( x, y ) { return this.lineToPoint( v( x, y ) ); },\r\n    lineToRelative: function( x, y ) { return this.lineToPointRelative( v( x, y ) ); },\r\n    lineToPointRelative: function( point ) { return this.lineToPoint( this.getRelativePoint().plus( point ) ); },\r\n    lineToPoint: function( point ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-lineto\r\n      if ( this.hasSubpaths() ) {\r\n        var start = this.getLastSubpath().getLastPoint();\r\n        var end = point;\r\n      var line = new kite.Segment.Line( start, end );\r\n        this.getLastSubpath().addPoint( end );\r\n        if ( !line.invalid ) {\r\n          this.getLastSubpath().addSegment( line );\r\n          this.bounds = this.bounds.withPoint( start ).withPoint( end );\r\n          assert && assert( !isNaN( this.bounds.getX() ) );\r\n        }\r\n      } else {\r\n        this.ensure( point );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    horizontalLineTo: function( x ) { return this.lineTo( x, this.getRelativePoint().y ); },\r\n    horizontalLineToRelative: function( x ) { return this.lineToRelative( x, 0 ); },\r\n    \r\n    verticalLineTo: function( y ) { return this.lineTo( this.getRelativePoint().x, y ); },\r\n    verticalLineToRelative: function( y ) { return this.lineToRelative( 0, y ); },\r\n    \r\n    quadraticCurveTo: function( cpx, cpy, x, y ) { return this.quadraticCurveToPoint( v( cpx, cpy ), v( x, y ) ); },\r\n    quadraticCurveToRelative: function( cpx, cpy, x, y ) { return this.quadraticCurveToPointRelative( v( cpx, cpy ), v( x, y ) ); },\r\n    quadraticCurveToPointRelative: function( controlPoint, point ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.quadraticCurveToPoint( relativePoint.plus( controlPoint ), relativePoint.plus( point ) );\r\n    },\r\n    // TODO: consider a rename to put 'smooth' farther back?\r\n    smoothQuadraticCurveTo: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ) ); },\r\n    smoothQuadraticCurveToRelative: function( x, y ) { return this.quadraticCurveToPoint( this.getSmoothQuadraticControlPoint(), v( x, y ).plus( this.getRelativePoint() ) ); },\r\n    quadraticCurveToPoint: function( controlPoint, point ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\r\n      this.ensure( controlPoint );\r\n      var start = this.getLastSubpath().getLastPoint();\r\n      var quadratic = new kite.Segment.Quadratic( start, controlPoint, point );\r\n      this.getLastSubpath().addPoint( point );\r\n      if ( !quadratic.invalid ) {\r\n        this.getLastSubpath().addSegment( quadratic );\r\n        this.bounds = this.bounds.union( quadratic.bounds );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    cubicCurveTo: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },\r\n    cubicCurveToRelative: function( cp1x, cp1y, cp2x, cp2y, x, y ) { return this.cubicCurveToPointRelative( v( cp1x, cp1y ), v( cp2x, cp2y ), v( x, y ) ); },\r\n    cubicCurveToPointRelative: function( control1, control2, point ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.cubicCurveToPoint( relativePoint.plus( control1 ), relativePoint.plus( control2 ), relativePoint.plus( point ) );\r\n    },\r\n    smoothCubicCurveTo: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ), v( x, y ) ); },\r\n    smoothCubicCurveToRelative: function( cp2x, cp2y, x, y ) { return this.cubicCurveToPoint( this.getSmoothCubicControlPoint(), v( cp2x, cp2y ).plus( this.getRelativePoint() ), v( x, y ).plus( this.getRelativePoint() ) ); },\r\n    cubicCurveToPoint: function( control1, control2, point ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-quadraticcurveto\r\n      this.ensure( control1 );\r\n      var start = this.getLastSubpath().getLastPoint();\r\n      var cubic = new kite.Segment.Cubic( start, control1, control2, point );\r\n      \r\n      if ( !cubic.invalid ) {\r\n        // if there is a cusp, we add the two (split) quadratic segments instead so that stroking treats the 'join' between them with the proper lineJoin\r\n        if ( cubic.hasCusp() ) {\r\n          this.getLastSubpath().addSegment( cubic.startQuadratic );\r\n          this.getLastSubpath().addSegment( cubic.endQuadratic );\r\n        } else {\r\n          this.getLastSubpath().addSegment( cubic );\r\n        }\r\n        \r\n        this.bounds = this.bounds.union( cubic.bounds );\r\n      }\r\n      this.getLastSubpath().addPoint( point );\r\n      \r\n      return this;\r\n    },\r\n    \r\n    arc: function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) { return this.arcPoint( v( centerX, centerY ), radius, startAngle, endAngle, anticlockwise ); },\r\n    arcPoint: function( center, radius, startAngle, endAngle, anticlockwise ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc\r\n      \r\n      var arc = new kite.Segment.Arc( center, radius, startAngle, endAngle, anticlockwise );\r\n      \r\n      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas\r\n      var startPoint = arc.start;\r\n      var endPoint = arc.end;\r\n      \r\n      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them\r\n      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {\r\n        this.getLastSubpath().addSegment( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );\r\n      }\r\n      \r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new kite.Subpath() );\r\n      }\r\n      \r\n      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)\r\n      this.getLastSubpath().addPoint( startPoint );\r\n      this.getLastSubpath().addPoint( endPoint );\r\n      \r\n      if ( !arc.invalid ) {\r\n        this.getLastSubpath().addSegment( arc );\r\n        \r\n        // and update the bounds\r\n        this.bounds = this.bounds.union( arc.bounds );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    ellipticalArc: function( centerX, centerY, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) { return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ); },\r\n    ellipticalArcPoint: function( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise ) {\r\n      // see http://www.whatwg.org/specs/web-apps/current-work/multipage/the-canvas-element.html#dom-context-2d-arc\r\n      \r\n      var ellipticalArc = new kite.Segment.EllipticalArc( center, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise );\r\n      \r\n      // we are assuming that the normal conditions were already met (or exceptioned out) so that these actually work with canvas\r\n      var startPoint = ellipticalArc.start;\r\n      var endPoint = ellipticalArc.end;\r\n      \r\n      // if there is already a point on the subpath, and it is different than our starting point, draw a line between them\r\n      if ( this.hasSubpaths() && this.getLastSubpath().getLength() > 0 && !startPoint.equals( this.getLastSubpath().getLastPoint(), 0 ) ) {\r\n        this.getLastSubpath().addSegment( new kite.Segment.Line( this.getLastSubpath().getLastPoint(), startPoint ) );\r\n      }\r\n      \r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new kite.Subpath() );\r\n      }\r\n      \r\n      // technically the Canvas spec says to add the start point, so we do this even though it is probably completely unnecessary (there is no conditional)\r\n      this.getLastSubpath().addPoint( startPoint );\r\n      this.getLastSubpath().addPoint( endPoint );\r\n      \r\n      if ( !ellipticalArc.invalid ) {\r\n        this.getLastSubpath().addSegment( ellipticalArc );\r\n        \r\n        // and update the bounds\r\n        this.bounds = this.bounds.union( ellipticalArc.bounds );\r\n      }\r\n      \r\n      return this;\r\n    },\r\n    \r\n    close: function() {\r\n      if ( this.hasSubpaths() ) {\r\n        var previousPath = this.getLastSubpath();\r\n        var nextPath = new kite.Subpath();\r\n        \r\n        previousPath.close();\r\n        this.addSubpath( nextPath );\r\n        nextPath.addPoint( previousPath.getFirstPoint() );\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    // matches SVG's elliptical arc from http://www.w3.org/TR/SVG/paths.html\r\n    ellipticalArcToRelative: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {\r\n      var relativePoint = this.getRelativePoint();\r\n      return this.ellipticalArcTo( radiusX, radiusY, rotation, largeArc, sweep, x + relativePoint.x, y + relativePoint.y );\r\n    },\r\n    ellipticalArcTo: function( radiusX, radiusY, rotation, largeArc, sweep, x, y ) {\r\n      throw new Error( 'ellipticalArcTo unimplemented' );\r\n    },\r\n    \r\n    /*\r\n     * Draws a circle using the arc() call with the following parameters:\r\n     * circle( center, radius ) // center is a Vector2\r\n     * circle( centerX, centerY, radius )\r\n     */\r\n    circle: function( centerX, centerY, radius ) {\r\n      if ( typeof centerX === 'object' ) {\r\n        // circle( center, radius )\r\n        var center = centerX;\r\n        radius = centerY;\r\n        return this.arcPoint( center, radius, 0, Math.PI * 2, false );\r\n      } else {\r\n        // circle( centerX, centerY, radius )\r\n        return this.arcPoint( p( centerX, centerY ), radius, 0, Math.PI * 2, false );\r\n      }\r\n    },\r\n    \r\n    /*\r\n     * Draws an ellipse using the ellipticalArc() call with the following parameters:\r\n     * ellipse( center, radiusX, radiusY, rotation ) // center is a Vector2\r\n     * ellipse( centerX, centerY, radiusX, radiusY, rotation )\r\n     */\r\n    ellipse: function( centerX, centerY, radiusX, radiusY, rotation ) {\r\n      // TODO: separate into ellipse() and ellipsePoint()?\r\n      // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling\r\n      if ( typeof centerX === 'object' ) {\r\n        // ellipse( center, radiusX, radiusY, rotation )\r\n        var center = centerX;\r\n        rotation = radiusY;\r\n        radiusY = radiusX;\r\n        radiusX = centerY;\r\n        return this.ellipticalArcPoint( center, radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );\r\n      } else {\r\n        // ellipse( centerX, centerY, radiusX, radiusY, rotation )\r\n        return this.ellipticalArcPoint( v( centerX, centerY ), radiusX, radiusY, rotation || 0, 0, Math.PI * 2, false );\r\n      }\r\n    },\r\n    \r\n    rect: function( x, y, width, height ) {\r\n      var subpath = new kite.Subpath();\r\n      this.addSubpath( subpath );\r\n      subpath.addPoint( v( x, y ) );\r\n      subpath.addPoint( v( x + width, y ) );\r\n      subpath.addPoint( v( x + width, y + height ) );\r\n      subpath.addPoint( v( x, y + height ) );\r\n      subpath.addSegment( new kite.Segment.Line( subpath.points[0], subpath.points[1] ) );\r\n      subpath.addSegment( new kite.Segment.Line( subpath.points[1], subpath.points[2] ) );\r\n      subpath.addSegment( new kite.Segment.Line( subpath.points[2], subpath.points[3] ) );\r\n      subpath.close();\r\n      this.addSubpath( new kite.Subpath() );\r\n      this.getLastSubpath().addPoint( v( x, y ) );\r\n      this.bounds = this.bounds.withCoordinates( x, y ).withCoordinates( x + width, y + height );\r\n      assert && assert( !isNaN( this.bounds.getX() ) );\r\n      \r\n      return this;\r\n    },\r\n\r\n    //Create a round rectangle. All arguments are number.\r\n    roundRect: function( x, y, width, height, arcw, arch ) {\r\n      var lowX = x + arcw;\r\n      var highX = x + width - arcw;\r\n      var lowY = y + arch;\r\n      var highY = y + height - arch;\r\n      // if ( true ) {\r\n      if ( arcw === arch ) {\r\n        // we can use circular arcs, which have well defined stroked offsets\r\n        this.arc( highX, lowY, arcw, -Math.PI / 2, 0, false )\r\n            .arc( highX, highY, arcw, 0, Math.PI / 2, false )\r\n            .arc( lowX, highY, arcw, Math.PI / 2, Math.PI, false )\r\n            .arc( lowX, lowY, arcw, Math.PI, Math.PI * 3 / 2, false )\r\n            .close();\r\n      } else {\r\n        // we have to resort to elliptical arcs\r\n        this.ellipticalArc( highX, lowY, arcw, arch, 0, -Math.PI / 2, 0, false )\r\n            .ellipticalArc( highX, highY, arcw, arch, 0, 0, Math.PI / 2, false )\r\n            .ellipticalArc( lowX, highY, arcw, arch, 0, Math.PI / 2, Math.PI, false )\r\n            .ellipticalArc( lowX, lowY, arcw, arch, 0, Math.PI, Math.PI * 3 / 2, false )\r\n            .close();\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    copy: function() {\r\n      // copy each individual subpath, so future modifications to either Shape doesn't affect the other one\r\n      return new Shape( _.map( this.subpaths, function( subpath ) { return subpath.copy(); } ), this.bounds );\r\n    },\r\n    \r\n    // write out this shape's path to a canvas 2d context. does NOT include the beginPath()!\r\n    writeToContext: function( context ) {\r\n      _.each( this.subpaths, function( subpath ) {\r\n        subpath.writeToContext( context );\r\n      } );\r\n    },\r\n    \r\n    // returns something like \"M150 0 L75 200 L225 200 Z\" for a triangle\r\n    getSVGPath: function() {\r\n      var subpathStrings = [];\r\n      _.each( this.subpaths, function( subpath ) {\r\n        if( subpath.isDrawable() ) {\r\n          // since the commands after this are relative to the previous 'point', we need to specify a move to the initial point\r\n          var startPoint = subpath.getFirstSegment().start;\r\n          assert && assert( startPoint.equals( subpath.getFirstPoint(), 0.00001 ) ); // sanity check\r\n          var string = 'M ' + startPoint.x + ' ' + startPoint.y + ' ';\r\n          \r\n          string += _.map( subpath.segments, function( segment ) { return segment.getSVGPathFragment(); } ).join( ' ' );\r\n          \r\n          if ( subpath.isClosed() ) {\r\n            string += ' Z';\r\n          }\r\n          subpathStrings.push( string );\r\n        }\r\n      } );\r\n      return subpathStrings.join( ' ' );\r\n    },\r\n    \r\n    // return a new Shape that is transformed by the associated matrix\r\n    transformed: function( matrix ) {\r\n      var subpaths = _.map( this.subpaths, function( subpath ) { return subpath.transformed( matrix ); } );\r\n      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.computeBounds() ); }, Bounds2.NOTHING );\r\n      return new Shape( subpaths, bounds );\r\n    },\r\n    \r\n    // returns the bounds. if lineStyles exists, include the stroke in the bounds\r\n    // TODO: consider renaming to getBounds()?\r\n    computeBounds: function( lineStyles ) {\r\n      if ( lineStyles ) {\r\n        return this.bounds.union( this.getStrokedShape( lineStyles ).bounds );\r\n      } else {\r\n        return this.bounds;\r\n      }\r\n    },\r\n    \r\n    containsPoint: function( point ) {\r\n      // we pick a ray, and determine the winding number over that ray. if the number of segments crossing it CCW == number of segments crossing it CW, then the point is contained in the shape\r\n      var ray = new Ray2( point, p( 1, 0 ) );\r\n      \r\n      return this.windingIntersection( ray ) !== 0;\r\n    },\r\n    \r\n    intersection: function( ray ) {\r\n      var hits = [];\r\n      _.each( this.subpaths, function( subpath ) {\r\n        if ( subpath.isDrawable() ) {\r\n          _.each( subpath.segments, function( segment ) {\r\n            _.each( segment.intersection( ray ), function( hit ) {\r\n              hits.push( hit );\r\n            } );\r\n          } );\r\n          \r\n          if ( subpath.hasClosingSegment() ) {\r\n            _.each( subpath.getClosingSegment().intersection( ray ), function( hit ) {\r\n              hits.push( hit );\r\n            } );\r\n          }\r\n        }\r\n      } );\r\n      return _.sortBy( hits, function( hit ) { return hit.distance; } );\r\n    },\r\n    \r\n    windingIntersection: function( ray ) {\r\n      var wind = 0;\r\n      \r\n      _.each( this.subpaths, function( subpath ) {\r\n        if ( subpath.isDrawable() ) {\r\n          _.each( subpath.segments, function( segment ) {\r\n            wind += segment.windingIntersection( ray );\r\n          } );\r\n          \r\n          // handle the implicit closing line segment\r\n          if ( subpath.hasClosingSegment() ) {\r\n            wind += subpath.getClosingSegment().windingIntersection( ray );\r\n          }\r\n        }\r\n      } );\r\n      \r\n      return wind;\r\n    },\r\n    \r\n    intersectsBounds: function( bounds ) {\r\n      var intersects = false;\r\n      // TODO: break-out-early optimizations\r\n      _.each( this.subpaths, function( subpath ) {\r\n        if ( subpath.isDrawable() ) {\r\n          _.each( subpath.segments, function( segment ) {\r\n            intersects = intersects && segment.intersectsBounds( bounds );\r\n          } );\r\n          \r\n          // handle the implicit closing line segment\r\n          if ( subpath.hasClosingSegment() ) {\r\n            intersects = intersects && subpath.getClosingSegment().intersectsBounds( bounds );\r\n          }\r\n        }\r\n      } );\r\n      return intersects;\r\n    },\r\n    \r\n    // returns a new Shape that is an outline of the stroked path of this current Shape. currently not intended to be nested (doesn't do intersection computations yet)\r\n    // TODO: rename stroked( lineStyles )\r\n    getStrokedShape: function( lineStyles ) {\r\n      var subpaths = _.flatten( _.map( this.subpaths, function( subpath ) { return subpath.stroked( lineStyles ); } ) );\r\n      var bounds = _.reduce( subpaths, function( bounds, subpath ) { return bounds.union( subpath.computeBounds() ); }, Bounds2.NOTHING );\r\n      return new Shape( subpaths, bounds );\r\n    },\r\n    \r\n    toString: function() {\r\n      // TODO: consider a more verbose but safer way?\r\n      return 'new kite.Shape( \\'' + this.getSVGPath() + '\\' )';\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * Internal subpath computations\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    ensure: function( point ) {\r\n      if ( !this.hasSubpaths() ) {\r\n        this.addSubpath( new Subpath() );\r\n        this.getLastSubpath().addPoint( point );\r\n      }\r\n    },\r\n    \r\n    addSubpath: function( subpath ) {\r\n      this.subpaths.push( subpath );\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    hasSubpaths: function() {\r\n      return this.subpaths.length > 0;\r\n    },\r\n    \r\n    getLastSubpath: function() {\r\n      return _.last( this.subpaths );\r\n    },\r\n    \r\n    // gets the last point in the last subpath, or null if it doesn't exist\r\n    getLastPoint: function() {\r\n      return this.hasSubpaths() ? this.getLastSubpath().getLastPoint() : null;\r\n    },\r\n    \r\n    getLastSegment: function() {\r\n      if ( !this.hasSubpaths() ) { return null; }\r\n      \r\n      var subpath = this.getLastSubpath();\r\n      if ( !subpath.isDrawable() ) { return null; }\r\n      \r\n      return subpath.getLastSegment();\r\n    },\r\n    \r\n    // returns the point to be used for smooth quadratic segments\r\n    getSmoothQuadraticControlPoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n      \r\n      var segment = this.getLastSegment();\r\n      if ( !segment || !( segment instanceof kite.Segment.Quadratic ) ) { return lastPoint; }\r\n      \r\n      return lastPoint.plus( lastPoint.minus( segment.control ) );\r\n    },\r\n    \r\n    // returns the point to be used for smooth cubic segments\r\n    getSmoothCubicControlPoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n      \r\n      var segment = this.getLastSegment();\r\n      if ( !segment || !( segment instanceof kite.Segment.Cubic ) ) { return lastPoint; }\r\n      \r\n      return lastPoint.plus( lastPoint.minus( segment.control2 ) );\r\n    },\r\n    \r\n    getRelativePoint: function() {\r\n      var lastPoint = this.getLastPoint();\r\n      return lastPoint ? lastPoint : Vector2.ZERO;\r\n    }\r\n  };\r\n  \r\n  /*---------------------------------------------------------------------------*\r\n  * Shape shortcuts\r\n  *----------------------------------------------------------------------------*/\r\n  \r\n  Shape.rectangle = function( x, y, width, height ) {\r\n    return new Shape().rect( x, y, width, height );\r\n  };\r\n  Shape.rect = Shape.rectangle;\r\n\r\n  //Create a round rectangle. All arguments are number.\r\n  //Rounding is currently using quadraticCurveTo.  Please note, future versions may use arcTo\r\n  //TODO: rewrite with arcTo?\r\n  Shape.roundRect = function( x, y, width, height, arcw, arch ) {\r\n    return new Shape().roundRect( x, y, width, height, arcw, arch );\r\n  };\r\n  Shape.roundRectangle = Shape.roundRect;\r\n  \r\n  Shape.bounds = function( bounds ) {\r\n    return new Shape().rect( bounds.minX, bounds.minY, bounds.maxX - bounds.minX, bounds.maxY - bounds.minY );\r\n  };\r\n\r\n  //Create a line segment, using either (x1,y1,x2,y2) or ({x1,y1},{x2,y2}) arguments\r\n  Shape.lineSegment = function( a, b, c, d ) {\r\n    // TODO: add type assertions?\r\n    if ( typeof a === 'number' ) {\r\n      return new Shape().moveTo( a, b ).lineTo( c, d );\r\n    }\r\n    else {\r\n      return new Shape().moveToPoint( a ).lineToPoint( b );\r\n    }\r\n  };\r\n  \r\n  Shape.regularPolygon = function( sides, radius ) {\r\n    var shape = new Shape();\r\n    _.each( _.range( sides ), function( k ) {\r\n      var point = Vector2.createPolar( radius, 2 * Math.PI * k / sides );\r\n      ( k === 0 ) ? shape.moveToPoint( point ) : shape.lineToPoint( point );\r\n    } );\r\n    return shape.close();\r\n  };\r\n  \r\n  // supports both circle( centerX, centerY, radius ), circle( center, radius ), and circle( radius ) with the center default to 0,0\r\n  Shape.circle = function( centerX, centerY, radius ) {\r\n    if ( centerY === undefined ) {\r\n      // circle( radius ), center = 0,0\r\n      return new Shape().circle( 0, 0, centerX );\r\n    }\r\n    return new Shape().circle( centerX, centerY, radius ).close();\r\n  };\r\n  \r\n  /*\r\n   * Supports ellipse( centerX, centerY, radiusX, radiusY ), ellipse( center, radiusX, radiusY ), and ellipse( radiusX, radiusY )\r\n   * with the center default to 0,0 and rotation of 0\r\n   */\r\n  Shape.ellipse = function( centerX, centerY, radiusX, radiusY ) {\r\n    // TODO: Ellipse/EllipticalArc has a mess of parameters. Consider parameter object, or double-check parameter handling\r\n    if ( radiusX === undefined ) {\r\n      // ellipse( radiusX, radiusY ), center = 0,0\r\n      return new Shape().ellipse( 0, 0, centerX, centerY );\r\n    }\r\n    return new Shape().ellipse( centerX, centerY, radiusX, radiusY ).close();\r\n  };\r\n  \r\n  // supports both arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) and arc( center, radius, startAngle, endAngle, anticlockwise )\r\n  Shape.arc = function( centerX, centerY, radius, startAngle, endAngle, anticlockwise ) {\r\n    return new Shape().arc( centerX, centerY, radius, startAngle, endAngle, anticlockwise );\r\n  };\r\n  \r\n  return Shape;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * The view portion of a Screen.\r\n * Specifies the layout strategy.\r\n * TODO: should extend this to be compatible with the Sim.js framework.\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/ScreenView',['require','SCENERY/nodes/Node','PHET_CORE/inherit','DOT/Bounds2','SCENERY/nodes/Path','KITE/shape'],function( require ) {\r\n  'use strict';\r\n\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Shape = require( 'KITE/shape' );\r\n\r\n  function ScreenView( options ) {\r\n    Node.call( this, options );\r\n\r\n    // Show the layoutBounds\r\n    if ( window.phetcommon.getQueryParameter( 'dev' ) ) {\r\n      this.addChild( new Path( { shape: Shape.bounds( this.layoutBounds ), stroke: 'red', lineWidth: 3, pickable: false } ) );\r\n    }\r\n  }\r\n\r\n  inherit( Node, ScreenView, {\r\n\r\n    //Default to width and height for iPad2, iPad3, iPad4 running Safari with default tabs and decorations\r\n    //Simulations can change this to provide their own sizes or aspect ratios\r\n    //TODO: the code that uses these bounds needs to account for the minX and minY values if they are overriden in subclasses\r\n    layoutBounds: new Bounds2( 0, 0, 768, 504 ),\r\n\r\n    //Get the scale to use for laying out the sim components and the navigation bar, so its size will track with the sim size\r\n    getLayoutScale: function( width, height ) {\r\n      return Math.min( width / this.layoutBounds.width, height / this.layoutBounds.height );\r\n    },\r\n\r\n    //Default layout function uses the layoutWidth and layoutHeight to scale the content (based on whichever is more limiting: width or height)\r\n    //and centers the content in the screen vertically and horizontally\r\n    //This function can be replaced by subclasses that wish to perform their own custom layout.\r\n    layout: function( width, height ) {\r\n      this.resetTransform();\r\n\r\n      var scale = this.getLayoutScale( width, height );\r\n      this.setScaleMagnitude( scale );\r\n\r\n      //center vertically\r\n      if ( scale === width / this.layoutBounds.width ) {\r\n        this.translate( 0, (height - this.layoutBounds.height * scale) / 2 / scale );\r\n      }\r\n\r\n      //center horizontally\r\n      else if ( scale === height / this.layoutBounds.height ) {\r\n        this.translate( (width - this.layoutBounds.width * scale) / 2 / scale, 0 );\r\n      }\r\n    }\r\n  } );\r\n\r\n  return ScreenView;\r\n} );","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * HTML Text, with the same interface as Text\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/nodes/HTMLText',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Text'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var scenery = require( 'SCENERY/scenery' );\r\n  var Text = require( 'SCENERY/nodes/Text' ); // inherits from Text\r\n  \r\n  scenery.HTMLText = function HTMLText( text, options ) {\r\n    // internal flag for Text\r\n    this._isHTML = true;\r\n    \r\n    Text.call( this, text, options );\r\n  };\r\n  var HTMLText = scenery.HTMLText;\r\n  \r\n  inherit( Text, HTMLText, {} );\r\n  \r\n  return HTMLText;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Encapsulation of the font used for PhET simulations.\r\n * Provides PhET-specific defaults, and guarantees a fallback for font family.\r\n * <p>\r\n * Sample use:\r\n * new PhetFont( { family: 'Futura', size: 24, weight: 'bold' } )\r\n * new PhetFont( 24 )\r\n *\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'SCENERY_PHET/PhetFont',['require','ASSERT/assert','SCENERY/util/Font','PHET_CORE/inherit'],function( require ) {\r\n  'use strict';\r\n\r\n  // imports\r\n  var assert = require( 'ASSERT/assert' )( 'scenery-phet' );\r\n  var Font = require( 'SCENERY/util/Font' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n\r\n  /**\r\n   * @param {Number|*} options if number this is the font size, otherwise same options as scenery.Font\r\n   * @constructor\r\n   */\r\n  function PhetFont( options ) {\r\n\r\n    // convenience constructor: new PhetFont( size )\r\n    if ( typeof options === 'number' ) {\r\n      options = { size: options };\r\n    }\r\n\r\n    // PhET defaults\r\n    options = _.extend( {\r\n      family: 'Arial'\r\n    }, options );\r\n\r\n    // Guarantee a fallback family\r\n    assert && assert( options.family );\r\n    options.family = options.family + ', sans-serif';\r\n\r\n    Font.call( this, options );\r\n  }\r\n\r\n  return inherit( Font, PhetFont );\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Shows the about dialog.\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/AboutDialog',['require','SCENERY/nodes/Node','SCENERY/nodes/VBox','SCENERY/nodes/Rectangle','SCENERY/nodes/Text','PHET_CORE/inherit','SCENERY_PHET/MultiLineText','JOIST/ScreenView','SUN/Panel','SCENERY/nodes/HTMLText','SCENERY_PHET/PhetFont'],function( require ) {\r\n  'use strict';\r\n\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var VBox = require( 'SCENERY/nodes/VBox' );\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var MultiLineText = require( 'SCENERY_PHET/MultiLineText' );\r\n  var ScreenView = require( 'JOIST/ScreenView' );\r\n  var Panel = require( 'SUN/Panel' );\r\n  var HTMLText = require( 'SCENERY/nodes/HTMLText' );\r\n  var PhetFont = require( 'SCENERY_PHET/PhetFont' );\r\n\r\n  // constants\r\n  var SOFTWARE_AGREEMENT_URL = 'http://phet.colorado.edu/about/software-agreement_v7.htm';\r\n\r\n  /**\r\n   * @param {Sim} sim\r\n   * @constructor\r\n   */\r\n  function AboutDialog( sim ) {\r\n    var aboutDialog = this;\r\n\r\n    //Use view, to help center and scale content\r\n    ScreenView.call( this, {renderer: 'svg'} );\r\n\r\n    var softwareAgreementLink = new HTMLText( '<a href=\"#\" onclick=\"return false;\">Software Agreement</a>', {\r\n      font: new PhetFont( 14 ),\r\n      renderer: 'dom',\r\n      interactive: true // don't prevent default on the events\r\n    } ); //TODO i18n\r\n    softwareAgreementLink.addInputListener( {\r\n      up: function( evt ) {\r\n        evt.handle(); // don't close the dialog\r\n      },\r\n      upImmediate: function( evt ) {\r\n        var aboutDialogWindow = window.open( SOFTWARE_AGREEMENT_URL, '_blank' );\r\n        aboutDialogWindow.focus();\r\n      }\r\n    } );\r\n    \r\n    var debugLink = 'http://phet.colorado.edu/files/troubleshooting/' +\r\n                    '?sim=' + encodeURIComponent( sim.name ) +\r\n                    '&version=' + encodeURIComponent( sim.version ) +\r\n                    '&url=' + encodeURIComponent( window.location.href );\r\n    var debuggingInfoLink = new HTMLText( '<a href=\"' + debugLink + '\" onclick=\"return false;\">Debugging Information (for bug reports)</a>', {\r\n      font: new PhetFont( 12 ),\r\n      renderer: 'dom',\r\n      interactive: true // don't prevent default on the events\r\n    } ); //TODO i18n\r\n    debuggingInfoLink.addInputListener( {\r\n      up: function( evt ) {\r\n        evt.handle(); // don't close the dialog\r\n      },\r\n      upImmediate: function( evt ) {\r\n        var debugWindow = window.open( debugLink, '_blank' );\r\n        debugWindow.focus();\r\n      }\r\n    } );\r\n\r\n    var content = new VBox( { align: 'left', spacing: 5, children: [\r\n      new Text( 'PhET Interactive Simulations', { font: new PhetFont( 16 ) } ),\r\n      new Text( 'Copyright © 2004-2013 University of Colorado Boulder', { font: new PhetFont( 12 ) } ),\r\n      new Text( ' ', { font: new PhetFont( 28 ) } ),\r\n      new Text( sim.name, { font: new PhetFont( 28 ) } ),\r\n      new Text( 'version ' + sim.version, { font: new PhetFont( 20 ) } ),\r\n      new Text( ' ' ),\r\n      new MultiLineText( sim.credits, { align: 'left', font: new PhetFont( 12 ) } ),\r\n      new Text( ' ' ),\r\n      new MultiLineText( sim.thanks, { align: 'left', font: new PhetFont( 12 ) } ),\r\n      new Text( ' ' ),\r\n      softwareAgreementLink,\r\n      new Text( ' ' ),\r\n      debuggingInfoLink\r\n    ]} );\r\n\r\n    //Show a gray overlay that will help focus on the about dialog, and prevent clicks on the sim while the dialog is up\r\n    this.addChild( new Panel( content, {centerX: this.layoutBounds.centerX, centerY: this.layoutBounds.centerY, xMargin: 20, yMargin: 20 } ) );\r\n\r\n    function resize() {\r\n      aboutDialog.layout( $( window ).width(), $( window ).height() );\r\n    }\r\n\r\n    //Fit to the window and render the initial scene\r\n    $( window ).resize( resize );\r\n    resize();\r\n  }\r\n\r\n  inherit( ScreenView, AboutDialog );\r\n\r\n  return AboutDialog;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Basic down/up pointer handling for a Node, so that it's easy to handle buttons\r\n *\r\n * TODO: test hand handle down, go off screen, up. How to handle that properly?\r\n * TODO: tests\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/input/DownUpListener',['require','SCENERY/scenery','SCENERY/util/Trail'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  require( 'SCENERY/util/Trail' );\r\n  \r\n  /*\r\n   * The 'trail' parameter passed to down/upInside/upOutside will end with the node to which this DownUpListener has been added.\r\n   *\r\n   * Allowed options: {\r\n   *    mouseButton: 0  // The mouse button to use: left: 0, middle: 1, right: 2, see https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent\r\n   *    down: null      // down( event, trail ) is called when the pointer is pressed down on this node\r\n   *                    // (and another pointer is not already down on it).\r\n   *    up: null        // up( event, trail ) is called after 'down', regardless of the pointer's current location.\r\n   *                    // Additionally, it is called AFTER upInside or upOutside, whichever is relevant\r\n   *    upInside: null  // upInside( event, trail ) is called after 'down', when the pointer is released inside\r\n   *                    // this node (it or a descendant is the top pickable node under the pointer)\r\n   *    upOutside: null // upOutside( event, trail ) is called after 'down', when the pointer is released outside\r\n   *                    // this node (it or a descendant is the not top pickable node under the pointer, even if the\r\n   *                    // same instance is still directly under the pointer)\r\n   * }\r\n   */\r\n  scenery.DownUpListener = function DownUpListener( options ) {\r\n    var handler = this;\r\n    \r\n    this.options = _.extend( {\r\n      mouseButton: 0 // allow a different mouse button \r\n    }, options );\r\n    this.isDown = false;   // public, whether this listener is down\r\n    this.downCurrentTarget = null; // 'up' is handled via a pointer lister, which will have null currentTarget, so save the 'down' currentTarget\r\n    this.downTrail = null;\r\n    this.pointer = null;\r\n    \r\n    // this listener gets added to the pointer on a 'down'\r\n    this.downListener = {\r\n      // mouse/touch up\r\n      up: function( event ) {\r\n        sceneryAssert && sceneryAssert( event.pointer === handler.pointer );\r\n        if ( !event.pointer.isMouse || event.domEvent.button === handler.options.mouseButton ) {\r\n          handler.buttonUp( event );\r\n        }\r\n      },\r\n      \r\n      // touch cancel\r\n      cancel: function( event ) {\r\n        sceneryAssert && sceneryAssert( event.pointer === handler.pointer );\r\n        handler.buttonUp( event );\r\n      }\r\n    };\r\n  };\r\n  var DownUpListener = scenery.DownUpListener;\r\n  \r\n  DownUpListener.prototype = {\r\n    constructor: DownUpListener,\r\n    \r\n    buttonDown: function( event ) {\r\n      // already down from another pointer, don't do anything\r\n      if ( this.isDown ) { return; }\r\n      \r\n      // ignore other mouse buttons\r\n      if ( event.pointer.isMouse && event.domEvent.button !== this.options.mouseButton ) { return; }\r\n      \r\n      // add our listener so we catch the up wherever we are\r\n      event.pointer.addInputListener( this.downListener );\r\n      \r\n      this.isDown = true;\r\n      this.downCurrentTarget = event.currentTarget;\r\n      this.downTrail = event.trail.subtrailTo( event.currentTarget, false );\r\n      this.pointer = event.pointer;\r\n      \r\n      if ( this.options.down ) {\r\n        this.options.down( event, this.downTrail );\r\n      }\r\n    },\r\n    \r\n    buttonUp: function( event ) {\r\n      this.isDown = false;\r\n      this.pointer.removeInputListener( this.downListener );\r\n\r\n      var currentTargetSave = event.currentTarget;\r\n      event.currentTarget = this.downCurrentTarget; // up is handled by a pointer listener, so currentTarget would be null.\r\n      if ( this.options.upInside || this.options.upOutside ) {\r\n        var scene = this.downTrail.rootNode();\r\n        var trailUnderPointer = event.trail;\r\n        \r\n        // TODO: consider changing this so that it just does a hit check and ignores anything in front?\r\n        var isInside = trailUnderPointer.isExtensionOf( this.downTrail, true );\r\n        \r\n        if ( isInside && this.options.upInside ) {\r\n          this.options.upInside( event, this.downTrail );\r\n        } else if ( !isInside && this.options.upOutside ) {\r\n          this.options.upOutside( event, this.downTrail );\r\n        }\r\n      }\r\n      if ( this.options.up ) {\r\n        this.options.up( event, this.downTrail );\r\n      }\r\n      event.currentTarget = currentTargetSave; // be polite to other listeners, restore currentTarget\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * events called from the node input listener\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // mouse/touch down on this node\r\n    down: function( event ) {\r\n      this.buttonDown( event );\r\n    }\r\n  };\r\n  \r\n  return DownUpListener;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Basic button handling.\r\n *\r\n * Uses 4 states:\r\n * up: mouse not over, not pressed\r\n * over: mouse over, not pressed\r\n * down: mouse over, pressed\r\n * out: mouse not over, pressed\r\n *\r\n * TODO: offscreen handling\r\n * TODO: fix enter/exit edge cases for moving nodes or add/remove child, and when touches are created\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/input/ButtonListener',['require','SCENERY/scenery','SCENERY/util/Trail','PHET_CORE/inherit','SCENERY/input/DownUpListener'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  require( 'SCENERY/util/Trail' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  \r\n  var DownUpListener = require( 'SCENERY/input/DownUpListener' );\r\n  \r\n  /**\r\n   * Options for the ButtonListener:\r\n   *\r\n   * mouseButton: 0\r\n   * fireOnDown: false // default is to fire on 'up' after 'down', but passing fireOnDown: true will fire on 'down' instead\r\n   * up: null          // Called on an 'up' state change, as up( event, oldState )\r\n   * over: null        // Called on an 'over' state change, as over( event, oldState )\r\n   * down: null        // Called on an 'down' state change, as down( event, oldState )\r\n   * out: null         // Called on an 'out' state change, as out( event, oldState )\r\n   * fire: null        // Called on a state change to/from 'down' (depending on fireOnDown), as fire( event ). Called after the triggering up/over/down event.\r\n   */\r\n  scenery.ButtonListener = function ButtonListener( options ) {\r\n\r\n    this.buttonState = 'up'; // public: 'up', 'over', 'down' or 'out'\r\n    \r\n    this._overCount = 0; // how many pointers are over us (track a count, so we can handle multiple pointers gracefully)\r\n    \r\n    this._buttonOptions = options; // store the options object so we can call the callbacks\r\n    \r\n    var buttonListener = this;\r\n    DownUpListener.call( this, {\r\n\r\n      mouseButton: options.mouseButton || 0, // forward the mouse button, default to 0 (LMB)\r\n      \r\n      down: function( event, trail ) {\r\n        buttonListener.setButtonState( event, 'down' );\r\n      },\r\n      \r\n      up: function( event, trail ) {\r\n        buttonListener.setButtonState( event, buttonListener._overCount > 0 ? 'over' : 'up' );\r\n      }\r\n    } );\r\n  };\r\n\r\n  var ButtonListener = scenery.ButtonListener;\r\n  \r\n  inherit( DownUpListener, ButtonListener, {\r\n\r\n    setButtonState: function( event, state ) {\r\n      if ( state !== this.buttonState ) {\r\n        var oldState = this.buttonState;\r\n        \r\n        this.buttonState = state;\r\n        \r\n        if ( this._buttonOptions[state] ) {\r\n          this._buttonOptions[state]( event, oldState );\r\n        }\r\n        \r\n        if ( this._buttonOptions.fire &&\r\n             this._overCount > 0 &&\r\n             ( this._buttonOptions.fireOnDown ? ( state === 'down' ) : ( oldState === 'down' ) ) ) {\r\n          this._buttonOptions.fire( event );\r\n        }\r\n      }\r\n    },\r\n    \r\n    enter: function( event ) {\r\n      this._overCount++;\r\n      if ( this._overCount === 1 ) {\r\n        this.setButtonState( event, this.isDown ? 'down' : 'over' );\r\n      }\r\n    },\r\n\r\n    exit: function( event ) {\r\n      sceneryAssert && sceneryAssert( this._overCount > 0, 'Exit events not matched by an enter' );\r\n      this._overCount--;\r\n      if ( this._overCount === 0 ) {\r\n        this.setButtonState( event, this.isDown ? 'out' : 'up' );\r\n      }\r\n    }\r\n  } );\r\n\r\n  //TODO delete this after work is completed on sun.Button and scenery.ButtonListener\r\n  ButtonListener.TEST_LISTENER = new ButtonListener( {\r\n\r\n    up: function( event, oldState ) {\r\n      console.log( \"ButtonListener.up oldState=\" + oldState );\r\n    },\r\n\r\n    over: function( event, oldState ) {\r\n      console.log( \"ButtonListener.over oldState=\" + oldState );\r\n    },\r\n\r\n    down: function( event, oldState ) {\r\n      console.log( \"ButtonListener.down oldState=\" + oldState );\r\n    },\r\n\r\n    out: function( event, oldState ) {\r\n      console.log( \"ButtonListener.out oldState=\" + oldState );\r\n    },\r\n\r\n    fire: function( event ) {\r\n      console.log( \"ButtonListener.fire\" );\r\n    }\r\n  } );\r\n\r\n  return ButtonListener;\r\n} );\r\n\r\n\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * A node which always fills the entire screen, no matter what the transform is.\r\n * Used for showing an overlay on the screen e.g., when a popup dialog is shown.\r\n * This can fade the background to focus on the dialog/popup as well as intercept mouse events for dismissing the dialog/popup.\r\n * Note: This is currently implemented using large numbers, it should be rewritten to work in any coordinate frame, possibly using kite.Shape.plane()\r\n * TODO: Implement using infinite geometry\r\n *\r\n * @author Sam Reid\r\n */\r\n\r\ndefine( 'SCENERY/nodes/Plane',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Rectangle','KITE/Shape'],function( require ) {\r\n  'use strict';\r\n\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var scenery = require( 'SCENERY/scenery' );\r\n\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n  var Shape = require( 'KITE/Shape' );\r\n\r\n  /**\r\n   * @param options Any options for the plane, typically fill/opacity (many others such as scale, translation, rotation should have no effect)\r\n   * @constructor\r\n   */\r\n  scenery.Plane = function Plane( options ) {\r\n    Rectangle.call( this, -2000, -2000, 6000, 6000, options );\r\n  };\r\n  var Plane = scenery.Plane;\r\n\r\n  return inherit( Rectangle, Plane );\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\ndefine( 'AXON/axon',['require'],function( require ) {\r\n  'use strict';\r\n\r\n  var axon = {};\r\n\r\n  // will be filled in by other modules\r\n  return axon;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/*\r\n * PhET Simulations can be recorded and played back.  This serves a few purposes:\r\n * 1. During research interviews (with student consent) the session can be recorded for future playback.\r\n * 2. (possibly) Saving a simulation state for loading later.  Could also be done by exporting state, but that would require extra work.\r\n * 3. Live broadcasting from one screen to another (sim sharing), for remote learning or projecting a student's sim onto the room's projector\r\n * 4. Standardize performance testing of a realistic scenario.  For instance, you can record a session and play it back automatically to test scenery performance.\r\n * 5. Teacher can record sessions for future evaluation.\r\n * 6. Sim event data collection: when recording logging information for how the user interacts with the UI, also record the model state so it doesn't\r\n *    have to be recreated in a Finite State Machine afterwards.\r\n *\r\n * For recording within a simulation (like Moving Man), another structure would be required.  This is focused on recording the entire session, not\r\n * just some of the events within a particular model.\r\n *\r\n * This implementation just records all state changes, but we could alternatively investigate tracking\r\n * method calls (like command pattern) or trigger calls, etc.\r\n *\r\n * History: Adapted from phetsims/fort/wiretap.js\r\n * \r\n * @author Sam Reid (PhET Interactive Simulations)\r\n * \r\n * TODO: Factor out class into one file, and singleton instance to another file\r\n * TODO: Remove extra cruft leftover from wiretap.js\r\n */\r\ndefine( 'AXON/log',['require','AXON/axon'],function( require ) {\r\n  'use strict';\r\n\r\n  var axon = require( 'AXON/axon' );\r\n//  var Vector2 = require( 'DOT/Vector2' );\r\n\r\n  var cid = 0;\r\n\r\n  function Log() {\r\n    var log = this;\r\n\r\n    //Enable it if 'log' query parameter specified.  TODO: Switch to has.js?\r\n    //Leave it public so it can be toggled on/off in code\r\n    this.enabled = window && window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'log' );\r\n\r\n    //Keep track of all the models, hashed by cid\r\n    //TODO: these could be arrays, we don't need cid on the objects, right?\r\n    this.properties = [];\r\n    this.collections = [];\r\n    this.propertySets = [];\r\n\r\n    //Keep track of the changes to all the models\r\n    this.entries = [];\r\n\r\n    //Replacer and reviver for the JSON.  Could be moved to the models themselves to decouple/simplify.\r\n    this.replacer = function( key, value ) {\r\n\r\n      //Properties must be stored separately, in case of nested properties (such as Forces and Motion: Basics)\r\n      //TODO: A better way of detecting a property?  Perhaps checking the constructor?\r\n      if ( value && value.cid ) {\r\n        return {jsonClass: 'Property', cid: value.cid};\r\n      }\r\n\r\n      if ( value && value.constructor.name === 'Vector2' ) {\r\n        return {x: value.x, y: value.y, jsonClass: 'Vector2'};\r\n      }\r\n      return value;\r\n    };\r\n\r\n    this.reviver = function( key, value ) {\r\n      if ( value && value.jsonClass && value.jsonClass === 'Property' ) {\r\n        return log.properties[value.cid];\r\n      }\r\n      if ( value && value.jsonClass && value.jsonClass === 'Vector2' ) {\r\n//        return new Vector2( value.x, value.y );\r\n        return {x: value.x, y: value.y };//TODO: pass in a factory that creates Vector2's ?  Log probably shouldn't depend on all of the code that needs reviving\r\n      }\r\n      return value;\r\n    };\r\n  }\r\n\r\n  Log.prototype = {\r\n\r\n    /**\r\n     * When a property is created, register it for recording and playback.\r\n     * Store its unique cid so that it can be discovered later during playback.\r\n     * @param property\r\n     */\r\n    registerProperty: function( property ) {\r\n      if ( !this.enabled ) {\r\n        return;\r\n      }\r\n      var index = this.properties.length;\r\n      var log = this;\r\n      this.properties.push( property );\r\n\r\n      //Don't record initial values for the properties, just the changes.\r\n      property.lazyLink( function( value ) {\r\n        var entry = {time: Date.now(), type: 'property', index: index, action: 'change', value: JSON.stringify( value, log.replacer )};\r\n//        console.log( entry );\r\n        log.entries.push( entry );\r\n      } );\r\n    },\r\n    clear: function() {\r\n      this.properties = [];\r\n      this.collection = [];\r\n      this.propertySets = [];\r\n    },\r\n    stepUntil: function( logArray, playbackTime, logIndex ) {\r\n      var log = this;\r\n      while ( logIndex < logArray.length ) {\r\n        //find any events that passed in this time frame\r\n        //Note, may handle multiple events before calling scene.updateScene()\r\n        var time = logArray[logIndex].time;\r\n        if ( time <= playbackTime ) {\r\n          var entry = logArray[logIndex];\r\n          var cid = entry.cid;\r\n\r\n          //if it is a change, then set the value\r\n          if ( entry.action === 'change' ) {\r\n            if ( entry.value ) {\r\n              log.properties[cid].value = JSON.parse( entry.value, log.reviver );\r\n            }\r\n            else {\r\n              console.log( 'missing value for index: ', logIndex, entry );\r\n            }\r\n          }\r\n          else if ( entry.action === 'trigger' ) {\r\n            log.properties[cid].trigger( entry.event );\r\n          }\r\n          else if ( entry.action === 'add' ) {\r\n            log.collections[entry.collectionCid].add( log.properties[entry.cid] );\r\n          }\r\n          else if ( entry.action === 'remove' ) {\r\n            log.collections[entry.collectionCid].remove( log.properties[entry.cid] );\r\n          }\r\n          else if ( entry.action === 'reset' ) {\r\n            log.collections[entry.collectionCid].reset();\r\n          }\r\n          else if ( entry.action === 'sort' ) {\r\n            log.collections[entry.collectionCid].sort();\r\n          }\r\n\r\n          logIndex++;\r\n        }\r\n        else {\r\n          break;\r\n        }\r\n      }\r\n      return logIndex;\r\n    }\r\n  };\r\n\r\n  axon.log = axon.log || new Log();\r\n\r\n  return axon.log;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * The 'PhET' menu.\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/PhetMenu',['require','SCENERY/nodes/Node','KITE/Shape','SCENERY/nodes/Path','SCENERY/nodes/Text','PHET_CORE/inherit','JOIST/AboutDialog','SCENERY/nodes/Rectangle','SCENERY/input/ButtonListener','SCENERY/nodes/Plane','AXON/log','SCENERY_PHET/PhetFont'],function( require ) {\r\n  'use strict';\r\n\r\n  // imports\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var AboutDialog = require( 'JOIST/AboutDialog' );\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n  var ButtonListener = require( 'SCENERY/input/ButtonListener' );\r\n  var Plane = require( 'SCENERY/nodes/Plane' );\r\n  var log = require( 'AXON/log' );\r\n  var PhetFont = require( 'SCENERY_PHET/PhetFont' );\r\n\r\n  // constants\r\n  var FONT_SIZE = '18px';\r\n  var HIGHLIGHT_COLOR = '#a6d2f4';\r\n\r\n  // Creates a menu item that highlights and fires.\r\n  var createMenuItem = function( text, width, height, callback, immediateCallback ) {\r\n\r\n    var X_MARGIN = 5;\r\n    var Y_MARGIN = 3;\r\n    var CORNER_RADIUS = 5;\r\n\r\n    var textNode = new Text( text, { font: new PhetFont( FONT_SIZE ) } );\r\n    var highlight = new Rectangle( 0, 0, width + X_MARGIN + X_MARGIN, height + Y_MARGIN + Y_MARGIN, CORNER_RADIUS, CORNER_RADIUS );\r\n\r\n    var menuItem = new Node( { cursor: 'pointer' } );\r\n    menuItem.addChild( highlight );\r\n    menuItem.addChild( textNode );\r\n\r\n    textNode.left = highlight.left + X_MARGIN; // text is left aligned\r\n    textNode.centerY = highlight.centerY;\r\n\r\n    menuItem.addInputListener( {\r\n      enter: function() { highlight.fill = HIGHLIGHT_COLOR; },\r\n      exit: function() { highlight.fill = null; },\r\n      upImmediate: function() { immediateCallback && immediateCallback(); }\r\n    } );\r\n    menuItem.addInputListener( new ButtonListener( {fire: callback } ) );\r\n\r\n    return menuItem;\r\n  };\r\n\r\n  // Creates a comic-book style bubble.\r\n  var createBubble = function( width, height ) {\r\n\r\n    var rectangle = new Rectangle( 0, 0, width, height, 8, 8, {fill: 'white', lineWidth: 1, stroke: 'black'} );\r\n\r\n    var tail = new Shape();\r\n    tail.moveTo( width - 20, height - 2 );\r\n    tail.lineToRelative( 0, 20 );\r\n    tail.lineToRelative( -20, -20 );\r\n    tail.close();\r\n\r\n    var tailOutline = new Shape();\r\n    tailOutline.moveTo( width - 20, height );\r\n    tailOutline.lineToRelative( 0, 20 - 2 );\r\n    tailOutline.lineToRelative( -18, -18 );\r\n\r\n    var bubble = new Node();\r\n    bubble.addChild( rectangle );\r\n    bubble.addChild( new Path( {shape: tail, fill: 'white'} ) );\r\n    bubble.addChild( new Path( {shape: tailOutline, stroke: 'black', lineWidth: 1} ) );\r\n\r\n    return bubble;\r\n  };\r\n\r\n  //TODO: The popup menu should scale with the size of the screen\r\n  function PhetMenu( sim, options ) {\r\n\r\n    options = _.extend( {renderer: 'svg'}, options );\r\n\r\n    var thisMenu = this;\r\n    Node.call( thisMenu );\r\n\r\n    /*\r\n     * Description of the items in the menu. Each descriptor has these properties:\r\n     * {String} text - the item's text\r\n     * {Boolean} present - whether the item should be added to the menu\r\n     * {Function} callback - called when the item fires\r\n     */\r\n    var itemDescriptors = [\r\n      {\r\n        text: 'PhET website',\r\n        present: true,\r\n        callback: function() {\r\n        },\r\n        immediateCallback: function() {\r\n          var phetWindow = window.open( 'http://phet.colorado.edu', '_blank' );\r\n          phetWindow.focus();\r\n        } },\r\n      {\r\n        text: 'Output Log',\r\n        present: log.enabled ? true : false, // because double-negation (!!) coercion doesn't look as cool?\r\n        callback: function() {\r\n          console.log( JSON.stringify( log.entries ) );\r\n        }},\r\n      {\r\n        text: 'Output Input Events Log',\r\n        present: !!sim.options.recordInputEventLog,\r\n        callback: function() {\r\n          // prints the recorded input event log to the console\r\n          console.log( sim.getRecordedInputEventLogString() );\r\n        }},\r\n      {\r\n        text: 'Submit Input Events Log',\r\n        present: !!sim.options.recordInputEventLog,\r\n        callback: function() {\r\n          // submits a recorded event log to the same-origin server (run scenery/tests/event-logs/server/server.js with Node, from the same directory)\r\n          sim.submitEventLog();\r\n        }},\r\n      {\r\n        text: 'Mail Input Events Log',\r\n        present: !!sim.options.recordInputEventLog,\r\n        callback: function() {\r\n        },\r\n        immediateCallback: function() {\r\n          // mailto: link including the body to email\r\n          sim.mailEventLog();\r\n        }},\r\n      {\r\n        text: 'About...',\r\n        present: true,\r\n        callback: function() {\r\n          var aboutDialog = new AboutDialog( sim );\r\n          var plane = new Plane( {fill: 'black', opacity: 0.3} );\r\n          sim.addChild( plane );\r\n          sim.addChild( aboutDialog );\r\n          var aboutDialogListener = {up: function() {\r\n            aboutDialog.removeInputListener( aboutDialogListener );\r\n            plane.addInputListener( aboutDialogListener );\r\n            aboutDialog.detach();\r\n            plane.detach();\r\n          }};\r\n          aboutDialog.addInputListener( aboutDialogListener );\r\n          plane.addInputListener( aboutDialogListener );\r\n        }}\r\n    ];\r\n\r\n    // Menu items have uniform size, so compute the max text dimensions.\r\n    var keepItemDescriptors = _.filter( itemDescriptors, function( itemDescriptor ) {return itemDescriptor.present;} );\r\n    var textNodes = _.map( keepItemDescriptors, function( item ) {return new Text( item.text, {font: new PhetFont( FONT_SIZE )} );} );\r\n    var maxTextWidth = _.max( textNodes,function( node ) {return node.width;} ).width;\r\n    var maxTextHeight = _.max( textNodes,function( node ) {return node.height;} ).height;\r\n\r\n    // Create the menu items.\r\n    var items = _.map( keepItemDescriptors, function( itemDescriptor ) {\r\n      return createMenuItem( itemDescriptor.text, maxTextWidth, maxTextHeight, itemDescriptor.callback, itemDescriptor.immediateCallback );\r\n    } );\r\n\r\n    // Create a comic-book-style bubble.\r\n    var itemWidth = _.max( items,function( item ) {return item.width;} ).width;\r\n    var itemHeight = _.max( items,function( item ) {return item.height;} ).height;\r\n    var X_MARGIN = 5;\r\n    var Y_MARGIN = 5;\r\n    var bubbleWidth = itemWidth + X_MARGIN + X_MARGIN;\r\n    var bubbleHeight = itemHeight * items.length + Y_MARGIN + Y_MARGIN;\r\n    thisMenu.addChild( createBubble( bubbleWidth, bubbleHeight ) );\r\n\r\n    // Populate the bubble with menu items.\r\n    var y = Y_MARGIN;\r\n    _.each( items, function( item ) {\r\n      item.top = y;\r\n      item.left = X_MARGIN;\r\n      thisMenu.addChild( item );\r\n\r\n      //TODO separators should be specified in itemDescriptors\r\n      // Put a separator before the last item.\r\n      if ( item === items[items.length - 2] ) {\r\n        thisMenu.addChild( new Path( {shape: Shape.lineSegment( 8, y + itemHeight, bubbleWidth - 8, y + itemHeight ), stroke: 'gray', lineWidth: 1} ) );\r\n      }\r\n      y += itemHeight;\r\n    } );\r\n\r\n    thisMenu.mutate( options );\r\n  }\r\n\r\n  inherit( Node, PhetMenu );\r\n\r\n  return PhetMenu;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Encapsulates common color information and transformations.\r\n *\r\n * See http://www.w3.org/TR/css3-color/\r\n *\r\n * TODO: make a getHue, getSaturation, getLightness. we can then expose them via ES5!\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/Color',['require','SCENERY/scenery','DOT/Util','DOT/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var clamp = require( 'DOT/Util' ).clamp;\r\n  var linear = require( 'DOT/Util' ).linear;\r\n\r\n  // r,g,b integers 0-255, 'a' float 0-1\r\n  scenery.Color = function Color( r, g, b, a ) {\r\n    \r\n    // allow listeners to be notified on any changes. called with listener()\r\n    this.listeners = [];\r\n    \r\n    if ( typeof r === 'string' ) {\r\n      var str = r.replace( / /g, '' ).toLowerCase();\r\n      var success = false;\r\n      \r\n      // replace colors based on keywords\r\n      var keywordMatch = Color.colorKeywords[str];\r\n      if ( keywordMatch ) {\r\n        str = '#' + keywordMatch;\r\n      }\r\n      \r\n      // run through the available text formats\r\n      for ( var i = 0; i < Color.formatParsers.length; i++ ) {\r\n        var parser = Color.formatParsers[i];\r\n        \r\n        var matches = parser.regexp.exec( str );\r\n        if ( matches ) {\r\n          parser.apply( this, matches );\r\n          success = true;\r\n          break;\r\n        }\r\n      }\r\n      \r\n      if ( !success ) {\r\n        throw new Error( 'scenery.Color unable to parse color string: ' + r );\r\n      }\r\n    } else {\r\n      // alpha\r\n      var alpha = a === undefined ? 1 : a;\r\n\r\n      // bitwise handling if 3 elements aren't defined\r\n      if ( g === undefined || b === undefined ) {\r\n        this.setRGBA( ( r >> 16 ) && 0xFF,\r\n                      ( r >> 8 ) && 0xFF,\r\n                      ( r >> 0 ) && 0xFF,\r\n                      alpha );\r\n      }\r\n      else {\r\n        // otherwise, copy them over\r\n        this.setRGBA( r, g, b, alpha );\r\n      }\r\n    }\r\n  };\r\n  var Color = scenery.Color;\r\n  \r\n  // regex utilities\r\n  var rgbNumber = '(-?\\\\d{1,3}%?)'; // syntax allows negative integers and percentages\r\n  var aNumber = '(\\\\d+|\\\\d*\\\\.\\\\d+)'; // decimal point number. technically we allow for '255', even though this will be clamped to 1.\r\n  var rawNumber = '(\\\\d{1,3})'; // a 1-3 digit number\r\n  \r\n  // handles negative and percentage values\r\n  function parseRGBNumber( str ) {\r\n    var multiplier = 1;\r\n    \r\n    // if it's a percentage, strip it off and handle it that way\r\n    if ( str.charAt( str.length - 1 ) === '%' ) {\r\n      multiplier = 2.55;\r\n      str = str.slice( 0, str.length - 1 );\r\n    }\r\n    \r\n    return Math.round( parseInt( str, 10 ) * multiplier );\r\n  }\r\n  \r\n  Color.formatParsers = [\r\n    {\r\n      // 'transparent'\r\n      regexp: /^transparent$/,\r\n      apply: function( color, matches ) {\r\n        color.setRGBA( 0, 0, 0, 0 );\r\n      }\r\n    },{\r\n      // short hex form, a la '#fff'\r\n      regexp: /^#(\\w{1})(\\w{1})(\\w{1})$/,\r\n      apply: function( color, matches ) {\r\n        color.setRGBA( parseInt( matches[1] + matches[1], 16 ),\r\n                       parseInt( matches[2] + matches[2], 16 ),\r\n                       parseInt( matches[3] + matches[3], 16 ),\r\n                       1 );\r\n      }\r\n    },{\r\n      // long hex form, a la '#ffffff'\r\n      regexp: /^#(\\w{2})(\\w{2})(\\w{2})$/,\r\n      apply: function( color, matches ) {\r\n        color.setRGBA( parseInt( matches[1], 16 ),\r\n                       parseInt( matches[2], 16 ),\r\n                       parseInt( matches[3], 16 ),\r\n                       1 );\r\n      }\r\n    },{\r\n      // rgb(...)\r\n      regexp: new RegExp( '^rgb\\\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + '\\\\)$' ),\r\n      apply: function( color, matches ) {\r\n        color.setRGBA( parseRGBNumber( matches[1] ),\r\n                       parseRGBNumber( matches[2] ),\r\n                       parseRGBNumber( matches[3] ),\r\n                       1 );\r\n      }\r\n    },{\r\n      // rgba(...)\r\n      regexp: new RegExp( '^rgba\\\\(' + rgbNumber + ',' + rgbNumber + ',' + rgbNumber + ',' + aNumber + '\\\\)$' ),\r\n      apply: function( color, matches ) {\r\n        color.setRGBA( parseRGBNumber( matches[1] ),\r\n                       parseRGBNumber( matches[2] ),\r\n                       parseRGBNumber( matches[3] ),\r\n                       parseFloat( matches[4] ) );\r\n      }\r\n    },{\r\n      // hsl(...)\r\n      regexp: new RegExp( '^hsl\\\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%\\\\)$' ),\r\n      apply: function( color, matches ) {\r\n        color.setHSLA( parseInt( matches[1], 10 ),\r\n                       parseInt( matches[2], 10 ),\r\n                       parseInt( matches[3], 10 ),\r\n                       1 );\r\n      }\r\n    },{\r\n      // hsla(...)\r\n      regexp: new RegExp( '^hsla\\\\(' + rawNumber + ',' + rawNumber + '%,' + rawNumber + '%,' + aNumber + '\\\\)$' ),\r\n      apply: function( color, matches ) {\r\n        color.setHSLA( parseInt( matches[1], 10 ),\r\n                       parseInt( matches[2], 10 ),\r\n                       parseInt( matches[3], 10 ),\r\n                       parseFloat( matches[4] ) );\r\n      }\r\n    }\r\n  ];\r\n  \r\n  // see http://www.w3.org/TR/css3-color/\r\n  Color.hueToRGB = function( m1, m2, h ) {\r\n    if ( h < 0 ) {\r\n      h = h + 1;\r\n    }\r\n    if ( h > 1 ) {\r\n      h = h - 1;\r\n    }\r\n    if ( h * 6 < 1 ) {\r\n      return m1 + ( m2 - m1 ) * h * 6;\r\n    }\r\n    if ( h * 2 < 1 ) {\r\n      return m2;\r\n    }\r\n    if ( h * 3 < 2 ) {\r\n      return m1 + ( m2 - m1 ) * ( 2 / 3 - h ) * 6;\r\n    }\r\n    return m1;\r\n  };\r\n  \r\n  Color.prototype = {\r\n    constructor: Color,\r\n    \r\n    copy: function() {\r\n      return new Color( this.r, this.g, this.b, this.a );\r\n    },\r\n    \r\n    // red, integral 0-255\r\n    getRed: function() { return this.r; },\r\n    setRed: function( value ) { return this.setRGBA( value, this.g, this.b, this.a ); },\r\n    get red() { return this.getRed(); },\r\n    set red( value ) { return this.setRed( value ); },\r\n    \r\n    // green, integral 0-255\r\n    getGreen: function() { return this.g; },\r\n    setGreen: function( value ) { return this.setRGBA( this.r, value, this.b, this.a ); },\r\n    get green() { return this.getGreen(); },\r\n    set green( value ) { return this.setGreen( value ); },\r\n    \r\n    // blue, integral 0-255\r\n    getBlue: function() { return this.b; },\r\n    setBlue: function( value ) { return this.setRGBA( this.r, this.g, value, this.a ); },\r\n    get blue() { return this.getBlue(); },\r\n    set blue( value ) { return this.setBlue( value ); },\r\n    \r\n    // alpha, floating 0-1\r\n    getAlpha: function() { return this.a; },\r\n    setAlpha: function( value ) { return this.setRGBA( this.r, this.g, this.b, value ); },\r\n    get alpha() { return this.getAlpha(); },\r\n    set alpha( value ) { return this.setAlpha( value ); },\r\n    \r\n    // RGB integral between 0-255, alpha (float) between 0-1\r\n    setRGBA: function( red, green, blue, alpha ) {\r\n      this.r = Math.round( clamp( red, 0, 255 ) );\r\n      this.g = Math.round( clamp( green, 0, 255 ) );\r\n      this.b = Math.round( clamp( blue, 0, 255 ) );\r\n      this.a = clamp( alpha, 0, 1 );\r\n      \r\n      this.updateColor(); // update the cached value\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    computeCSS: function() {\r\n      if ( this.a === 1 ) {\r\n        return 'rgb(' + this.r + ',' + this.g + ',' + this.b + ')';\r\n      } else {\r\n        var alphaString = this.a === 0 || this.a === 1 ? this.a : this.a.toFixed( 20 ); // toFixed prevents scientific notation\r\n        return 'rgba(' + this.r + ',' + this.g + ',' + this.b + ',' + alphaString + ')';\r\n      }\r\n    },\r\n    \r\n    toCSS: function() {\r\n      // verify that the cached value is correct (in debugging builds only, defeats the point of caching otherwise)\r\n      sceneryAssert && sceneryAssert( this._css === this.computeCSS(), 'CSS cached value is ' + this._css + ', but the computed value appears to be ' + this.computeCSS() );\r\n      \r\n      return this._css;\r\n    },\r\n    \r\n    // called to update the interally cached CSS value\r\n    updateColor: function() {\r\n      sceneryAssert && sceneryAssert( !this.immutable, 'Cannot modify an immutable color' );\r\n      \r\n      var oldCSS = this._css;\r\n      this._css = this.computeCSS();\r\n      \r\n      // notify listeners if it changed\r\n      if ( oldCSS !== this._css && this.listeners.length ) {\r\n        var listeners = this.listeners.slice( 0 ); // defensive copy. consider removing if it's a performance bottleneck?\r\n        var length = listeners.length;\r\n        \r\n        for ( var i = 0; i < length; i++ ) {\r\n          listeners[i]();\r\n        }\r\n      }\r\n    },\r\n    \r\n    // allow setting this Color to be immutable when assertions are disabled. any change will throw an error\r\n    setImmutable: function() {\r\n      if ( sceneryAssert ) {\r\n        this.immutable = true;\r\n      }\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    // to what value a Canvas's context.fillStyle should be set\r\n    getCanvasStyle: function() {\r\n      return this.toCSS(); // should be inlined, leave like this for future maintainability\r\n    },\r\n    \r\n    // TODO: make a getHue, getSaturation, getLightness. we can then expose them via ES5!\r\n    setHSLA: function( hue, saturation, lightness, alpha ) {\r\n      hue = ( hue % 360 ) / 360;                    // integer modulo 360\r\n      saturation = clamp( saturation / 100, 0, 1 ); // percentage\r\n      lightness = clamp( lightness / 100, 0, 1 );   // percentage\r\n      \r\n      // see http://www.w3.org/TR/css3-color/\r\n      var m1, m2;\r\n      if ( lightness < 0.5 ) {\r\n        m2 = lightness * ( saturation + 1 );\r\n      } else {\r\n        m2 = lightness + saturation - lightness * saturation;\r\n      }\r\n      m1 = lightness * 2 - m2;\r\n      \r\n      this.r = Math.round( Color.hueToRGB( m1, m2, hue + 1/3 ) * 255 );\r\n      this.g = Math.round( Color.hueToRGB( m1, m2, hue ) * 255 );\r\n      this.b = Math.round( Color.hueToRGB( m1, m2, hue - 1/3 ) * 255 );\r\n      this.a = clamp( alpha, 0, 1 );\r\n      \r\n      this.updateColor(); // update the cached value\r\n      \r\n      return this; // allow chaining\r\n    },\r\n    \r\n    equals: function( color ) {\r\n      return this.r === color.r && this.g === color.g && this.b === color.b && this.a === color.a;\r\n    },\r\n    \r\n    withAlpha: function( alpha ) {\r\n      return new Color( this.r, this.g, this.b, alpha );\r\n    },\r\n    \r\n    brighterColor: function( factor ) {\r\n      if ( factor < 0 || factor > 1 ) {\r\n        throw new Error( \"factor must be between 0 and 1: \" + factor );\r\n      }\r\n      factor = ( factor === undefined ) ? 0.7 : factor;\r\n      var red   = Math.min( 255, Math.floor( this.r / factor ) );\r\n      var green = Math.min( 255, Math.floor( this.g / factor ) );\r\n      var blue  = Math.min( 255, Math.floor( this.b / factor ) );\r\n      return new Color( red, green, blue, this.a );\r\n    },\r\n    \r\n    darkerColor: function( factor ) {\r\n      if ( factor < 0 || factor > 1 ) {\r\n        throw new Error( \"factor must be between 0 and 1: \" + factor );\r\n      }\r\n      factor = ( factor === undefined ) ? 0.7 : factor;\r\n      var red   = Math.max( 0, Math.floor( factor * this.r ) );\r\n      var green = Math.max( 0, Math.floor( factor * this.g ) );\r\n      var blue  = Math.max( 0, Math.floor( factor * this.b ) );\r\n      return new Color( red, green, blue, this.a );\r\n    },\r\n    \r\n    /*---------------------------------------------------------------------------*\r\n    * listeners TODO: consider mixing in this behavior, it's common\r\n    *----------------------------------------------------------------------------*/\r\n    \r\n    // listener should be a callback expecting no arguments, listener() will be called when the color changes\r\n    addChangeListener: function( listener ) {\r\n      sceneryAssert && sceneryAssert( listener !== undefined && listener !== null, 'Verify that the listener exists' );\r\n      sceneryAssert && sceneryAssert( !_.contains( this.listeners, listener ) );\r\n      this.listeners.push( listener );\r\n    },\r\n    \r\n    removeChangeListener: function( listener ) {\r\n      sceneryAssert && sceneryAssert( _.contains( this.listeners, listener ) );\r\n      this.listeners.splice( _.indexOf( this.listeners, listener ), 1 );\r\n    }\r\n  };\r\n  \r\n  Color.basicColorKeywords = {\r\n    aqua:    '00ffff',\r\n    black:   '000000',\r\n    blue:    '0000ff',\r\n    fuchsia: 'ff00ff',\r\n    gray:    '808080',\r\n    green:   '008000',\r\n    lime:    '00ff00',\r\n    maroon:  '800000',\r\n    navy:    '000080',\r\n    olive:   '808000',\r\n    purple:  '800080',\r\n    red:     'ff0000',\r\n    silver:  'c0c0c0',\r\n    teal:    '008080',\r\n    white:   'ffffff',\r\n    yellow:  'ffff00'\r\n  };\r\n  \r\n  Color.colorKeywords = {\r\n    aliceblue:            'f0f8ff',\r\n    antiquewhite:         'faebd7',\r\n    aqua:                 '00ffff',\r\n    aquamarine:           '7fffd4',\r\n    azure:                'f0ffff',\r\n    beige:                'f5f5dc',\r\n    bisque:               'ffe4c4',\r\n    black:                '000000',\r\n    blanchedalmond:       'ffebcd',\r\n    blue:                 '0000ff',\r\n    blueviolet:           '8a2be2',\r\n    brown:                'a52a2a',\r\n    burlywood:            'deb887',\r\n    cadetblue:            '5f9ea0',\r\n    chartreuse:           '7fff00',\r\n    chocolate:            'd2691e',\r\n    coral:                'ff7f50',\r\n    cornflowerblue:       '6495ed',\r\n    cornsilk:             'fff8dc',\r\n    crimson:              'dc143c',\r\n    cyan:                 '00ffff',\r\n    darkblue:             '00008b',\r\n    darkcyan:             '008b8b',\r\n    darkgoldenrod:        'b8860b',\r\n    darkgray:             'a9a9a9',\r\n    darkgreen:            '006400',\r\n    darkkhaki:            'bdb76b',\r\n    darkmagenta:          '8b008b',\r\n    darkolivegreen:       '556b2f',\r\n    darkorange:           'ff8c00',\r\n    darkorchid:           '9932cc',\r\n    darkred:              '8b0000',\r\n    darksalmon:           'e9967a',\r\n    darkseagreen:         '8fbc8f',\r\n    darkslateblue:        '483d8b',\r\n    darkslategray:        '2f4f4f',\r\n    darkturquoise:        '00ced1',\r\n    darkviolet:           '9400d3',\r\n    deeppink:             'ff1493',\r\n    deepskyblue:          '00bfff',\r\n    dimgray:              '696969',\r\n    dodgerblue:           '1e90ff',\r\n    feldspar:             'd19275',\r\n    firebrick:            'b22222',\r\n    floralwhite:          'fffaf0',\r\n    forestgreen:          '228b22',\r\n    fuchsia:              'ff00ff',\r\n    gainsboro:            'dcdcdc',\r\n    ghostwhite:           'f8f8ff',\r\n    gold:                 'ffd700',\r\n    goldenrod:            'daa520',\r\n    gray:                 '808080',\r\n    green:                '008000',\r\n    greenyellow:          'adff2f',\r\n    honeydew:             'f0fff0',\r\n    hotpink:              'ff69b4',\r\n    indianred :           'cd5c5c',\r\n    indigo :              '4b0082',\r\n    ivory:                'fffff0',\r\n    khaki:                'f0e68c',\r\n    lavender:             'e6e6fa',\r\n    lavenderblush:        'fff0f5',\r\n    lawngreen:            '7cfc00',\r\n    lemonchiffon:         'fffacd',\r\n    lightblue:            'add8e6',\r\n    lightcoral:           'f08080',\r\n    lightcyan:            'e0ffff',\r\n    lightgoldenrodyellow: 'fafad2',\r\n    lightgrey:            'd3d3d3',\r\n    lightgreen:           '90ee90',\r\n    lightpink:            'ffb6c1',\r\n    lightsalmon:          'ffa07a',\r\n    lightseagreen:        '20b2aa',\r\n    lightskyblue:         '87cefa',\r\n    lightslateblue:       '8470ff',\r\n    lightslategray:       '778899',\r\n    lightsteelblue:       'b0c4de',\r\n    lightyellow:          'ffffe0',\r\n    lime:                 '00ff00',\r\n    limegreen:            '32cd32',\r\n    linen:                'faf0e6',\r\n    magenta:              'ff00ff',\r\n    maroon:               '800000',\r\n    mediumaquamarine:     '66cdaa',\r\n    mediumblue:           '0000cd',\r\n    mediumorchid:         'ba55d3',\r\n    mediumpurple:         '9370d8',\r\n    mediumseagreen:       '3cb371',\r\n    mediumslateblue:      '7b68ee',\r\n    mediumspringgreen:    '00fa9a',\r\n    mediumturquoise:      '48d1cc',\r\n    mediumvioletred:      'c71585',\r\n    midnightblue:         '191970',\r\n    mintcream:            'f5fffa',\r\n    mistyrose:            'ffe4e1',\r\n    moccasin:             'ffe4b5',\r\n    navajowhite:          'ffdead',\r\n    navy:                 '000080',\r\n    oldlace:              'fdf5e6',\r\n    olive:                '808000',\r\n    olivedrab:            '6b8e23',\r\n    orange:               'ffa500',\r\n    orangered:            'ff4500',\r\n    orchid:               'da70d6',\r\n    palegoldenrod:        'eee8aa',\r\n    palegreen:            '98fb98',\r\n    paleturquoise:        'afeeee',\r\n    palevioletred:        'd87093',\r\n    papayawhip:           'ffefd5',\r\n    peachpuff:            'ffdab9',\r\n    peru:                 'cd853f',\r\n    pink:                 'ffc0cb',\r\n    plum:                 'dda0dd',\r\n    powderblue:           'b0e0e6',\r\n    purple:               '800080',\r\n    red:                  'ff0000',\r\n    rosybrown:            'bc8f8f',\r\n    royalblue:            '4169e1',\r\n    saddlebrown:          '8b4513',\r\n    salmon:               'fa8072',\r\n    sandybrown:           'f4a460',\r\n    seagreen:             '2e8b57',\r\n    seashell:             'fff5ee',\r\n    sienna:               'a0522d',\r\n    silver:               'c0c0c0',\r\n    skyblue:              '87ceeb',\r\n    slateblue:            '6a5acd',\r\n    slategray:            '708090',\r\n    snow:                 'fffafa',\r\n    springgreen:          '00ff7f',\r\n    steelblue:            '4682b4',\r\n    tan:                  'd2b48c',\r\n    teal:                 '008080',\r\n    thistle:              'd8bfd8',\r\n    tomato:               'ff6347',\r\n    turquoise:            '40e0d0',\r\n    violet:               'ee82ee',\r\n    violetred:            'd02090',\r\n    wheat:                'f5deb3',\r\n    white:                'ffffff',\r\n    whitesmoke:           'f5f5f5',\r\n    yellow:               'ffff00',\r\n    yellowgreen:          '9acd32'\r\n  };\r\n  \r\n  // Java compatibility\r\n  Color.BLACK      = new Color( 0,   0,   0   ).setImmutable();\r\n  Color.BLUE       = new Color( 0,   0,   255 ).setImmutable();\r\n  Color.CYAN       = new Color( 0,   255, 255 ).setImmutable();\r\n  Color.DARK_GRAY  = new Color( 64,  64,  64  ).setImmutable();\r\n  Color.GRAY       = new Color( 128, 128, 128 ).setImmutable();\r\n  Color.GREEN      = new Color( 0,   255, 0   ).setImmutable();\r\n  Color.LIGHT_GRAY = new Color( 192, 192, 192 ).setImmutable();\r\n  Color.MAGENTA    = new Color( 255, 0,   255 ).setImmutable();\r\n  Color.ORANGE     = new Color( 255, 200, 0   ).setImmutable();\r\n  Color.PINK       = new Color( 255, 175, 175 ).setImmutable();\r\n  Color.RED        = new Color( 255, 0,   0   ).setImmutable();\r\n  Color.WHITE      = new Color( 255, 255, 255 ).setImmutable();\r\n  Color.YELLOW     = new Color( 255, 255, 0   ).setImmutable();\r\n\r\n  /**\r\n   * Interpolates between 2 colors in RGBA space. When distance is 0, color1\r\n   * is returned. When distance is 1, color2 is returned. Other values of\r\n   * distance return a color somewhere between color1 and color2. Each color\r\n   * component is interpolated separately.\r\n   *\r\n   * @param {Color} color1\r\n   * @param {Color} color2\r\n   * @param {Number} distance distance between color1 and color2, 0 <= distance <= 1\r\n   * @return {Color}\r\n   */\r\n  Color.interpolateRBGA = function( color1, color2, distance ) {\r\n    if ( distance < 0 || distance > 1 ) {\r\n      throw new Error( \"distance must be between 0 and 1: \" + distance );\r\n    }\r\n    var r = Math.floor( linear( 0, 1, color1.r, color2.r, distance ) );\r\n    var g = Math.floor( linear( 0, 1, color1.g, color2.g, distance ) );\r\n    var b = Math.floor( linear( 0, 1, color1.b, color2.b, distance ) );\r\n    var a = linear( 0, 1, color1.a, color2.a, distance );\r\n    return new Color( r, g, b, a );\r\n  };\r\n\r\n  return Color;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * Gradient base type for LinearGradient and RadialGradient. Will not function on its own\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/Gradient',['require','SCENERY/util/Color','SCENERY/scenery','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n  \r\n  require( 'SCENERY/util/Color' );\r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Vector2 = require( 'DOT/Vector2' );\r\n\r\n  // TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]\r\n  scenery.Gradient = function Gradient( canvasGradient ) {\r\n    sceneryAssert && sceneryAssert( this.constructor.name !== 'Gradient', 'Please create a LinearGradient or RadialGradient. Do not directly use the supertype Gradient.' );\r\n    \r\n    this.stops = [];\r\n    this.lastStopRatio = 0;\r\n    \r\n    this.canvasGradient = canvasGradient;\r\n    \r\n    this.transformMatrix = null;\r\n  };\r\n  var Gradient = scenery.Gradient;\r\n  \r\n  Gradient.prototype = {\r\n    constructor: Gradient,\r\n    \r\n    /**\r\n     * @param {Number} ratio        Monotonically increasing value in the range of 0 to 1\r\n     * @param {Color|String} color  Color for the stop, either a scenery.Color or CSS color string\r\n     */\r\n    addColorStop: function( ratio, color ) {\r\n      // TODO: invalidate the gradient?\r\n      if ( this.lastStopRatio > ratio ) {\r\n        // fail out, since browser quirks go crazy for this case\r\n        throw new Error( 'Color stops not specified in the order of increasing ratios' );\r\n      } else {\r\n        this.lastStopRatio = ratio;\r\n      }\r\n      \r\n      // make sure we have a scenery.Color now\r\n      if ( typeof color === 'string' ) {\r\n        color = new scenery.Color( color );\r\n      }\r\n      \r\n      this.stops.push( {\r\n        ratio: ratio,\r\n        color: color\r\n      } );\r\n      \r\n      // construct the Canvas gradient as we go\r\n      this.canvasGradient.addColorStop( ratio, color.toCSS() );\r\n      return this;\r\n    },\r\n    \r\n    setTransformMatrix: function( transformMatrix ) {\r\n      // TODO: invalidate the gradient?\r\n      if ( this.transformMatrix !== transformMatrix ) {\r\n        this.transformMatrix = transformMatrix;\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    getCanvasStyle: function() {\r\n      return this.canvasGradient;\r\n    }\r\n  };\r\n  \r\n  return Gradient;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * A linear gradient that can be passed into the 'fill' or 'stroke' parameters.\r\n *\r\n * SVG gradients, see http://www.w3.org/TR/SVG/pservers.html\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/util/LinearGradient',['require','SCENERY/scenery','PHET_CORE/inherit','DOT/Vector2','SCENERY/util/Gradient'],function( require ) {\r\n  'use strict';\r\n  \r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Gradient = require( 'SCENERY/util/Gradient' );\r\n\r\n  // TODO: add the ability to specify the color-stops inline. possibly [ [0,color1], [0.5,color2], [1,color3] ]\r\n  scenery.LinearGradient = function LinearGradient( x0, y0, x1, y1 ) {\r\n    sceneryAssert && sceneryAssert( isFinite( x0 ) && isFinite( y0 ) && isFinite( x1 ) && isFinite( y1 ) );\r\n    var usesVectors = y1 === undefined;\r\n    if ( usesVectors ) {\r\n      sceneryAssert && sceneryAssert( ( x0 instanceof Vector2 ) && ( y0 instanceof Vector2 ), 'If less than 4 parameters are given, the first two parameters must be Vector2' );\r\n    }\r\n    this.start = usesVectors ? x0 : new Vector2( x0, y0 );\r\n    this.end = usesVectors ? y0 : new Vector2( x1, y1 );\r\n    \r\n    // use the global scratch canvas instead of creating a new Canvas\r\n    Gradient.call( this, scenery.scratchContext.createLinearGradient( x0, y0, x1, y1 ) );\r\n  };\r\n  var LinearGradient = scenery.LinearGradient;\r\n  \r\n  inherit( Gradient, LinearGradient, {\r\n    \r\n    // seems we need the defs: http://stackoverflow.com/questions/7614209/linear-gradients-in-svg-without-defs\r\n    // SVG: spreadMethod 'pad' 'reflect' 'repeat' - find Canvas usage\r\n    getSVGDefinition: function( id ) {\r\n      /* Approximate example of what we are creating:\r\n      <linearGradient id=\"grad2\" x1=\"0\" y1=\"0\" x2=\"100\" y2=\"0\" gradientUnits=\"userSpaceOnUse\">\r\n        <stop offset=\"0\" style=\"stop-color:rgb(255,255,0);stop-opacity:1\" />\r\n        <stop offset=\"0.5\" style=\"stop-color:rgba(255,255,0,0);stop-opacity:0\" />\r\n        <stop offset=\"1\" style=\"stop-color:rgb(255,0,0);stop-opacity:1\" />\r\n      </linearGradient>\r\n      */\r\n      var svgns = 'http://www.w3.org/2000/svg'; // TODO: store this in a common place!\r\n      var definition = document.createElementNS( svgns, 'linearGradient' );\r\n      definition.setAttribute( 'id', id );\r\n      definition.setAttribute( 'gradientUnits', 'userSpaceOnUse' ); // so we don't depend on the bounds of the object being drawn with the gradient\r\n      definition.setAttribute( 'x1', this.start.x );\r\n      definition.setAttribute( 'y1', this.start.y );\r\n      definition.setAttribute( 'x2', this.end.x );\r\n      definition.setAttribute( 'y2', this.end.y );\r\n      if ( this.transformMatrix ) {\r\n        definition.setAttribute( 'gradientTransform', this.transformMatrix.getSVGTransform() );\r\n      }\r\n      \r\n      _.each( this.stops, function( stop ) {\r\n        var stopElement = document.createElementNS( svgns, 'stop' );\r\n        stopElement.setAttribute( 'offset', stop.ratio );\r\n        stopElement.setAttribute( 'style', 'stop-color: ' + stop.color.withAlpha( 1 ).toCSS() + '; stop-opacity: ' + stop.color.a.toFixed( 20 ) + ';' );\r\n        definition.appendChild( stopElement );\r\n      } );\r\n      \r\n      return definition;\r\n    },\r\n    \r\n    toString: function() {\r\n      var result = 'new scenery.LinearGradient( ' + this.start.x + ', ' + this.start.y + ', ' + this.end.x + ', ' + this.end.y + ' )';\r\n      \r\n      _.each( this.stops, function( stop ) {\r\n        result += '.addColorStop( ' + stop.ratio + ', \\'' + stop.color.toString() + '\\' )';\r\n      } );\r\n      \r\n      return result;\r\n    }\r\n  } );\r\n  \r\n  return LinearGradient;\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Code for testing which platform is running.  Use sparingly, if at all!\r\n *\r\n * Sample usage:\r\n * if (platform.firefox) {node.renderer = 'canvas';}\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'PHET_CORE/platform',['require'],function( require ) {\r\n  'use strict';\r\n\r\n  return {\r\n    get firefox() { return navigator.userAgent.toLowerCase().indexOf( 'firefox' ) > -1; },\r\n\r\n    //see http://stackoverflow.com/questions/3007480/determine-if-user-navigated-from-mobile-safari\r\n    get mobileSafari() { return navigator.userAgent.match( /(iPod|iPhone|iPad)/ ) && navigator.userAgent.match( /AppleWebKit/ );}\r\n  };\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * The button that pops up the PhET menu.\r\n */\r\ndefine( 'JOIST/PhetButton',['require','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/nodes/Text','SCENERY/nodes/Image','SUN/FontAwesomeNode','SCENERY/nodes/Rectangle','SCENERY/nodes/Plane','PHET_CORE/inherit','PHET_CORE/platform','JOIST/PhetMenu','SCENERY/util/Font','KITE/Shape','SCENERY/util/LinearGradient','SCENERY/input/ButtonListener','DOT/Vector2','JOIST/joistImageLoader'],function( require ) {\r\n  'use strict';\r\n\r\n  //imports\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var Image = require( 'SCENERY/nodes/Image' );\r\n  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n  var Plane = require( 'SCENERY/nodes/Plane' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var platform = require( 'PHET_CORE/platform' );\r\n  var PhetMenu = require( 'JOIST/PhetMenu' );\r\n  var Font = require( 'SCENERY/util/Font' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var LinearGradient = require( 'SCENERY/util/LinearGradient' );\r\n  var ButtonListener = require( 'SCENERY/input/ButtonListener' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var joistImageLoader = require( 'JOIST/joistImageLoader' );\r\n\r\n  //TODO this is copied from NavigationBar\r\n  var createHighlight = function( width, height ) {\r\n    var leftBar = new Path( {shape: Shape.lineSegment( 0, 0, 0, height ), lineWidth: 1, stroke: new LinearGradient( 0, 0, 0, height ).addColorStop( 0, 'black' ).addColorStop( 0.5, 'white' ).addColorStop( 1, 'black' ) } );\r\n    var rightBar = new Path( {shape: Shape.lineSegment( width, 0, width, height ), lineWidth: 1, stroke: new LinearGradient( 0, 0, 0, height ).addColorStop( 0, 'black' ).addColorStop( 0.5, 'white' ).addColorStop( 1, 'black' ) } );\r\n    return new Node( {children: [leftBar, rightBar], visible: false} );\r\n  };\r\n\r\n  //TODO this is copied from NavigationBar\r\n  var createHighlightListener = function( node ) {\r\n    return {//Highlight a button when mousing over it\r\n      over: function( event ) { if ( event.pointer.isMouse ) {node.visible = true;} },\r\n      out: function( event ) { if ( event.pointer.isMouse ) {node.visible = false;} }\r\n    };\r\n  };\r\n\r\n  //TODO don't pass in navigationBar, position based on this button\r\n  function PhetButton( sim, options ) {\r\n\r\n    var phetButton = this;\r\n    Node.call( this, {renderer: 'svg', cursor: 'pointer'} );\r\n\r\n    options = _.extend( {phetLogo: 'phet-logo-short.svg', phetLogoScale: 0.28, optionsButtonVerticalMargin: 1.5}, options );\r\n\r\n    var phetLabel = new Image( joistImageLoader.getImage( options.phetLogo ), {scale: options.phetLogoScale} );\r\n\r\n    //Workaround for the SVG not showing up properly in firefox.  SVG Renderer still giving odd bounds on FireFox, so use canvas there\r\n    if ( platform.firefox ) {phetLabel.renderer = 'canvas';}\r\n\r\n    var optionsButton = new FontAwesomeNode( 'reorder', {fill: '#fff', scale: 0.6, left: phetLabel.width + 10, bottom: phetLabel.bottom - options.optionsButtonVerticalMargin} );\r\n\r\n    this.addChild( phetLabel );\r\n    this.addChild( optionsButton );\r\n\r\n    var optionsHighlight = createHighlight( this.width + 6, this.height - 2 );\r\n    optionsHighlight.bottom = this.bottom + 3;\r\n    optionsHighlight.x = -3;\r\n    this.addChild( optionsHighlight );\r\n\r\n    //When the phet button is pressed, show the phet menu\r\n    var phetButtonPressed = function() {\r\n      var phetMenu = new PhetMenu( sim );\r\n      phetMenu.right = phetButton.globalToParentPoint( new Vector2( phetButton.globalBounds.maxX, 0 ) ).x;\r\n      phetMenu.bottom = phetButton.centerY;\r\n      var rectangle = new Plane( {fill: 'black', opacity: 0.3} );\r\n      var detach = function() {\r\n        rectangle.detach();\r\n        phetMenu.detach();\r\n        phetMenu.removeInputListener( popupMenuListener );\r\n        rectangle.removeInputListener( rectangleListener );\r\n      };\r\n      var popupMenuListener = new ButtonListener( {fire: detach} );\r\n      var rectangleListener = {down: detach};\r\n\r\n      phetMenu.addInputListener( popupMenuListener );\r\n      rectangle.addInputListener( rectangleListener );\r\n\r\n      phetButton.parents[0].addChild( rectangle );\r\n      phetButton.parents[0].addChild( phetMenu );\r\n    };\r\n\r\n    this.addPeer( '<input type=\"button\" aria-label=\"PhET Menu\">', {click: phetButtonPressed, tabIndex: 101} );\r\n    this.addInputListener( new ButtonListener( {fire: phetButtonPressed} ) );\r\n    this.addInputListener( createHighlightListener( optionsHighlight ) );\r\n\r\n    // eliminate interactivity gap between label and button\r\n    this.mouseArea = this.touchArea = Shape.bounds( this.bounds );\r\n\r\n    this.mutate( options );\r\n  }\r\n\r\n  return inherit( Node, PhetButton );\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Static utilities for creating and showing highlights on mouseover\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/Highlight',['require','SCENERY/nodes/Node','SCENERY/nodes/Path','KITE/Shape','SCENERY/util/LinearGradient'],function( require ) {\r\n  'use strict';\r\n\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var LinearGradient = require( 'SCENERY/util/LinearGradient' );\r\n\r\n  var createHighlight = function( width, height ) {\r\n    var leftBar = new Path( {shape: Shape.lineSegment( 0, 0, 0, height ), lineWidth: 1, stroke: new LinearGradient( 0, 0, 0, height ).addColorStop( 0, 'black' ).addColorStop( 0.5, 'white' ).addColorStop( 1, 'black' ) } );\r\n    var rightBar = new Path( {shape: Shape.lineSegment( width, 0, width, height ), lineWidth: 1, stroke: new LinearGradient( 0, 0, 0, height ).addColorStop( 0, 'black' ).addColorStop( 0.5, 'white' ).addColorStop( 1, 'black' ) } );\r\n    return new Node( {children: [leftBar, rightBar], visible: false} );\r\n  };\r\n\r\n  var createHighlightListener = function( node ) {\r\n    return {//Highlight a button when mousing over it\r\n      over: function( event ) { if ( event.pointer.isMouse ) {node.visible = true;} },\r\n      out: function( event ) { if ( event.pointer.isMouse ) {node.visible = false;} }\r\n    };\r\n  };\r\n\r\n  return {createHighlight: createHighlight, createHighlightListener: createHighlightListener};\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * The navigation bar at the bottom of the screen.\r\n * For a single-screen sim, it shows the name of the sim at the left and the PhET Logo and options menu at the right.\r\n * For a multi-screen sim, it shows icons for all of the other screens, with the screen name at the left and the PhET Logo and options menu at the right.\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/NavigationBar',['require','SCENERY/nodes/Node','SCENERY/nodes/Path','SCENERY/nodes/HBox','SCENERY/nodes/VBox','SCENERY/nodes/Text','SUN/FontAwesomeNode','SUN/Panel','SCENERY_PHET/HomeButton','SCENERY/nodes/Rectangle','PHET_CORE/inherit','JOIST/PhetMenu','SCENERY_PHET/PhetFont','KITE/Shape','SCENERY/util/LinearGradient','JOIST/PhetButton','SCENERY/input/ButtonListener','JOIST/Highlight'],function( require ) {\r\n  'use strict';\r\n\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var HBox = require( 'SCENERY/nodes/HBox' );\r\n  var VBox = require( 'SCENERY/nodes/VBox' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );\r\n  var Panel = require( 'SUN/Panel' );\r\n  var HomeButton = require( 'SCENERY_PHET/HomeButton' );\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var PhetMenu = require( 'JOIST/PhetMenu' );\r\n  var PhetFont = require( 'SCENERY_PHET/PhetFont' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var LinearGradient = require( 'SCENERY/util/LinearGradient' );\r\n  var PhetButton = require( 'JOIST/PhetButton' );\r\n  var ButtonListener = require( 'SCENERY/input/ButtonListener' );\r\n  var Highlight = require( 'JOIST/Highlight' );\r\n\r\n  /**\r\n   * Create a nav bar.  Layout assumes all of the screen widths are the same.\r\n   * @param {Sim} sim\r\n   * @param {Array<Screen>} screens\r\n   * @param {PropertySet} model see joist.Sim\r\n   * @constructor\r\n   */\r\n  function NavigationBar( sim, screens, model ) {\r\n    this.screens = screens;\r\n\r\n    this.navBarHeight = 40;\r\n    this.navBarScale = 1;\r\n    this.navBarWidth = 768;\r\n\r\n    Node.call( this, {renderer: 'svg'} );\r\n    this.background = new Rectangle( 0, 0, 0, 0, {fill: 'black'} );\r\n    this.addChild( this.background );\r\n\r\n    this.hbox = new PhetButton( sim );\r\n    this.addChild( this.hbox );\r\n\r\n    this.titleLabel = new Text( sim.name, {font: new PhetFont( 18 ), fill: 'white'} );\r\n\r\n    //Create the nodes to be used for the screen icons\r\n    var index = 0;\r\n\r\n    var selectedFont = new PhetFont( { size: 10, weight: 'bold'} );\r\n    var normalFont = new PhetFont( { size: 10 } );\r\n\r\n    this.addChild( this.titleLabel );\r\n\r\n    if ( screens.length > 1 ) {\r\n\r\n      var iconAndTextArray = _.map( screens, function( screen ) {\r\n        var icon = new Node( {children: [screen.icon], scale: 25 / screen.icon.height} );\r\n        var text = new Text( screen.name, { fill: 'white', visible: true} );\r\n\r\n        //Put a panel around it to extend it horizontally so there is some distance from the highlight region to the text and some distance between adjacent texts.\r\n        var textPanel = new Panel( text, {\r\n          fill: null,\r\n          stroke: null,\r\n          lineWidth: 1, // width of the background border\r\n          xMargin: 4,\r\n          yMargin: 0,\r\n          cornerRadius: 0, // radius of the rounded corners on the background\r\n          resize: false // dynamically resize when content bounds change?\r\n        } );\r\n        var iconAndText = new VBox( {children: [icon, textPanel]} );\r\n        iconAndText.icon = icon;\r\n        iconAndText.text = text;\r\n        iconAndText.textPanel = textPanel;\r\n        iconAndText.index = index++;\r\n        iconAndText.screen = screen;\r\n\r\n        //On initialization and when the screen changes, update the size of the icons and the layout of the icons and text\r\n        model.screenIndexProperty.link( function( screenIndex ) {\r\n          var selected = iconAndText.index === screenIndex;\r\n          iconAndText.text.fill = selected ? 'yellow' : 'white';\r\n          iconAndText.text.font = selected ? selectedFont : normalFont;\r\n          iconAndText.opacity = selected ? 1.0 : 0.5;\r\n        } );\r\n\r\n        return iconAndText;\r\n      } );\r\n\r\n      //Make all of the icons the same size so they will have equal hit areas and equal spacing\r\n      var maxWidth = _.max( iconAndTextArray,function( iconAndText ) {return iconAndText.width;} ).width;\r\n      var maxHeight = _.max( iconAndTextArray,function( iconAndText ) {return iconAndText.height;} ).height;\r\n\r\n      this.buttonArray = iconAndTextArray.map( function( iconAndText ) {\r\n        //Background area for layout and hit region\r\n        var rectangle = new Rectangle( 0, 0, maxWidth, maxHeight );\r\n        var highlight = Highlight.createHighlight( maxWidth, maxHeight );\r\n        iconAndText.centerX = maxWidth / 2;\r\n        iconAndText.top = 0;\r\n        var button = new Node( {children: [ rectangle, highlight, iconAndText]} );\r\n\r\n        //In the nav bar, don't show highlight or cursor pointer when over a screen icon that is already selected\r\n        model.screenIndexProperty.link( function( screenIndex ) { button.cursor = screenIndex === iconAndText.index ? 'default' : 'pointer'; } );\r\n\r\n        var pressListener = function() {\r\n          model.screenIndex = iconAndText.index;\r\n          model.showHomeScreen = false;\r\n        };\r\n        button.addInputListener( new ButtonListener( {fire: pressListener} ) );\r\n\r\n        //TODO: Move the over/out listener into ButtonListener when it is working better. Currently 'out' is not being fired\r\n        button.addInputListener( {\r\n          //Highlight a button when mousing over it\r\n          over: function( event ) {\r\n            if ( event.pointer.isMouse ) {\r\n              highlight.visible = true;\r\n            }\r\n          },\r\n          out: function( event ) {\r\n            if ( event.pointer.isMouse ) {\r\n              highlight.visible = false;\r\n            }\r\n          }\r\n        } );\r\n\r\n        button.addPeer( '<input type=\"button\" aria-label=\"Switch to the ' + iconAndText.screen.name + ' screen\">', {click: pressListener, tabIndex: 99} );\r\n        return  button;\r\n      } );\r\n\r\n      //TODO: This spacing is not always necessary, it depends on the relative width\r\n      //TODO:   of the icon vs the text, if all of the buttons have the same dimensions.\r\n      //TODO:   Currently this solves the simple case where all of the text is shorter than all of the icons (like in Build an Atom)\r\n      //TODO: A better strategy may be to use a linear function to space them based on how far it is from the criterion maxTextWidth<=maxIconWidth+2\r\n      //See Joist #28 https://github.com/phetsims/joist/issues/28\r\n      var maxIconWidth = _.max( iconAndTextArray,function( i ) {return i.icon.width;} ).icon.width;\r\n      var maxTextWidth = _.max( iconAndTextArray,function( i ) {return i.text.width;} ).text.width;\r\n\r\n      this.buttonHBox = new HBox( {spacing: maxTextWidth <= maxIconWidth + 2 ? 20 : 0, children: this.buttonArray} );\r\n      this.addChild( this.buttonHBox );\r\n\r\n      //add the home icon\r\n      this.homeIcon = new HomeButton();\r\n      var homeHighlight = Highlight.createHighlight( this.homeIcon.width + 10, this.homeIcon.height + 5 );\r\n      homeHighlight.bottom = this.homeIcon.bottom + 3;\r\n      homeHighlight.x = -5;\r\n      this.homeIcon.addChild( homeHighlight );\r\n\r\n      //Hide the highlight on the home icon if the home icon is pressed\r\n      model.showHomeScreenProperty.link( function( showHomeScreen ) { if ( showHomeScreen ) { homeHighlight.visible = false; } } );\r\n      this.homeIcon.addInputListener( { down: function() { model.showHomeScreen = true; }} );\r\n      this.homeIcon.addInputListener( Highlight.createHighlightListener( homeHighlight ) );\r\n      this.homeIcon.addPeer( '<input type=\"button\" aria-label=\"Home Screen\">', {click: function() {model.showHomeScreen = true;}, tabIndex: 100} );\r\n      this.addChild( this.homeIcon );\r\n    }\r\n  }\r\n\r\n  return inherit( Node, NavigationBar, {\r\n    relayout: function() {\r\n      var navigationBar = this;\r\n      navigationBar.background.rectHeight = this.navBarHeight;\r\n      navigationBar.background.rectWidth = this.navBarWidth;\r\n      var screenIndex = navigationBar.screenIndex;\r\n\r\n      if ( this.buttonHBox ) {\r\n        this.buttonHBox.setScaleMagnitude( navigationBar.navBarScale );\r\n      }\r\n\r\n      this.titleLabel.setScaleMagnitude( this.navBarScale );\r\n      this.titleLabel.centerY = this.navBarHeight / 2;\r\n      this.titleLabel.left = 10;\r\n\r\n      //Lay out the components from left to right\r\n      if ( this.screens.length !== 1 ) {\r\n\r\n        //put the center right in the middle\r\n        this.buttonHBox.centerX = this.navBarWidth / 2;\r\n        this.buttonHBox.top = 2;\r\n\r\n        navigationBar.homeIcon.setScaleMagnitude( this.navBarScale );\r\n        navigationBar.homeIcon.top = 2;\r\n        navigationBar.homeIcon.left = navigationBar.buttonHBox.right + 15;\r\n      }\r\n      this.hbox.setScaleMagnitude( this.navBarScale );\r\n      this.hbox.right = this.navBarWidth - 5;\r\n      this.hbox.centerY = this.navBarHeight / 2;\r\n    },\r\n    layout: function( scale, width, height, windowHeight ) {\r\n      this.navBarScale = scale;\r\n      this.navBarWidth = width;\r\n      this.navBarHeight = height;\r\n      this.relayout();\r\n    }} );\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Decorative frame around the selected node\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/Frame',['require','PHET_CORE/inherit','SCENERY/nodes/Node','SCENERY/nodes/Rectangle','SCENERY/util/LinearGradient'],function( require ) {\r\n  'use strict';\r\n\r\n  // imports\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n  var LinearGradient = require( 'SCENERY/util/LinearGradient' );\r\n\r\n  /**\r\n   * @param {Node} content\r\n   * @param {object} options\r\n   * @constructor\r\n   */\r\n  function Frame( content, options ) {\r\n\r\n    var thisNode = this;\r\n\r\n    // default options\r\n    options = _.extend( {\r\n      xMargin1: 6,\r\n      yMargin1: 6,\r\n      cornerRadius: 0 // radius of the rounded corners on the background\r\n    }, options );\r\n\r\n    Node.call( thisNode );\r\n\r\n    var width1 = content.width + 2 * options.xMargin1;\r\n    var height1 = content.height + 2 * options.yMargin1;\r\n\r\n    this.gradient = new LinearGradient( 0, 0, width1, 0 ).addColorStop( 0, '#fbff41' ).addColorStop( 118 / 800.0, '#fef98b' ).addColorStop( 372 / 800.0, '#feff40' ).addColorStop( 616 / 800, '#fffccd' ).addColorStop( 1, '#fbff41' );\r\n    this.rectangle = new Rectangle( 0, 0, width1, height1, options.cornerRadius, options.cornerRadius, {stroke: this.gradient, lineWidth: 3, x: content.x - options.xMargin1, y: content.y - options.yMargin1} );\r\n    this.addChild( this.rectangle );\r\n\r\n    // Apply options after the layout is done, so that options that use the bounds will work properly.\r\n    this.mutate( options );\r\n    this.width1 = width1;\r\n    this.height1 = height1;\r\n  }\r\n\r\n  inherit( Node, Frame, {\r\n    setHighlighted: function( highlighted ) {\r\n      this.rectangle.lineWidth = highlighted ? 4.5 : 3;\r\n\r\n      //Make the frame larger when highlighted, but only so that it expands out\r\n      if ( highlighted ) {\r\n        this.rectangle.setRect( -1.5 / 2, -1.5 / 2, this.width1 + 1.5, this.height1 + 1.5 );\r\n      }\r\n      else {\r\n        this.rectangle.setRect( 0, 0, this.width1, this.height1 );\r\n      }\r\n    }\r\n  } );\r\n\r\n  return Frame;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * An observable property, notifies registered observers when the value changes.\r\n *\r\n * Uses the 'Constructor' pattern for object creation, which has the downside that\r\n * all properties are created once for each instance. It would be nice if our functions\r\n * were shared. But since the only way to create private fields is in the constructor,\r\n * and the functions need access to those private fields, there doesn't seem to be\r\n * any choice but to define the functions in the constructor.\r\n *\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'AXON/Property',['require','AXON/log','AXON/axon'],function( require ) {\r\n  'use strict';\r\n\r\n  var log = require( 'AXON/log' );\r\n  var axon = require( 'AXON/axon' );\r\n\r\n  /**\r\n   * @param {*} value\r\n   * @constructor\r\n   */\r\n  axon.Property = function Property( value ) {\r\n\r\n    //Store the internal value and the initial value\r\n    this._value = value;\r\n    this._initialValue = value;\r\n    this._observers = [];\r\n\r\n    //Set up for recording\r\n    log.registerProperty( this );\r\n  };\r\n\r\n  axon.Property.prototype = {\r\n\r\n    /**\r\n     * Gets the value.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.\r\n     * @return {*}\r\n     */\r\n    get: function() {\r\n      return this._value;\r\n    },\r\n\r\n    /**\r\n     * Sets the value and notifies registered observers.  You can also use the es5 getter (property.value) but this means is provided for inner loops or internal code that must be fast.\r\n     * If the value hasn't changed, this is a no-op.\r\n     *\r\n     * @param {*} value\r\n     */\r\n    set: function( value ) {\r\n      if ( value !== this._value ) { //TODO: some Properties probably need deep comparisons here\r\n        var oldValue = this._value;\r\n        this._value = value;\r\n        var observersCopy = this._observers.slice(); // make a copy, in case notification results in removeObserver\r\n        for ( var i = 0; i < observersCopy.length; i++ ) {\r\n          observersCopy[i]( value, oldValue );\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Resets the value to the initial value.\r\n     */\r\n    reset: function() {\r\n      this.set( this._initialValue );\r\n    },\r\n\r\n    /**\r\n     * This function returns a bound function that sets the specified value.  For use in creating closures e.g. with gui classes.\r\n     * For instance, to have a button that sets a property to true, instead of using\r\n     * button.click(function(){property.set(true);});\r\n     * you could use\r\n     * button.click(property._set(true));\r\n     * @param value the value to use when the setter is called.\r\n     * @return a function that can be used to set the specified value.\r\n     */\r\n    _set: function( value ) {\r\n      return this.set.bind( this, value );\r\n    },\r\n\r\n    get value() { return this.get(); },\r\n\r\n    set value( newValue ) { this.set( newValue ); },\r\n\r\n    /**\r\n     * Adds an observer and notifies it immediately.\r\n     * If observer is already registered, this is a no-op.\r\n     * The initial notification provides the current value for newValue and null for oldValue.\r\n     *\r\n     * @param {Function} observer a function of the form observer(newValue,oldValue)\r\n     */\r\n    link: function( observer ) {\r\n      if ( this._observers.indexOf( observer ) === -1 ) {\r\n        this._observers.push( observer );\r\n        observer( this._value, null ); // null should be used when an object is expected but unavailable\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Removes an observer.\r\n     * If observer is not registered, this is a no-op.\r\n     *\r\n     * @param {Function} observer\r\n     */\r\n    unlink: function( observer ) {\r\n      var index = this._observers.indexOf( observer );\r\n      if ( index !== -1 ) {\r\n        this._observers.splice( index, index + 1 );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Add an observer to the Property, without calling it back right away.  This is mostly used for internal code.\r\n     * @param {Function} observer  a function with a single argument, which is the value of the property at the time the function is called.\r\n     */\r\n    lazyLink: function( observer ) {\r\n      if ( this._observers.indexOf( observer ) === -1 ) {\r\n        this._observers.push( observer );\r\n      }\r\n    },\r\n\r\n    //Provide toString for console debugging, see http://stackoverflow.com/questions/2485632/valueof-vs-tostring-in-javascript\r\n    toString: function() {return 'Property{' + this.get() + '}'; },\r\n    valueOf: function() {return this.toString();},\r\n\r\n    /**\r\n     * Add a listener so that it will only fire once (and not on registration)\r\n     *\r\n     * I can see two ways to implement this:\r\n     * (a) add a field to the observer so after notifications it can be checked and possibly removed. Disadvantage: will make everything slower even if not using 'once'\r\n     * (b) wrap the observer in a new function which will call the observer and then remove itself.  Disadvantage: cannot remove an observer added using 'once'\r\n     * To avoid possible performance problems, use a wrapper function, and return it as a handle in case the 'once' listener must be removed before it is called once\r\n     *\r\n     * @param observer the listener which should be called back only for one property change (and not on registration)\r\n     * @returns {Function} the wrapper handle in case the wrapped function needs to be removed with 'unlink' before it is called once\r\n     */\r\n    once: function( observer ) {\r\n      var property = this;\r\n      var wrapper = function( newValue, oldValue ) {\r\n        observer( newValue, oldValue );\r\n        property.unlink( wrapper );\r\n      };\r\n      this.lazyLink( wrapper );\r\n      return wrapper;\r\n    },\r\n\r\n    /**\r\n     * Links an object's named attribute to this property.  Returns a handle so it can be removed.\r\n     * Example: modelVisibleProperty.linkAttribute(view,'visible');\r\n     *\r\n     * @param object\r\n     * @param attributeName\r\n     */\r\n    linkAttribute: function( object, attributeName ) {\r\n      var handle = function( value ) {object[attributeName] = value;};\r\n      this.link( handle );\r\n      return handle;\r\n    },\r\n\r\n    /**\r\n     * Returns a new DerivedProperty which is true/false based on whether the value matches (based on ===) the passed in argument.\r\n     * @param value\r\n     * @returns {axon.DerivedProperty}\r\n     */\r\n    valueEquals: function( value ) {\r\n      return new axon.DerivedProperty( [this], function( propertyValue ) { return propertyValue === value; } );\r\n    },\r\n\r\n    /**\r\n     * Two way communication for not, so you can set the value and have it come back to the parent\r\n     * Note that noting about the following code is specific to booleans, although this should probably be used mostly for booleans.\r\n     * To unlink both listeners attached unlink a property created with not(), use detach()\r\n     */\r\n    not: function() {\r\n      var parentProperty = this;\r\n      var childProperty = new axon.Property( !this.value );\r\n\r\n      var setParentToChild = function( value ) {childProperty.set( !value );};\r\n      parentProperty.link( setParentToChild );\r\n\r\n      var setChildToParent = function( value ) {parentProperty.set( !value );};\r\n      childProperty.link( setChildToParent );\r\n\r\n      childProperty.detach = function() {\r\n        parentProperty.unlink( setParentToChild );\r\n        childProperty.unlink( setChildToParent );\r\n      };\r\n      return childProperty;\r\n    },\r\n\r\n    /**\r\n     * Convenience function for debugging a property values.  It prints the new value on registration and when changed.\r\n     * @param name debug name to be printed on the console\r\n     * @returns {Function} the handle to the linked listener in case it needs to be removed later\r\n     */\r\n    debug: function( name ) {\r\n      var listener = function( value ) { console.log( name, value ); };\r\n      this.link( listener );\r\n      return listener;\r\n    }\r\n  };\r\n\r\n  return axon.Property;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Shows a button that changes the simulation to full screen.  This feature is not available on iPad.\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/FullScreenButton',['require','SCENERY/nodes/Node','SCENERY/nodes/Path','KITE/Shape','SCENERY/util/LinearGradient','SUN/FontAwesomeNode','PHET_CORE/inherit','SCENERY/input/ButtonListener','SCENERY/input/Input'],function( require ) {\r\n  'use strict';\r\n\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var LinearGradient = require( 'SCENERY/util/LinearGradient' );\r\n  var FontAwesomeNode = require( 'SUN/FontAwesomeNode' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var ButtonListener = require( 'SCENERY/input/ButtonListener' );\r\n  var Input = require( 'SCENERY/input/Input' );\r\n\r\n  function requestFullScreen( element ) {\r\n\r\n    // Supports most browsers and their versions.\r\n    var requestMethod = element.requestFullScreen || element.webkitRequestFullScreen || element.mozRequestFullScreen || element.msRequestFullScreen;\r\n\r\n    if ( requestMethod ) { // Native full screen.\r\n      requestMethod.call( element );\r\n    }\r\n    else if ( typeof window.ActiveXObject !== \"undefined\" ) { // Older IE.\r\n      var wscript = new ActiveXObject( \"WScript.Shell\" );\r\n      if ( wscript !== null ) {\r\n        wscript.SendKeys( \"{F11}\" );\r\n      }\r\n    }\r\n  }\r\n\r\n  var fullScreener = function() {\r\n    requestFullScreen( document.body );\r\n  };\r\n\r\n  function FullScreenButton( options ) {\r\n    Node.call( this, {cursor: 'pointer'} );\r\n    this.addChild( new FontAwesomeNode( 'fullscreen', {fill: '#fff', scale: 0.8} ) );\r\n    this.mutate( _.extend( {cursor: 'pointer'}, options ) );//TODO: pointer not going through here\r\n\r\n    this.addInputListener( {down: function() {\r\n      $( 'body' ).one( 'mouseup', fullScreener );\r\n    }} );\r\n\r\n    this.mouseArea = this.bounds;\r\n    this.touchArea = this.bounds;\r\n  }\r\n\r\n  return inherit( Node, FullScreenButton );\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Shows the home screen for a multi-screen simulation, which lets the user see all of the screens and select one.\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/HomeScreen',['require','JOIST/PhetButton','SCENERY/nodes/Node','SCENERY/nodes/HBox','SCENERY/nodes/VBox','SCENERY/nodes/Text','KITE/Shape','PHET_CORE/inherit','JOIST/ScreenView','JOIST/Frame','SCENERY/nodes/Rectangle','AXON/Property','SCENERY/input/ButtonListener','JOIST/FullScreenButton','SCENERY_PHET/PhetFont'],function( require ) {\r\n  'use strict';\r\n\r\n  var PhetButton = require( 'JOIST/PhetButton' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var HBox = require( 'SCENERY/nodes/HBox' );\r\n  var VBox = require( 'SCENERY/nodes/VBox' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var ScreenView = require( 'JOIST/ScreenView' );\r\n  var Frame = require( 'JOIST/Frame' );\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n  var Property = require( 'AXON/Property' );\r\n  var ButtonListener = require( 'SCENERY/input/ButtonListener' );\r\n  var FullScreenButton = require( 'JOIST/FullScreenButton' );\r\n  var PhetFont = require( 'SCENERY_PHET/PhetFont' );\r\n\r\n  var HEIGHT = 70;\r\n\r\n  function HomeScreen( sim ) {\r\n    var homeScreen = this;\r\n\r\n    //Rendering in SVG seems to solve the problem that the home screen consumes 100% disk and crashes, see https://github.com/phetsims/joist/issues/17\r\n    //Also makes it more responsive (and crisper on retina displays)\r\n    ScreenView.call( this, {renderer: 'svg'} );\r\n\r\n    this.backgroundColor = 'black';\r\n\r\n    //iPad doesn't support Century Gothic, so fall back to Futura, see http://wordpress.org/support/topic/font-not-working-on-ipad-browser\r\n    var title = new Text( sim.name, {\r\n      font: new PhetFont( {size: 52, family: 'Century Gothic, Futura' }),\r\n      fill: 'white',\r\n      y: 110,\r\n      centerX: this.layoutBounds.width / 2} );\r\n    this.addChild( title );\r\n\r\n    //Keep track of which screen is highlighted so the same screen can remain highlighted even if nodes are replaced (say when one grows larger or smaller)\r\n    var highlightedIndex = new Property( -1 );\r\n\r\n    var screenChildren = _.map( sim.screens, function( screen ) {\r\n      var index = sim.screens.indexOf( screen );\r\n      var largeIcon = new Node( {children: [screen.icon], scale: HEIGHT / screen.icon.height * 2} );\r\n      var frame = new Frame( largeIcon );\r\n\r\n      highlightedIndex.link( function( highlightedIndex ) { frame.setHighlighted( highlightedIndex === index ); } );\r\n\r\n      var largeIconWithFrame = new Node( {children: [ frame, largeIcon]} );\r\n      var large = new VBox( {cursor: 'pointer', children: [\r\n        largeIconWithFrame,\r\n        new Text( screen.name, { font: new PhetFont( 42 ), fill: 'yellow'} )\r\n      ]} );\r\n\r\n      //TODO: Switch to buttonListener, but make sure you test it because on 7/17/2013 there is a problem where ButtonListener won't fire if a node has appeared under the pointer\r\n      large.addInputListener( {\r\n        down: function() {\r\n          sim.simModel.showHomeScreen = false;\r\n          highlightedIndex.value = -1;\r\n        }\r\n      } );\r\n\r\n      var small = new VBox( {spacing: 3, cursor: 'pointer', children: [\r\n        new Node( {opacity: 0.5, children: [screen.icon], scale: sim.screens.length === 4 ? HEIGHT / screen.icon.height :\r\n                                                              sim.screens.length === 3 ? 1.25 * HEIGHT / screen.icon.height :\r\n                                                              sim.screens.length === 2 ? 1.75 * HEIGHT / screen.icon.height :\r\n                                                              HEIGHT / screen.icon.height} ),\r\n        new Text( screen.name, { font: new PhetFont( 18 ), fill: 'gray'} )\r\n      ]} );\r\n      small.mouseArea = small.touchArea = Shape.bounds( small.bounds ); //cover the gap in the vbox\r\n      small.addInputListener( {\r\n        down: function() { sim.simModel.screenIndex = index; },\r\n\r\n        //On the home screen if you touch an inactive screen thumbnail, it grows.  If then without lifting your finger you swipe over\r\n        // to the next thumbnail, that one would grow.\r\n        over: function( event ) {\r\n          if ( !event.pointer.isMouse ) {\r\n            sim.simModel.screenIndex = index;\r\n          }\r\n        }\r\n      } );\r\n\r\n      var highlightListener = {\r\n        over: function( event ) {\r\n          if ( event.pointer.isMouse ) {\r\n            highlightedIndex.value = index;\r\n\r\n            //TODO: use named children instead of child indices?\r\n            small.children[0].opacity = 1;\r\n            small.children[1].fill = 'white';\r\n          }\r\n        },\r\n        out: function( event ) {\r\n          if ( event.pointer.isMouse ) {\r\n            highlightedIndex.value = -1;\r\n            small.children[0].opacity = 0.5;\r\n            small.children[1].fill = 'gray';\r\n          }\r\n        }\r\n      };\r\n      small.addInputListener( highlightListener );\r\n\r\n      large.addInputListener( highlightListener );\r\n      large.mouseArea = large.touchArea = Shape.bounds( large.bounds ); //cover the gap in the vbox\r\n\r\n      //TODO: Add accessibility peers\r\n      //      screenChild.addPeer( '<input type=\"button\" aria-label=\"' + screenChild.screen.name + '\">', {click: function() {\r\n//        var screen = screenChild.screen;\r\n//        if ( sim.simModel.screenIndex === screen.index ) {\r\n//          sim.simModel.showHomeScreen = false;\r\n//        }\r\n//        else {\r\n//          sim.simModel.screenIndex = screen.index;\r\n//        }\r\n//      }} );\r\n//    } );\r\n\r\n      return {screen: screen, small: small, large: large, index: index};\r\n    } );\r\n\r\n    var center = new Node( {y: 170} );\r\n    homeScreen.addChild( center );\r\n    sim.simModel.screenIndexProperty.link( function( screenIndex ) {\r\n\r\n      //Space the icons out more if there are fewer, so they will be spaced nicely\r\n      //Cannot have only 1 screen because for 1-screen sims there is no home screen.\r\n      var spacing = sim.screens.length === 2 ? 60 :\r\n                    sim.screens.length === 3 ? 60 :\r\n                    33;\r\n\r\n      var icons = _.map( screenChildren, function( screenChild ) {return screenChild.index === screenIndex ? screenChild.large : screenChild.small;} );\r\n      center.children = [new HBox( {spacing: spacing, children: icons, align: 'top'} )];\r\n      center.centerX = homeScreen.layoutBounds.width / 2;\r\n    } );\r\n\r\n    //Only show the full screen button on supported platforms\r\n    var deviceIsAndroid = navigator.userAgent.indexOf( 'Android' ) > 0;\r\n    var deviceIsIOS = /iP(ad|hone|od)/.test( navigator.userAgent );\r\n\r\n    function isIE( v ) {\r\n      var r = new RegExp( 'msie' + (!isNaN( v ) ? ('\\\\s' + v) : ''), 'i' );\r\n      return r.test( navigator.userAgent );\r\n    }\r\n\r\n    var ie = isIE( 9 ) || isIE( 10 );//might work on IE11\r\n\r\n    var showFullScreenButton = !deviceIsAndroid && !deviceIsIOS && !ie;\r\n    if ( showFullScreenButton && false ) {\r\n      var fullScreenButton = new FullScreenButton();\r\n      var phetButton = new PhetButton( sim );\r\n      this.addChild( new HBox( {spacing: 10, children: [fullScreenButton, phetButton], right: this.layoutBounds.maxX - 5, bottom: this.layoutBounds.maxY - 5} ) );\r\n    }\r\n    else {\r\n      this.addChild( new PhetButton( sim, {phetLogo: 'phet-logo-short.svg', phetLogoScale: 0.4, optionsButtonVerticalMargin: 6} ).mutate( {right: this.layoutBounds.maxX - 5, bottom: this.layoutBounds.maxY - 5} ) );\r\n    }\r\n  }\r\n\r\n  return inherit( ScreenView, HomeScreen );\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n// Returns version identifier for the simulation.\r\ndefine( 'version',[],function() {\r\n  'use strict';\r\n  return function() { return '1.1.0-rc1'; };\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * A DerivedProperty is computed based on other properties.\r\n *\r\n * TODO: Inherit from ObservableProperty?\r\n * @author Sam Reid\r\n */\r\n\r\ndefine( 'AXON/DerivedProperty',['require','AXON/Property','AXON/axon'],function( require ) {\r\n  'use strict';\r\n\r\n  var Property = require( 'AXON/Property' );\r\n  var axon = require( 'AXON/axon' );\r\n\r\n  /**\r\n   * @param {Array<Property>} dependencies\r\n   * @param {Function} derivation function that expects args in the same order as dependencies\r\n   * @constructor\r\n   */\r\n  axon.DerivedProperty = function DerivedProperty( dependencies, derivation ) {\r\n\r\n    this.observers = [];\r\n    this.dependencies = dependencies;\r\n\r\n    var derivedProperty = this;\r\n\r\n    //When any of the dependencies change, see if the value has changed\r\n    //If the value has changed, send out notification.\r\n    //TODO: Move to prototype?\r\n    function update() {\r\n\r\n      //TODO: Could just re-evaluate the changed property instead of recomputing all of them, right?\r\n      var args = dependencies.map( function( property ) { return property.get(); } );\r\n      var newValue = derivation.apply( null, args );\r\n\r\n      //Send out notifications if the value has truly changed\r\n      if ( newValue !== derivedProperty._value ) {\r\n        var oldValue = derivedProperty._value;\r\n        derivedProperty._value = newValue; //Store the value so it can be compared against next time, and for the value getter\r\n        derivedProperty.observers.forEach( function( observer ) { observer( newValue, oldValue ); } );\r\n      }\r\n    }\r\n\r\n    this.update = update;\r\n\r\n    dependencies.forEach( function( property ) {\r\n      property.lazyLink( update );\r\n    } );\r\n\r\n    //TODO: Should we add an option to defer callbacks (like lazyLink?)\r\n\r\n    //Call the derivation function with the initial value(s)\r\n    update();\r\n  };\r\n\r\n  //TODO: _value could be made private if we moved these functions to the constructor, but I don't think it is necessary\r\n  axon.DerivedProperty.prototype = {\r\n\r\n    /**\r\n     * Get the current value of this DerivedProperty.\r\n     * @returns {*}\r\n     */\r\n    get value() {\r\n      return this._value;\r\n    },\r\n\r\n    get: function() {\r\n      return this._value;\r\n    },\r\n\r\n    /**\r\n     * Add an observer to this DerivedProperty\r\n     * @param observer\r\n     */\r\n    link: function( observer ) {\r\n      this.observers.push( observer );\r\n      observer( this._value );\r\n    },\r\n\r\n    /**\r\n     * Link to a target object's attribute, see Property.linkAttribute\r\n     * @param object\r\n     * @param attributeName\r\n     * @returns {Function}\r\n     */\r\n    linkAttribute: function( object, attributeName ) {\r\n      var handle = function( value ) {object[attributeName] = value;};\r\n      this.link( handle );\r\n      return handle;\r\n    },\r\n\r\n    unlink: function( observer ) {\r\n      var index = this.observers.indexOf( observer );\r\n      if ( index !== -1 ) {\r\n        this.observers.splice( index, index + 1 );\r\n      }\r\n    },\r\n\r\n    /**\r\n     * @see Property.lazyLink\r\n     * @param observer\r\n     */\r\n    lazyLink: function( observer ) {\r\n      this.observers.push( observer );\r\n    },\r\n\r\n    /**\r\n     * Detaches this derived property from its dependencies.\r\n     */\r\n    detach: function() {\r\n      var derivedProperty = this;\r\n      this.dependencies.forEach( function( property ) {\r\n        property.unlink( derivedProperty.update );\r\n      } );\r\n    }\r\n  };\r\n\r\n  return axon.DerivedProperty;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * PropertySet facilitates creation and use of multiple named Property instances.  There are still several API design issues in question, but this\r\n * class is ready for use.\r\n *\r\n * A PropertySet is a set of Property instances that provides support for:\r\n * -Easily creating several properties using an object literal (hash)\r\n * -Resetting them as a group\r\n * -Set multiple values at once, using propertySet.set({x:100,y:200,name:'alice'});\r\n * -Support for derived properties, which appear with the same interface as basic properties\r\n * -Convenient toString that prints e.g., PropertySet{name:'larry',age:101,kids:['alice','bob']}\r\n * -Wiring up to listen to multiple properties simultaneously\r\n * -Add properties after the PropertySet is created?  Don't forget to add to the key list as well.\r\n * -Remove properties that were added using addProperty or the constructor\r\n * -TODO: Make it easy to mix-in with model classes?  Subclassing PropertySet already works fairly well, so this may good enough already.\r\n * -TODO: Type checking, so that a boolean input will be automatically generated as BooleanProperty, etc.\r\n * -TODO: Should this be called Model or perhaps something even better?\r\n * -TODO: addProperty(DerivedProperty/Property)???  Perhaps overload it?  Let's wait on that until we need it.\r\n *\r\n * Sample usage:\r\n * var p = new PropertySet( {name: 'larry', age: 100, kids: ['alice', 'bob']} );\r\n * p.nameProperty.link( function( n ) {console.log( 'hello ' + n );} );\r\n * p.name = 'jensen';\r\n * p.age = 101;//Happy Birthday!\r\n * console.log( p );\r\n * p.reset();\r\n * console.log( p );\r\n * p.set({name:'clark',age:102,kids:['alice','bob','charlie']});\r\n * p.values = {name:'clark',age:102,kids:['alice','bob','charlie']}; //TODO: should we support this es5 way of doing it?  I kind of like it better than set\r\n *\r\n * How would this be done without PropertySet (for comparison)?\r\n * //Normally would be created in a class but that is omitted here for brevity.\r\n * var p ={name: new Property('larry'), age: new Property('age'), kids: new Property(['alice','bob'])}\r\n * p.reset = function(){\r\n *   this.name.reset(); \r\n *   this.age.reset();\r\n *   this.kids.reset();\r\n * }\r\n * p.name.set('clark');\r\n * p.age.set('102');\r\n * p.kids.set(['alice','bob','charlie']);\r\n *\r\n * @author Sam Reid\r\n */\r\n\r\ndefine( 'AXON/PropertySet',['require','AXON/Property','AXON/DerivedProperty','AXON/axon'],function( require ) {\r\n  'use strict';\r\n\r\n  var Property = require( 'AXON/Property' );\r\n  var DerivedProperty = require( 'AXON/DerivedProperty' );\r\n  var axon = require( 'AXON/axon' );\r\n\r\n  /**\r\n   * @class PropertySet\r\n   * @constructor\r\n   * @param values an object hash with the initial values for the properties\r\n   */\r\n  axon.PropertySet = function PropertySet( values ) {\r\n    var propertySet = this;\r\n\r\n    //Keep track of the keys so we know which to reset\r\n    this.keys = [];\r\n\r\n    Object.getOwnPropertyNames( values ).forEach( function( value ) {\r\n      propertySet.addProperty( value, values[value] );\r\n    } );\r\n\r\n    this.eventListeners = {};\r\n  };\r\n\r\n  axon.PropertySet.prototype = {\r\n\r\n    /**\r\n     * Adds a new property to this PropertySet\r\n     *\r\n     * @param {String} name\r\n     * @param value\r\n     */\r\n    addProperty: function( name, value ) {\r\n      this[name + 'Property'] = new Property( value );\r\n      this.addGetterAndSetter( name );\r\n      this.keys.push( name );\r\n    },\r\n\r\n    /**\r\n     * Remove any property (whether a derived property or not) that was added to this PropertySet\r\n     * @param name\r\n     */\r\n    removeProperty: function( name ) {\r\n\r\n      //Remove from the keys (only for non-derived properties)\r\n      var index = this.keys.indexOf( name );\r\n      if ( index !== -1 ) {\r\n        this.keys.splice( index, index + 1 );\r\n      }\r\n\r\n      //Unregister the Property instance from the PropertySet\r\n      delete this[name + 'Property'];\r\n\r\n      //Unregister the getter/setter, if they exist\r\n      delete this[name];\r\n    },\r\n\r\n    //Taken from https://gist.github.com/dandean/1292057, same as in github/Atlas\r\n    addGetterAndSetter: function( name ) {\r\n      var propertyName = name + 'Property';\r\n\r\n      //TODO: Store the this[propertyName] in a closure for performance?  Memory/performance tradeoff, and problems if the property instance ever changes (unlikely)\r\n      //TODO: If a subclass ever substitutes a property like this: person.ageProperty = new Property(person.age), then it would break the getter/setter\r\n      Object.defineProperty( this, name, {\r\n\r\n        // Getter proxies to Model#get()...\r\n        get: function() { return this[propertyName].get();},\r\n\r\n        // Setter proxies to Model#set(attributes)\r\n        set: function( value ) { this[propertyName].set( value );},\r\n\r\n        // Make it configurable and enumerable so it's easy to override...\r\n        configurable: true,\r\n        enumerable: true\r\n      } );\r\n    },\r\n\r\n    addGetter: function( name ) {\r\n\r\n      //TODO: Store the this[propertyName] for performance?\r\n      var propertyName = name + 'Property';\r\n      Object.defineProperty( this, name, {\r\n\r\n        get: function() { return this[propertyName].get();},\r\n\r\n        // Make it configurable and enumerable so it's easy to override...\r\n        configurable: true,\r\n        enumerable: true\r\n      } );\r\n    },\r\n\r\n    //Resets all of the properties associated with this PropertySet \r\n    reset: function() {\r\n      var propertySet = this;\r\n      this.keys.forEach( function( key ) {\r\n        propertySet[key + 'Property'].reset();\r\n      } );\r\n    },\r\n\r\n    /**\r\n     * Creates a DerivedProperty from the given dependency names and derivation.\r\n     * @param dependencyNames {Array<String>}\r\n     * @param derivation {Function}\r\n     * @returns {DerivedProperty}\r\n     */\r\n    toDerivedProperty: function( dependencyNames, derivation ) {\r\n      var propertySet = this;\r\n      var dependencies = dependencyNames.map( function( dependency ) {\r\n        return propertySet[dependency + 'Property'];\r\n      } );\r\n      return new DerivedProperty( dependencies, derivation );\r\n    },\r\n\r\n    addDerivedProperty: function( name, dependencyNames, derivation ) {\r\n      this[name + 'Property'] = this.toDerivedProperty( dependencyNames, derivation );\r\n      this.addGetter( name );\r\n    },\r\n\r\n    /**\r\n     * Set all of the values specified in the object hash\r\n     * Allows you to use this form:\r\n     * puller.set( {x: knot.x, y: knot.y, knot: knot} );\r\n     *\r\n     * instead of this:\r\n     * puller.x.value = knot.x;\r\n     * puller.y.value = knot.y;\r\n     * puller.knot.value = knot;\r\n     *\r\n     * Throws an error if you try to set a value for which there is no property.\r\n     */\r\n    set: function( values ) {\r\n      var propertySet = this;\r\n      Object.getOwnPropertyNames( values ).forEach( function( val ) {\r\n        if ( typeof(propertySet[val + 'Property'] === 'Property') ) {\r\n          propertySet[val + 'Property'].set( values[val] );\r\n        }\r\n        else {\r\n          throw new Error( 'property not found: ' + val );\r\n        }\r\n      } );\r\n    },\r\n\r\n    /**\r\n     * Add a listener to zero or more properties in this PropertySet, useful when you have an update function\r\n     * that relies on several properties.  Similar to DerivedProperty.\r\n     * TODO: Should this be named link because it won't clash with any other methods on this class?\r\n     *  Discussion result: Let's use 'multilink' for now, and in the future we may change it to link.\r\n     * @param dependencyNames {Array<String>} the list of dependencies to use\r\n     * @param listener {Function} the listener to call back, with signature matching the dependency names\r\n     */\r\n    multilink: function( dependencyNames, listener ) {\r\n      return this.toDerivedProperty( dependencyNames, listener );\r\n    },\r\n\r\n    /**\r\n     * Removes the multilinked listener from this PropertySet.\r\n     * Same as calling detach() on the handle (which happens to be a DerivedProperty instance)\r\n     * @param derivedProperty\r\n     */\r\n    unmultilink: function( derivedProperty ) {\r\n      derivedProperty.detach();\r\n    },\r\n\r\n    toString: function() {\r\n      var text = 'PropertySet{';\r\n      var propertySet = this;\r\n      for ( var i = 0; i < this.keys.length; i++ ) {\r\n        var key = this.keys[i];\r\n        text = text + key + ':' + propertySet[key].toString();\r\n        if ( i < this.keys.length - 1 ) {\r\n          text = text + ',';\r\n        }\r\n      }\r\n      return text + '}';\r\n    },\r\n\r\n    /////////////////////////////////////////////\r\n    // Below this point are the functions for event handling, basically orthogonal to property value change notifications\r\n\r\n    /**\r\n     * Register a listener when the specified eventName is triggered.\r\n     * @param eventName {String} the name for the event channel\r\n     * @param callback\r\n     */\r\n    on: function( eventName, callback ) {\r\n      this.eventListeners[eventName] = this.eventListeners[eventName] || [];\r\n      this.eventListeners[eventName].push( callback );\r\n    },\r\n\r\n    /**\r\n     * Adds a function which will only be called back once, after which it is removed as a listener.\r\n     * If you need to remove a function added with 'once' you will have to remove its handle, which is returned by the function.\r\n     * @param eventName {String} the name for the event channel\r\n     * @param callback function to be called back once (if at all)\r\n     */\r\n    once: function( eventName, callback ) {\r\n      var propertySet = this;\r\n      var wrappedCallback = function() {\r\n        propertySet.off( eventName, wrappedCallback );\r\n\r\n        //If no arguments being passed through, call back without processing arguments, for possible speed\r\n        if ( arguments.length === 0 ) {\r\n          callback();\r\n        }\r\n        else {\r\n\r\n          //General case of passing events through to the wrapped callback function\r\n          callback.apply( this, Array.prototype.slice.call( arguments, 0 ) );\r\n        }\r\n      };\r\n      this.on( eventName, wrappedCallback );\r\n\r\n      //Return the handle in case it needs to be removed.\r\n      return wrappedCallback;\r\n    },\r\n\r\n    /**\r\n     * Remove a listener from the specified event type.  Does nothing if the listener did not exist\r\n     * @param eventName {String} the name for the event channel\r\n     * @param callback\r\n     */\r\n    off: function( eventName, callback ) {\r\n      if ( this.eventListeners[eventName] ) {\r\n        var index = this.eventListeners[eventName].indexOf( callback );\r\n        if ( index !== -1 ) {\r\n          this.eventListeners[eventName].splice( index, index + 1 );\r\n        }\r\n      }\r\n    },\r\n\r\n    /**\r\n     * Trigger an event with the specified name and arguments.\r\n     * @param eventName {String} the name for the event channel\r\n     * @param args... optional arguments to pass to the listeners\r\n     */\r\n    trigger: function( eventName ) {\r\n      if ( this.eventListeners[eventName] ) {\r\n        var listenersCopy = this.eventListeners[eventName].slice(); // make a copy, in case callback removes listener\r\n        for ( var i = 0; i < listenersCopy.length; i++ ) {\r\n          var listener = listenersCopy[i];\r\n\r\n          //Simple case of no arguments, call it separately for improved performance in case it is faster (untested)\r\n          if ( arguments.length === 1 ) {\r\n            listener( arguments );\r\n          }\r\n          else {\r\n            var suffix = Array.prototype.slice.call( arguments, 1 );\r\n            listener.apply( this, suffix );\r\n          }\r\n        }\r\n      }\r\n    }\r\n  };\r\n\r\n  return axon.PropertySet;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * This model implementation tracks the location of the pointer(s), if any, so they can be visualized during playback.\r\n *\r\n * @author Sam Reid (PhET Interactive Simulations)\r\n */\r\ndefine( 'JOIST/share/Pointer',['require'],function( require ) {\r\n  'use strict';\r\n\r\n  function Pointer() {}\r\n\r\n  return Pointer;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * This model implementation tracks the location of the pointer(s), if any, so they can be visualized during playback.\r\n *\r\n * @author Sam Reid (PhET Interactive Simulations)\r\n */\r\ndefine( 'JOIST/share/Pointers',['require','JOIST/share/Pointer'],function( require ) {\r\n  'use strict';\r\n\r\n  var Pointer = require( 'JOIST/share/Pointer' );\r\n\r\n  //TODO: make it an observable array \r\n  return [];\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * This model implementation tracks the location of the pointer(s), if any, so they can be visualized during playback.\r\n *\r\n * @author Sam Reid (PhET Interactive Simulations)\r\n */\r\ndefine( 'JOIST/share/LogPointers',['require','JOIST/share/Pointer','JOIST/share/Pointers'],function( require ) {\r\n  'use strict';\r\n\r\n  var Pointer = require( 'JOIST/share/Pointer' );\r\n  var Pointers = require( 'JOIST/share/Pointers' );\r\n\r\n  function LogPointers() {\r\n\r\n    //Set up data logging and visualization\r\n    this.pointers = new Pointers();\r\n  }\r\n\r\n  LogPointers.prototype = {\r\n    startLogging: function() {\r\n      var logPointers = this;\r\n      window.addEventListener( 'mousemove', function( e ) {\r\n        var location = {x: e.clientX, y: e.clientY};\r\n        if ( logPointers.pointers.length === 0 ) {\r\n          logPointers.pointers.add( new Pointer( location ) );\r\n        }\r\n        else {\r\n          logPointers.pointers.at( 0 ).set( location );\r\n        }\r\n      }, false );\r\n      window.addEventListener( 'touchmove', function( e ) {\r\n        var touches = e.touches;\r\n        for ( var i = 0; i < touches.length; i++ ) {\r\n          var touch = touches[i];\r\n          var location = {x: touch.pageX, y: touch.pageY};\r\n          if ( i >= logPointers.pointers.length ) {\r\n            logPointers.pointers.add( new Pointer( location ) );\r\n          }\r\n          else {\r\n            logPointers.pointers.at( i ).set( location );\r\n          }\r\n        }\r\n        while ( logPointers.pointers.length > touches.length ) {\r\n          logPointers.pointers.pop();\r\n        }\r\n      }, false );\r\n\r\n      //TODO: add touchend support\r\n    },\r\n    showPointers: function() {\r\n      var logPointers = this;\r\n      this.pointers.on( 'add', function( model, collection, options ) {\r\n        var $img = $( '<img id=\"cursor\">' ); //Equivalent: $(document.createElement('img'))\r\n        $img.attr( 'src', 'http://dc440.4shared.com/img/mFJBl0A0/s7/mouse-cursor-icon.png' ); //TODO: our own copy of the image\r\n        $img.css( {zIndex: 9999, position: 'absolute', width: 12, height: 20, 'pointer-events': 'none'} );\r\n        $img.appendTo( 'body' );\r\n        model.on( 'change:x change:y', function() {\r\n          $img.css( {left: model.x, top: model.y} );\r\n        } );\r\n\r\n        logPointers.pointers.on( 'remove', function( m, c, o ) {\r\n          if ( m === model ) {\r\n            $img.detach();\r\n            //TODO: clean up listeners?\r\n          }\r\n        } );\r\n      } );\r\n    }\r\n  };\r\n\r\n  return LogPointers;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Main class that represents one simulation.\r\n * Provides default initialization, such as polyfills as well.\r\n * If the simulation has only one screen, then there is no homescreen, home icon or screen icon in the navigation bar.\r\n *\r\n * @author Sam Reid\r\n */\r\ndefine( 'JOIST/Sim',['require','SCENERY/util/Util','JOIST/NavigationBar','JOIST/HomeScreen','SCENERY/Scene','SCENERY/nodes/Node','SCENERY/nodes/Text','DOT/Vector2','DOT/Bounds2','version','AXON/PropertySet','SCENERY_PHET/PhetFont','AXON/log','JOIST/share/LogPointers'],function( require ) {\r\n  'use strict';\r\n\r\n  var Util = require( 'SCENERY/util/Util' );\r\n  var NavigationBar = require( 'JOIST/NavigationBar' );\r\n  var HomeScreen = require( 'JOIST/HomeScreen' );\r\n  var Scene = require( 'SCENERY/Scene' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n  var Bounds2 = require( 'DOT/Bounds2' );\r\n  var version = require( 'version' );\r\n  var PropertySet = require( 'AXON/PropertySet' );\r\n  var PhetFont = require( 'SCENERY_PHET/PhetFont' );\r\n\r\n  //For Data logging and visualization\r\n  var log = require( 'AXON/log' );\r\n  var LogPointers = require( 'JOIST/share/LogPointers' );\r\n\r\n  /**\r\n   * @param {String} name\r\n   * @param {Array<Screen>} screens\r\n   * @param options optional parameters for starting screen and home values, so that developers can easily specify the startup scenario for quick development\r\n   * @constructor\r\n   */\r\n  function Sim( name, screens, options ) {\r\n\r\n    options = _.extend( { showHomeScreen: true, screenIndex: 0, standalone: false, credits: '', thanks: '' }, options );\r\n    this.options = options; // store this for access from prototype functions, assumes that it won't be changed later\r\n\r\n    var sim = this;\r\n    window.sim = sim;\r\n\r\n    sim.name = name;\r\n    sim.version = version();\r\n    sim.credits = options.credits;\r\n    sim.thanks = options.thanks;\r\n\r\n    sim.frameCounter = 0; // number of animation frames that have occurred\r\n\r\n    sim.inputEventLog = []; // used to store input events and requestAnimationFrame cycles\r\n    sim.inputEventBounds = Bounds2.NOTHING;\r\n\r\n    // state for mouse event fuzzing\r\n    sim.fuzzMouseAverage = 10; // average number of mouse events to synthesize per frame\r\n    sim.fuzzMouseIsDown = false;\r\n    sim.fuzzMousePosition = new Vector2(); // start at 0,0\r\n    sim.fuzzMouseLastMoved = false; // whether the last mouse event was a move (we skew probabilities based on this)\r\n\r\n    //Set the HTML page title to the localized title\r\n    //TODO: When a sim is embedded on a page, we shouldn't retitle the page\r\n    $( 'title' ).html( name + ' ' + sim.version ); //TODO i18n of order\r\n\r\n    //if nothing else specified, try to use the options for showHomeScreen & screenIndex from query parameters, to facilitate testing easily in different screens\r\n    function stringToBoolean( string ) { return string === 'true' ? true : false; }\r\n\r\n    // Query parameters override options.\r\n    if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'showHomeScreen' ) ) {\r\n      options.showHomeScreen = stringToBoolean( window.phetcommon.getQueryParameter( 'showHomeScreen' ) );\r\n    }\r\n    if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'screenIndex' ) ) {\r\n      options.screenIndex = parseInt( window.phetcommon.getQueryParameter( 'screenIndex' ), 10 );\r\n    }\r\n    if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'recordInputEventLog' ) ) {\r\n      // enables recording of Scenery's input events, request animation frames, and dt's so the sim can be played back\r\n      options.recordInputEventLog = true;\r\n      options.inputEventLogName = window.phetcommon.getQueryParameter( 'recordInputEventLog' );\r\n    }\r\n    if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'playbackInputEventLog' ) ) {\r\n      // instead of loading like normal, download a previously-recorded event sequence and play it back (unique to the browser and window size)\r\n      options.playbackInputEventLog = true;\r\n      options.inputEventLogName = window.phetcommon.getQueryParameter( 'playbackInputEventLog' );\r\n    }\r\n    if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'fuzzMouse' ) ) {\r\n      // ignore any user input events, and instead fire mouse events randomly in an effort to cause an exception\r\n      options.fuzzMouse = true;\r\n      if ( window.phetcommon.getQueryParameter( 'fuzzMouse' ) !== 'undefined' ) {\r\n        sim.fuzzMouseAverage = parseFloat( window.phetcommon.getQueryParameter( 'fuzzMouse' ) );\r\n      }\r\n    }\r\n    if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'fuzzTouches' ) ) {\r\n      // ignore any user input events, and instead fire touch events randomly in an effort to cause an exception\r\n      options.fuzzTouches = true;\r\n    }\r\n\r\n    //If specifying 'standalone' then filter the screens array so that it is just the selected screenIndex\r\n    if ( window.phetcommon && window.phetcommon.getQueryParameter && window.phetcommon.getQueryParameter( 'standalone' ) ) {\r\n      options.standalone = true;\r\n      screens = [screens[options.screenIndex]];\r\n      options.screenIndex = 0;\r\n    }\r\n\r\n    //Default values are to show the home screen with the 1st screen selected\r\n    var showHomeScreen = ( _.isUndefined( options.showHomeScreen ) ) ? true : options.showHomeScreen;\r\n\r\n    //If there is only one screen, do not show the home screen\r\n    if ( screens.length === 1 ) {\r\n      showHomeScreen = false;\r\n    }\r\n\r\n    sim.screens = screens;\r\n\r\n    //This model represents where the simulation is, whether it is on the home screen or a screen, and which screen it is on or is highlighted in the homescreen\r\n    sim.simModel = new PropertySet( {showHomeScreen: showHomeScreen, screenIndex: options.screenIndex || 0 } );\r\n\r\n    var $body = $( 'body' );\r\n    $body.css( 'padding', '0' ).css( 'margin', '0' ).css( 'overflow', 'hidden' ); // prevent scrollbars\r\n\r\n    //TODO should probably look for this div to see if it exists, then create only if it doesn't exist.\r\n    //Add a div for the sim to the DOM\r\n    var $simDiv = $( '<div>' ).attr( 'id', 'sim' ).css( 'position', 'absolute' ).css( 'left', 0 ).css( 'top', 0 );\r\n    $body.append( $simDiv );\r\n\r\n    //Create the scene\r\n    //Leave accessibility as a flag while in development\r\n    sim.scene = new Scene( $simDiv, {allowDevicePixelRatioScaling: false, accessible: true} );\r\n    sim.scene.sim = sim; // add a reference back to the simulation\r\n    sim.scene.initializeWindowEvents( { batchDOMEvents: true } ); // sets up listeners on the document with preventDefault(), and forwards those events to our scene\r\n    if ( options.recordInputEventLog ) {\r\n      sim.scene.input.logEvents = true; // flag Scenery to log all input events\r\n    }\r\n    window.simScene = sim.scene; // make the scene available for debugging\r\n\r\n    sim.navigationBar = new NavigationBar( sim, screens, sim.simModel );\r\n\r\n    if ( screens.length > 1 ) {\r\n      sim.homeScreen = new HomeScreen( sim );\r\n    }\r\n\r\n    //The simNode contains the home screen or the play area\r\n    var simNode = new Node();\r\n\r\n    //The viewContainer contains the ScreenView itself, which will be swapped out based on which icon the user selected in the navigation bar.\r\n    //Without this layerSplit, the performance significantly declines on both Win8/Chrome and iPad3/Safari\r\n    //TODO: Test this after rewriting into multiple divs/scenes\r\n    var viewContainer = new Node( {layerSplit: true} );\r\n\r\n    var updateBackground = function() {\r\n      if ( sim.simModel.showHomeScreen ) {\r\n        $simDiv.css( 'background', 'black' );\r\n      }\r\n      else {\r\n        var backgroundColor = screens[sim.simModel.screenIndex].backgroundColor || 'white';\r\n        var cssColor = ( typeof backgroundColor === 'string' ) ? backgroundColor :  backgroundColor.toCSS();\r\n        $simDiv.css( 'background', cssColor );\r\n      }\r\n    };\r\n\r\n    //When the user presses the home icon, then show the homescreen, otherwise show the screen.\r\n    sim.simModel.showHomeScreenProperty.link( function( showHomeScreen ) {\r\n      simNode.children = showHomeScreen ? [] : [viewContainer];\r\n      if ( showHomeScreen ) {\r\n        sim.scene.children = [sim.homeScreen];\r\n      }\r\n      else {\r\n        sim.scene.children = [simNode, sim.navigationBar];\r\n      }\r\n      updateBackground();\r\n    } );\r\n\r\n    //Instantiate the screens\r\n    //Currently this is done eagerly, but this pattern leaves open the door for loading things in the background.\r\n    _.each( screens, function( m ) {\r\n      m.model = m.createModel();\r\n      m.view = m.createView( m.model );\r\n    } );\r\n\r\n    //SR: ModuleIndex should always be defined.  On startup screenIndex=0 to highlight the 1st screen.\r\n    //    When moving from a screen to the homescreen, the previous screen should be highlighted\r\n    //When the user selects a different screen, show it.\r\n    sim.simModel.screenIndexProperty.link( function( screenIndex ) {\r\n      viewContainer.children = [screens[screenIndex].view];\r\n      updateBackground();\r\n    } );\r\n\r\n    updateBackground();\r\n\r\n    //Fit to the window and render the initial scene\r\n    $( window ).resize( function() { sim.resizeToWindow(); } );\r\n    sim.resizeToWindow();\r\n  }\r\n\r\n  Sim.prototype.resizeToWindow = function() {\r\n    //TODO: This will have to change when sims are embedded on a page instead of taking up an entire page\r\n    this.resize( $( window ).width(), $( window ).height() );\r\n  };\r\n\r\n  Sim.prototype.resize = function( width, height ) {\r\n    var sim = this;\r\n\r\n    //Use Mobile Safari layout bounds to size the home screen and navigation bar\r\n    var scale = Math.min( width / 768, height / 504 );\r\n\r\n    //40 px high on Mobile Safari\r\n    var navBarHeight = scale * 40;\r\n    sim.navigationBar.layout( scale, width, navBarHeight, height );\r\n    sim.navigationBar.y = height - navBarHeight;\r\n    sim.scene.resize( width, height );\r\n\r\n    //Layout each of the screens\r\n    _.each( sim.screens, function( m ) { m.view.layout( width, height - sim.navigationBar.height ); } );\r\n\r\n    if ( sim.homeScreen ) {\r\n      sim.homeScreen.layout( width, height );\r\n    }\r\n    //Startup can give spurious resizes (seen on ipad), so defer to the animation loop for painting\r\n\r\n    sim.scene.input.eventLog.push( 'scene.sim.resize(' + width + ',' + height + ');' );\r\n  };\r\n\r\n  Sim.prototype.start = function() {\r\n    var sim = this;\r\n\r\n    // if the playback flag is set, don't start up like normal. instead download our event log from the server and play it back.\r\n    // if direct playback (copy-paste) is desired, please directly call sim.startInputEventPlayback( ... ) instead of sim.start().\r\n    if ( this.options.playbackInputEventLog ) {\r\n      var request = new XMLHttpRequest();\r\n      request.open( 'GET', this.getEventLogLocation(), true );\r\n      request.onload = function( e ) {\r\n        // we create functions, so eval is necessary. we go to the loaded domain on a non-standard port, so cross-domain issues shouldn't present themselves\r\n        /* jshint -W061 */\r\n        sim.startInputEventPlayback( eval( request.responseText ) );\r\n      };\r\n      request.send();\r\n      return;\r\n    }\r\n\r\n    //Keep track of the previous time for computing dt, and initially signify that time hasn't been recorded yet.\r\n    var lastTime = -1;\r\n\r\n    //Make sure requestAnimationFrame is defined\r\n    Util.polyfillRequestAnimationFrame();\r\n\r\n    //Record the pointers (if logging is enabled)\r\n//    var logPointers = new LogPointers();\r\n//    logPointers.startLogging();\r\n//\r\n//    //For debugging, display the pointers\r\n//    logPointers.showPointers();\r\n\r\n    // place the rAF *before* the render() to assure as close to 60fps with the setTimeout fallback.\r\n    //http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n    (function animationLoop() {\r\n      var dt;\r\n\r\n      // increment this before we can have an exception thrown, to see if we are missing frames\r\n      sim.frameCounter++;\r\n\r\n      window.requestAnimationFrame( animationLoop );\r\n\r\n      // fire or synthesize input events\r\n      if ( sim.options.fuzzMouse ) {\r\n        sim.fuzzMouseEvents();\r\n      }\r\n      else if ( sim.options.fuzzTouches ) {\r\n        // TODO: we need more state tracking of individual touch points to do this properly\r\n      }\r\n      else {\r\n        // if any input events were received and batched, fire them now.\r\n        sim.scene.fireBatchedEvents();\r\n      }\r\n\r\n      //Update the active screen, but not if the user is on the home screen\r\n      if ( !sim.simModel.showHomeScreen ) {\r\n\r\n        //Compute the elapsed time since the last frame, or guess 1/60th of a second if it is the first frame\r\n        var time = Date.now();\r\n        var elapsedTimeMilliseconds = (lastTime === -1) ? (1000.0 / 60.0) : (time - lastTime);\r\n        lastTime = time;\r\n\r\n        //Convert to seconds\r\n        dt = elapsedTimeMilliseconds / 1000.0;\r\n        sim.screens[sim.simModel.screenIndex].model.step( dt );\r\n      }\r\n\r\n      //If using the TWEEN animation library, then update all of the tweens (if any) before rendering the scene.\r\n      //Update the tweens after the model is updated but before the scene is redrawn.\r\n      if ( window.TWEEN ) {\r\n        window.TWEEN.update();\r\n      }\r\n      if ( sim.options.recordInputEventLog ) {\r\n        // push a frame entry into our inputEventLog\r\n        var entry = {\r\n          dt: dt,\r\n          events: sim.scene.input.eventLog,\r\n          id: sim.frameCounter,\r\n          time: Date.now()\r\n        };\r\n        if ( !sim.inputEventBounds.equals( sim.scene.sceneBounds ) ) {\r\n          sim.inputEventBounds = sim.scene.sceneBounds.copy();\r\n\r\n          entry.width = sim.scene.sceneBounds.width;\r\n          entry.height = sim.scene.sceneBounds.height;\r\n        }\r\n        sim.inputEventLog.push( entry );\r\n        sim.scene.input.eventLog = []; // clears the event log so that future actions will fill it\r\n      }\r\n      sim.scene.updateScene();\r\n    })();\r\n  };\r\n\r\n  Sim.prototype.startPlayback = function( logArray ) {\r\n    var sim = this;\r\n    var logIndex = 0;\r\n    var playbackTime = logArray[0].time;\r\n\r\n    //Make sure requestAnimationFrame is defined\r\n    Util.polyfillRequestAnimationFrame();\r\n\r\n    //Display the pointers\r\n//    new LogPointers().showPointers();\r\n    var totalTime = 0;\r\n\r\n    // place the rAF *before* the render() to assure as close to 60fps with the setTimeout fallback.\r\n    //http://paulirish.com/2011/requestanimationframe-for-smart-animating/\r\n    (function animationLoop() {\r\n      if ( logIndex >= logArray.length ) {\r\n        console.log( totalTime );\r\n\r\n        sim.scene.addChild( new Text( 'Elapsed time (ms): ' + totalTime, {x: 100, y: 100, font: new PhetFont( 32 ) } ) );\r\n        sim.scene.updateScene();\r\n        return;\r\n      }\r\n\r\n      window.requestAnimationFrame( animationLoop );\r\n\r\n      var start = Date.now();\r\n      //Update the sim based on the given log\r\n      logIndex = log.stepUntil( logArray, playbackTime, logIndex );\r\n\r\n      playbackTime += 17;//ms between frames at 60fp\r\n\r\n      sim.scene.updateScene();\r\n      var stop = Date.now();\r\n      var elapsed = (stop - start);\r\n\r\n      totalTime += elapsed;\r\n    })();\r\n  };\r\n\r\n  // Plays back input events and updateScene() loops based on recorded data. data should be an array of objects (representing frames) with dt and fireEvents( scene, dot )\r\n  Sim.prototype.startInputEventPlayback = function( data ) {\r\n    var sim = this;\r\n\r\n    var index = 0; // our index into our frame data.\r\n\r\n    //Make sure requestAnimationFrame is defined\r\n    Util.polyfillRequestAnimationFrame();\r\n\r\n    if ( data.length && data[0].width ) {\r\n      sim.resize( data[0].width, data[0].height );\r\n    }\r\n\r\n    var startTime = Date.now();\r\n\r\n    (function animationLoop() {\r\n      var frame = data[index++];\r\n\r\n      // when we have aready played the last frame\r\n      if ( frame === undefined ) {\r\n        var endTime = Date.now();\r\n\r\n        var elapsedTime = endTime - startTime;\r\n        var fps = data.length / ( elapsedTime / 1000 );\r\n\r\n        // replace the page with a performance message\r\n        document.body.innerHTML = '<div style=\"text-align: center; font-size: 16px;\">' +\r\n                                  '<h1>Performance results:</h1>' +\r\n                                  '<p>Approximate frames per second: <strong>' + fps.toFixed( 1 ) + '</strong></p>' +\r\n                                  '<p>Average time per frame (ms/frame): <strong>' + (elapsedTime / index).toFixed( 1 ) + '</strong></p>' +\r\n                                  '<p>Elapsed time: <strong>' + elapsedTime + 'ms</strong></p>' +\r\n                                  '<p>Number of frames: <strong>' + index + '</strong></p>' +\r\n                                  '</div>';\r\n\r\n        // ensure that the black text is readable (chipper-built sims have a black background right now)\r\n        document.body.style.backgroundColor = '#fff';\r\n\r\n        // bail before the requestAnimationFrame if we are at the end (stops the frame loop)\r\n        return;\r\n      }\r\n\r\n      window.requestAnimationFrame( animationLoop );\r\n\r\n      // we don't fire batched input events (prevents them from affecting unit/performance tests).\r\n      // instead, we fire pre-recorded events for the scene if it exists (left out for brevity when not necessary)\r\n      if ( frame.fireEvents ) { frame.fireEvents( sim.scene, function( x, y ) { return new Vector2( x, y ); } ); }\r\n\r\n      //Update the active screen, but not if the user is on the home screen\r\n      if ( !sim.simModel.showHomeScreen ) {\r\n        sim.screens[sim.simModel.screenIndex].model.step( frame.dt ); // use the pre-recorded dt to ensure lack of variation between runs\r\n      }\r\n\r\n      //If using the TWEEN animation library, then update all of the tweens (if any) before rendering the scene.\r\n      //Update the tweens after the model is updated but before the scene is redrawn.\r\n      if ( window.TWEEN ) {\r\n        window.TWEEN.update();\r\n      }\r\n      sim.scene.updateScene();\r\n    })();\r\n  };\r\n\r\n  Sim.prototype.addChild = function( node ) {\r\n    this.scene.addChild( node );\r\n  };\r\n\r\n  // A string that should be evaluated as JavaScript containing an array of \"frame\" objects, with a dt and an optional fireEvents function\r\n  Sim.prototype.getRecordedInputEventLogString = function() {\r\n    return '[\\n' + _.map( this.inputEventLog,function( item ) {\r\n      var fireEvents = 'fireEvents:function(scene,dot){' + _.map( item.events,function( str ) { return 'scene.input.' + str; } ).join( '' ) + '}';\r\n      return '{dt:' + item.dt + ( item.events.length ? ',' + fireEvents : '' ) + ( item.width ? ',width:' + item.width : '' ) + ( item.height ? ',height:' + item.height : '' ) +\r\n             ',id:' + item.id + ',time:' + item.time + '}';\r\n    } ).join( ',\\n' ) + '\\n]';\r\n  };\r\n\r\n  // For recording and playing back input events, we use a unique combination of the user agent, width and height, so the same\r\n  // server can test different recorded input events on different devices/browsers (desired, because events and coordinates are different)\r\n  Sim.prototype.getEventLogName = function() {\r\n    var name = this.options.inputEventLogName;\r\n    if ( name === 'browser' ) {\r\n      name = window.navigator.userAgent;\r\n    }\r\n    return ( this.name + '_' + name ).replace( /[^a-zA-Z0-9]/g, '_' );\r\n  };\r\n\r\n  // protocol-relative URL to the same-origin on a different port, for loading/saving recorded input events and frames\r\n  Sim.prototype.getEventLogLocation = function() {\r\n    var host = window.location.host.split( ':' )[0]; // grab the hostname without the port\r\n    return '//' + host + ':8083/' + this.getEventLogName();\r\n  };\r\n\r\n  // submits a recorded event log to the same-origin server (run scenery/tests/event-logs/server/server.js with Node, from the same directory)\r\n  Sim.prototype.submitEventLog = function() {\r\n    // if we aren't recording data, don't submit any!\r\n    if ( !this.options.recordInputEventLog ) { return; }\r\n\r\n    var data = this.getRecordedInputEventLogString();\r\n\r\n    var xmlhttp = new XMLHttpRequest();\r\n    xmlhttp.open( 'POST', this.getEventLogLocation(), true ); // use a protocol-relative port to send it to Scenery's local event-log server\r\n    xmlhttp.setRequestHeader( 'Content-type', 'text/javascript' );\r\n    xmlhttp.send( data );\r\n  };\r\n\r\n  // submits a recorded event log to the same-origin server (run scenery/tests/event-logs/server/server.js with Node, from the same directory)\r\n  Sim.prototype.mailEventLog = function() {\r\n    // if we aren't recording data, don't submit any!\r\n    if ( !this.options.recordInputEventLog ) { return; }\r\n\r\n    var data = this.getRecordedInputEventLogString();\r\n\r\n    window.open( 'mailto:phethelp@colorado.edu?subject=' + encodeURIComponent( this.name + ' input event log at ' + Date.now() ) + '&body=' + encodeURIComponent( data ) );\r\n  };\r\n\r\n  Sim.prototype.fuzzMouseEvents = function() {\r\n    var sim = this;\r\n\r\n    var chance;\r\n    // run a variable number of events, with a certain chance of bailing out (so no events are possible)\r\n    // models a geometric distribution of events\r\n    while ( ( chance = Math.random() ) < 1 - 1 / sim.fuzzMouseAverage ) {\r\n      var domEvent;\r\n      if ( chance < ( sim.fuzzMouseLastMoved ? 0.02 : 0.4 ) ) {\r\n        // toggle up/down\r\n        domEvent = document.createEvent( 'MouseEvent' ); // not 'MouseEvents' according to DOM Level 3 spec\r\n\r\n        // technically deprecated, but DOM4 event constructors not out yet. people on #whatwg said to use it\r\n        domEvent.initMouseEvent( sim.fuzzMouseIsDown ? 'mouseup' : 'mousedown', true, true, window, 1, // click count\r\n          sim.fuzzMousePosition.x, sim.fuzzMousePosition.y, sim.fuzzMousePosition.x, sim.fuzzMousePosition.y,\r\n          false, false, false, false,\r\n          0, // button\r\n          null );\r\n\r\n        sim.scene.input.validatePointers();\r\n\r\n        if ( sim.fuzzMouseIsDown ) {\r\n          sim.scene.input.mouseUp( sim.fuzzMousePosition, domEvent );\r\n          sim.fuzzMouseIsDown = false;\r\n        }\r\n        else {\r\n          sim.scene.input.mouseDown( sim.fuzzMousePosition, domEvent );\r\n          sim.fuzzMouseIsDown = true;\r\n        }\r\n      }\r\n      else {\r\n        // change the mouse position\r\n        sim.fuzzMousePosition = new Vector2(\r\n          Math.floor( Math.random() * sim.scene.sceneBounds.width ),\r\n          Math.floor( Math.random() * sim.scene.sceneBounds.height )\r\n        );\r\n\r\n        // our move event\r\n        domEvent = document.createEvent( 'MouseEvent' ); // not 'MouseEvents' according to DOM Level 3 spec\r\n\r\n        // technically deprecated, but DOM4 event constructors not out yet. people on #whatwg said to use it\r\n        domEvent.initMouseEvent( 'mousemove', true, true, window, 0, // click count\r\n          sim.fuzzMousePosition.x, sim.fuzzMousePosition.y, sim.fuzzMousePosition.x, sim.fuzzMousePosition.y,\r\n          false, false, false, false,\r\n          0, // button\r\n          null );\r\n\r\n        sim.scene.input.validatePointers();\r\n        sim.scene.input.mouseMove( sim.fuzzMousePosition, domEvent );\r\n      }\r\n    }\r\n  };\r\n\r\n  return Sim;\r\n} );\r\n","\n/**\r\n * @license RequireJS i18n 2.0.2 Copyright (c) 2010-2012, The Dojo Foundation All Rights Reserved.\r\n * Available via the MIT or new BSD license.\r\n * see: http://github.com/requirejs/i18n for details\r\n */\r\n/*jslint regexp: true */\r\n/*global require: false, navigator: false, define: false */\r\n\r\n/**\r\n * This plugin handles i18n! prefixed modules. It does the following:\r\n *\r\n * 1) A regular module can have a dependency on an i18n bundle, but the regular\r\n * module does not want to specify what locale to load. So it just specifies\r\n * the top-level bundle, like \"i18n!nls/colors\".\r\n *\r\n * This plugin will load the i18n bundle at nls/colors, see that it is a root/master\r\n * bundle since it does not have a locale in its name. It will then try to find\r\n * the best match locale available in that master bundle, then request all the\r\n * locale pieces for that best match locale. For instance, if the locale is \"en-us\",\r\n * then the plugin will ask for the \"en-us\", \"en\" and \"root\" bundles to be loaded\r\n * (but only if they are specified on the master bundle).\r\n *\r\n * Once all the bundles for the locale pieces load, then it mixes in all those\r\n * locale pieces into each other, then finally sets the context.defined value\r\n * for the nls/colors bundle to be that mixed in locale.\r\n *\r\n * 2) A regular module specifies a specific locale to load. For instance,\r\n * i18n!nls/fr-fr/colors. In this case, the plugin needs to load the master bundle\r\n * first, at nls/colors, then figure out what the best match locale is for fr-fr,\r\n * since maybe only fr or just root is defined for that locale. Once that best\r\n * fit is found, all of its locale pieces need to have their bundles loaded.\r\n *\r\n * Once all the bundles for the locale pieces load, then it mixes in all those\r\n * locale pieces into each other, then finally sets the context.defined value\r\n * for the nls/fr-fr/colors bundle to be that mixed in locale.\r\n */\r\n(function () {\r\n    'use strict';\r\n\r\n    //regexp for reconstructing the master bundle name from parts of the regexp match\r\n    //nlsRegExp.exec(\"foo/bar/baz/nls/en-ca/foo\") gives:\r\n    //[\"foo/bar/baz/nls/en-ca/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"en-ca\", \"foo\"]\r\n    //nlsRegExp.exec(\"foo/bar/baz/nls/foo\") gives:\r\n    //[\"foo/bar/baz/nls/foo\", \"foo/bar/baz/nls/\", \"/\", \"/\", \"foo\", \"\"]\r\n    //so, if match[5] is blank, it means this is the top bundle definition.\r\n    var nlsRegExp = /(^.*(^|\\/)nls(\\/|$))([^\\/]*)\\/?([^\\/]*)/;\r\n\r\n    //Helper function to avoid repeating code. Lots of arguments in the\r\n    //desire to stay functional and support RequireJS contexts without having\r\n    //to know about the RequireJS contexts.\r\n    function addPart(locale, master, needed, toLoad, prefix, suffix) {\r\n        if (master[locale]) {\r\n            needed.push(locale);\r\n            if (master[locale] === true || master[locale] === 1) {\r\n                toLoad.push(prefix + locale + '/' + suffix);\r\n            }\r\n        }\r\n    }\r\n\r\n    function addIfExists(req, locale, toLoad, prefix, suffix) {\r\n        var fullName = prefix + locale + '/' + suffix;\r\n        if (require._fileExists(req.toUrl(fullName + '.js'))) {\r\n            toLoad.push(fullName);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Simple function to mix in properties from source into target,\r\n     * but only if target does not already have a property of the same name.\r\n     * This is not robust in IE for transferring methods that match\r\n     * Object.prototype names, but the uses of mixin here seem unlikely to\r\n     * trigger a problem related to that.\r\n     */\r\n    function mixin(target, source, force) {\r\n        var prop;\r\n        for (prop in source) {\r\n            if (source.hasOwnProperty(prop) && (!target.hasOwnProperty(prop) || force)) {\r\n                target[prop] = source[prop];\r\n            } else if (typeof source[prop] === 'object') {\r\n                mixin(target[prop], source[prop], force);\r\n            }\r\n        }\r\n    }\r\n\r\n    define('i18n',['module'], function (module) {\r\n        var masterConfig = module.config ? module.config() : {};\r\n\r\n        return {\r\n            version: '2.0.1+',\r\n            /**\r\n             * Called when a dependency needs to be loaded.\r\n             */\r\n            load: function (name, req, onLoad, config) {\r\n                config = config || {};\r\n\r\n                if (config.locale) {\r\n                    masterConfig.locale = config.locale;\r\n                }\r\n\r\n                var masterName,\r\n                    match = nlsRegExp.exec(name),\r\n                    prefix = match[1],\r\n                    locale = match[4],\r\n                    suffix = match[5],\r\n                    parts = locale.split(\"-\"),\r\n                    toLoad = [],\r\n                    value = {},\r\n                    i, part, current = \"\";\r\n\r\n                //If match[5] is blank, it means this is the top bundle definition,\r\n                //so it does not have to be handled. Locale-specific requests\r\n                //will have a match[4] value but no match[5]\r\n                if (match[5]) {\r\n                    //locale-specific bundle\r\n                    prefix = match[1];\r\n                    masterName = prefix + suffix;\r\n                } else {\r\n                    //Top-level bundle.\r\n                    masterName = name;\r\n                    suffix = match[4];\r\n                    locale = masterConfig.locale;\r\n                    if (!locale) {\r\n                        locale = masterConfig.locale =\r\n                            typeof navigator === \"undefined\" ? \"root\" :\r\n                            (navigator.language ||\r\n                             navigator.userLanguage || \"root\").toLowerCase();\r\n                    }\r\n                    parts = locale.split(\"-\");\r\n                }\r\n\r\n                if (config.isBuild) {\r\n                    //Check for existence of all locale possible files and\r\n                    //require them if exist.\r\n                    toLoad.push(masterName);\r\n                    addIfExists(req, \"root\", toLoad, prefix, suffix);\r\n                    for (i = 0; i < parts.length; i++) {\r\n                        part = parts[i];\r\n                        current += (current ? \"-\" : \"\") + part;\r\n                        addIfExists(req, current, toLoad, prefix, suffix);\r\n                    }\r\n\r\n                    req(toLoad, function () {\r\n                        onLoad();\r\n                    });\r\n                } else {\r\n                    //First, fetch the master bundle, it knows what locales are available.\r\n                    req([masterName], function (master) {\r\n                        //Figure out the best fit\r\n                        var needed = [],\r\n                            part;\r\n\r\n                        //Always allow for root, then do the rest of the locale parts.\r\n                        addPart(\"root\", master, needed, toLoad, prefix, suffix);\r\n                        for (i = 0; i < parts.length; i++) {\r\n                            part = parts[i];\r\n                            current += (current ? \"-\" : \"\") + part;\r\n                            addPart(current, master, needed, toLoad, prefix, suffix);\r\n                        }\r\n\r\n                        //Load all the parts missing.\r\n                        req(toLoad, function () {\r\n                            var i, partBundle, part;\r\n                            for (i = needed.length - 1; i > -1 && needed[i]; i--) {\r\n                                part = needed[i];\r\n                                partBundle = master[part];\r\n                                if (partBundle === true || partBundle === 1) {\r\n                                    partBundle = req(prefix + part + '/' + suffix);\r\n                                }\r\n                                mixin(value, partBundle);\r\n                            }\r\n\r\n                            //All done, notify the loader.\r\n                            onLoad(value);\r\n                        });\r\n                    });\r\n                }\r\n            }\r\n        };\r\n    });\r\n}());\r\n","\n// English strings\r\ndefine(\r\n    '../nls/resistance-in-a-wire-strings',{\r\n      \"root\": {\r\n        simTitle: \"Resistance in a Wire\",\r\n        cm: \"cm\",\r\n        ohm: \"ohm\",\r\n        resistivity: \"resistivity\",\r\n        length: \"length\",\r\n        area: \"area\",\r\n        resistanceEq: \"Resistance =\"\r\n      },\r\n      \"am\": true,\r\n      \"ar\": true,\r\n      \"ar-sa\": true,\r\n      \"da\": true,\r\n      \"de\": true,\r\n      \"el\": true,\r\n      \"es\": true,\r\n      \"es-pe\": true,\r\n      \"et\": true,\r\n      \"eu\": true,\r\n      \"fa\": true,\r\n      \"fi\": true,\r\n      \"fr\": true,\r\n      \"gl\": true,\r\n      \"hr\": true,\r\n      \"hu\": true,\r\n      \"in\": true,\r\n      \"it\": true,\r\n      \"iw\": true,\r\n      \"ja\": true,\r\n      \"ka\": true,\r\n      \"ko\": true,\r\n      \"lv\": true,\r\n      \"mk\": true,\r\n      \"mn\": true,\r\n      \"nl\": true,\r\n      \"pl\": true,\r\n      \"pt\": true,\r\n      \"pt-br\": true,\r\n      \"ro\": true,\r\n      \"ru\": true,\r\n      \"sk\": true,\r\n      \"sr\": true,\r\n      \"sv\": true,\r\n      \"tk\": true,\r\n      \"tr\": true,\r\n      \"vi\": true,\r\n      \"zh-cn\": true,\r\n      \"zh-tw\": true\r\n    } );","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * Author: Sam Reid (PhET Interactive Simulations)\r\n *\r\n * Load the strings only once and from a single location, because loading them from different relative paths\r\n * causes them to fall back to the root language sometimes for unknown reasons.\r\n * See #17 at https://github.com/phetsims/resistance-in-a-wire/issues/17\r\n *\r\n */\r\ndefine( 'resistance-in-a-wire-strings',['require','i18n!../nls/resistance-in-a-wire-strings'],function( require ) {\r\n  'use strict';\r\n\r\n  var Strings = require( 'i18n!../nls/resistance-in-a-wire-strings' );\r\n  return Strings;\r\n} );","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * Model container for the \"resistance-in-a-wire\" module.\r\n *\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner)\r\n */\r\ndefine( 'model/ResistanceInAWireModel',['require','AXON/PropertySet','PHET_CORE/inherit'],function( require ) {\r\n  'use strict';\r\n  var PropertySet = require( 'AXON/PropertySet' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n\r\n  function ResistanceInAWireModel() {\r\n    var thisModel = this;\r\n\r\n    PropertySet.call( this, {\r\n      resistance: 0,\r\n      resistivity: 0.5,\r\n      length: 10,\r\n      area: 7.5\r\n    } );\r\n\r\n    var updateResistance = function() {\r\n      thisModel.resistance = (thisModel.resistivity * thisModel.length / thisModel.area);\r\n    };\r\n    this.resistivityProperty.link( updateResistance );\r\n    this.lengthProperty.link( updateResistance );\r\n    this.areaProperty.link( updateResistance );\r\n\r\n    this.reset();\r\n  }\r\n\r\n  inherit( PropertySet, ResistanceInAWireModel, {\r\n    step: function() { },\r\n    reset: function() {\r\n      this.resistivityProperty.reset();\r\n      this.lengthProperty.reset();\r\n      this.areaProperty.reset();\r\n    }\r\n  } );\r\n\r\n  return ResistanceInAWireModel;\r\n} );\r\n","\ndefine( 'imageLoader',['require'],function( require ) {\r\n  \"use strict\";\r\n\r\n  //Will be added lazily after image loader complete.\r\n  //Makes it possible to load through the module system rather than passed as parameter everywhere or used as global. \r\n\r\n  return {\r\n    imageNames: [\r\n      'slider.png',\r\n      'reset_button_disabled.png',\r\n      'reset_button_down.png',\r\n      'reset_button_over.png',\r\n      'reset_button_up.png'\r\n    ]  };\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Base class for push buttons that give visual feedback about their state.\r\n *\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'SUN/PushButton',['require','SCENERY/input/ButtonListener','PHET_CORE/inherit','SCENERY/nodes/Node','AXON/Property'],function( require ) {\r\n  'use strict';\r\n\r\n  // import\r\n  var ButtonListener = require( 'SCENERY/input/ButtonListener' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var Property = require( 'AXON/Property' );\r\n\r\n  /**\r\n   * @param {Node} upNode\r\n   * @param {Node} overNode\r\n   * @param {Node} downNode\r\n   * @param {Node} disabledNode\r\n   * @param {function} callback\r\n   * @param {object} options\r\n   * @constructor\r\n   */\r\n  function PushButton( upNode, overNode, downNode, disabledNode, callback, options ) {\r\n\r\n    options = _.extend( {\r\n        cursor: 'pointer',\r\n        label: 'Button'\r\n      },\r\n      options );\r\n\r\n    var thisButton = this;\r\n    Node.call( thisButton );\r\n\r\n    // nodes for each state\r\n    thisButton._upNode = upNode;\r\n    thisButton._overNode = overNode;\r\n    thisButton._downNode = downNode;\r\n    thisButton._disabledNode = disabledNode;\r\n\r\n    thisButton._state = 'up';\r\n    thisButton._enabled = new Property( true ); //TODO make this public and ditch the ES5 set/get?\r\n    thisButton._listeners = [ callback ];\r\n\r\n    thisButton.addChild( upNode );\r\n    thisButton.addChild( overNode );\r\n    thisButton.addChild( downNode );\r\n    thisButton.addChild( disabledNode );\r\n\r\n    thisButton.addInputListener( new ButtonListener( {\r\n\r\n      up: function() {\r\n        thisButton._state = 'up';\r\n        thisButton._update();\r\n      },\r\n\r\n      over: function() {\r\n        thisButton._state = 'over';\r\n        thisButton._update();\r\n      },\r\n\r\n      down: function() {\r\n        thisButton._state = 'down';\r\n        thisButton._update();\r\n      },\r\n\r\n      out: function() {\r\n        thisButton._state = 'up'; //NOTE: 'out' state looks the same as 'up'\r\n        thisButton._update();\r\n      },\r\n\r\n      fire: function() {\r\n        thisButton._fire();\r\n      }\r\n    } ) );\r\n\r\n    // accessibility\r\n    thisButton.addPeer( '<input type=\"button\" aria-label=\"' + _.escape( options.label ) + '\">',\r\n      { click: thisButton._fire.bind( thisButton ) }\r\n    );\r\n\r\n    thisButton._enabled.link( function( enabled ) {\r\n      thisButton.cursor = enabled ? options.cursor : 'default';\r\n      thisButton._update();\r\n    } );\r\n\r\n    //Mutate with the options after the layout is complete so that you can use width-dependent fields like centerX, etc.\r\n    thisButton.mutate( options );\r\n  }\r\n\r\n  return inherit( Node, PushButton, {\r\n\r\n    // Adds a listener. If already a listener, this is a no-op.\r\n    addListener: function( listener ) {\r\n      if ( this._listeners.indexOf( listener ) === -1 ) {\r\n        this._listeners.push( listener );\r\n      }\r\n    },\r\n\r\n    // Remove a listener. If not a listener, this is a no-op.\r\n    removeListener: function( listener ) {\r\n      var i = this._listeners.indexOf( listener );\r\n      if ( i !== -1 ) {\r\n        this._listeners.splice( i, 1 );\r\n      }\r\n    },\r\n\r\n    _fire: function() {\r\n      this._listeners.forEach( function( listener ) {\r\n        listener();\r\n      } );\r\n    },\r\n\r\n    _update: function() {\r\n      // use visible instead of add/removeChild to prevent flickering\r\n      var enabled = this._enabled.get();\r\n      this._upNode.visible = ( this._state === 'up' && enabled );\r\n      this._downNode.visible = ( this._state === 'down' && enabled );\r\n      this._overNode.visible = ( this._state === 'over' && enabled );\r\n      this._disabledNode.visible = !enabled;\r\n    },\r\n\r\n    set enabled( value ) { this._enabled.set( value ); },\r\n\r\n    get enabled() { return this._enabled.get(); }\r\n  } );\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n//TODO this is a local copy, duplicated in all sims, migrate to sun.ResetAllButton\r\n/**\r\n * Reset All button.\r\n */\r\ndefine( 'view/ResetAllButton',['require','imageLoader','SCENERY/nodes/Image','PHET_CORE/inherit','SUN/PushButton','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n\r\n  // imports\r\n  var imageLoader = require( 'imageLoader' );\r\n  var Image = require( 'SCENERY/nodes/Image' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var PushButton = require( 'SUN/PushButton' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n\r\n  var radius = 33; // hardcoded width/height for the circle of the reset all button\r\n  var radiusSquared = radius * radius;\r\n  var center = new Vector2( radius, radius );\r\n\r\n  function ResetAllButton( callback, options ) {\r\n    PushButton.call( this,\r\n      new ResetAllImage( imageLoader.getImage( 'reset_button_up.png' ) ),\r\n      new ResetAllImage( imageLoader.getImage( 'reset_button_over.png' ) ),\r\n      new ResetAllImage( imageLoader.getImage( 'reset_button_down.png' ) ),\r\n      new ResetAllImage( imageLoader.getImage( 'reset_button_disabled.png' ) ),\r\n      callback, options );\r\n  }\r\n\r\n  function ResetAllImage( image ) {\r\n    Image.call( this, image );\r\n  }\r\n  inherit( Image, ResetAllImage, {\r\n    containsPointSelf: function( point ) {\r\n      return point.distanceSquared( center ) <= radiusSquared;\r\n    }\r\n  } );\r\n\r\n  return inherit( PushButton, ResetAllButton );\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * An arrow shape, either single or double headed.\r\n *\r\n * @author John Blanco\r\n * @author Chris Malley\r\n */\r\ndefine( 'SCENERY_PHET/ArrowShape',['require','PHET_CORE/inherit','KITE/Shape','DOT/Vector2'],function( require ) {\r\n  'use strict';\r\n\r\n  // imports\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var Vector2 = require( 'DOT/Vector2' );\r\n\r\n  function ArrowShape( tailX, tailY, tipX, tipY, options ) {\r\n\r\n    options = _.extend( {\r\n      tailWidth: 5,\r\n      headWidth: 10,\r\n      headHeight: 10,\r\n      doubleHead: false\r\n    }, options );\r\n\r\n    var thisShape = this;\r\n    Shape.call( thisShape );\r\n\r\n    if ( tipX !== tailX || tipY !== tailY ) {\r\n\r\n      var vector = new Vector2( tipX - tailX, tipY - tailY );\r\n      var xHatUnit = vector.normalized();\r\n      var yHatUnit = xHatUnit.rotated( Math.PI / 2 );\r\n      var length = vector.magnitude();\r\n\r\n      // limit head height\r\n      options.headHeight = Math.min( options.headHeight, options.doubleHead ? 0.35 * length : 0.5 * length );\r\n\r\n      // Set up a coordinate frame that goes from the tail of the arrow to the tip.\r\n      var getPoint = function( xHat, yHat ) {\r\n        var x = xHatUnit.x * xHat + yHatUnit.x * yHat + tailX;\r\n        var y = xHatUnit.y * xHat + yHatUnit.y * yHat + tailY;\r\n        return new Vector2( x, y );\r\n      };\r\n\r\n      // Compute points for single- or double-headed arrow\r\n      var points = [];\r\n      if ( options.doubleHead ) {\r\n        points.push( getPoint( 0, 0 ) );\r\n        points.push( getPoint( options.headHeight, options.headWidth / 2 ) );\r\n        points.push( getPoint( options.headHeight, options.tailWidth / 2 ) );\r\n      }\r\n      else {\r\n        points.push( getPoint( 0, options.tailWidth / 2 ) );\r\n      }\r\n      points.push( getPoint( length - options.headHeight, options.tailWidth / 2 ) );\r\n      points.push( getPoint( length - options.headHeight, options.headWidth / 2 ) );\r\n      points.push( getPoint( length, 0 ) );\r\n      points.push( getPoint( length - options.headHeight, -options.headWidth / 2 ) );\r\n      points.push( getPoint( length - options.headHeight, -options.tailWidth / 2 ) );\r\n      if ( options.doubleHead ) {\r\n        points.push( getPoint( options.headHeight, -options.tailWidth / 2 ) );\r\n        points.push( getPoint( options.headHeight, -options.headWidth / 2 ) );\r\n      }\r\n      else {\r\n        points.push( getPoint( 0, -options.tailWidth / 2 ) );\r\n      }\r\n\r\n      // Describe the shape\r\n      thisShape.moveTo( points[0].x, points[0].y );\r\n      var tail = _.tail( points );\r\n      _.each( tail, function( element ) {\r\n        thisShape.lineTo( element.x, element.y );\r\n      } );\r\n      thisShape.close();\r\n    }\r\n  }\r\n\r\n  return inherit( Shape, ArrowShape );\r\n} );\r\n","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * A single- or double-headed arrow. This is a convenience class, most of the\r\n * work is done in ArrowShape.\r\n *\r\n * @author John Blanco\r\n * @author Chris Malley\r\n */\r\ndefine( 'SCENERY_PHET/ArrowNode',['require','SCENERY_PHET/ArrowShape','ASSERT/assert','PHET_CORE/inherit','SCENERY/nodes/Path','SCENERY/nodes/Node'],function( require ) {\r\n  'use strict';\r\n\r\n  // Imports\r\n  var ArrowShape = require( 'SCENERY_PHET/ArrowShape' );\r\n  var assert = require( 'ASSERT/assert' )( 'scenery-phet' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n\r\n  /**\r\n   * @param {number} tailX\r\n   * @param {number} tailY\r\n   * @param {number} tipX\r\n   * @param {number} tipY\r\n   * @param {Object} options\r\n   * @constructor\r\n   */\r\n  function ArrowNode( tailX, tailY, tipX, tipY, options ) {\r\n\r\n    // default options\r\n    options = _.extend( {\r\n      headHeight: 10,\r\n      headWidth: 10,\r\n      tailWidth: 5,\r\n      doubleHead: false, // true puts heads on both ends of the arrow, false puts a head at the tip\r\n      fill: 'black',\r\n      stroke: 'black',\r\n      lineWidth: 1\r\n    }, options );\r\n\r\n    // things you're likely to mess up, add more as needed\r\n    assert && assert( options.headWidth > options.tailWidth );\r\n\r\n    // shape is not an option that the client should be able to set\r\n    options.shape = new ArrowShape( tailX, tailY, tipX, tipY, options );\r\n    var arrowNode = new Path( options );\r\n\r\n    // wrap in a Node so that clients can't set Path.shape (yes, someone did this)\r\n    Node.call( this, options );\r\n    this.addChild( arrowNode );\r\n  }\r\n\r\n  return inherit( Node, ArrowNode );\r\n} );","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * White Block with black border container\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner)\r\n */\r\n\r\n\r\ndefine( 'view/shape-views/slider-box-view/WhiteBox',['require','SCENERY/nodes/Node','PHET_CORE/inherit','SCENERY/nodes/Rectangle'],function( require ) {\r\n  'use strict';\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n\r\n  function WhiteBox( x, y, w, h ) {\r\n    Node.call( this );\r\n    this.addChild( new Rectangle( x, y, w, h, 12, 12, { fill: '#FFF', stroke: \"#000\", lineWidth: 3} ) );\r\n  }\r\n\r\n  inherit( Node, WhiteBox );\r\n\r\n  return WhiteBox;\r\n} );","\n// Copyright 2002-2013, University of Colorado Boulder\r\n\r\n/**\r\n * Function for doing a linear mapping between two domains ('a' and 'b').\r\n * <p>\r\n * Example usage:\r\n * <code>\r\n * var f = new dot.LinearFunction( 0, 100, 0, 200 );\r\n * f( 50 ); // 100\r\n * f.inverse( 100 ); // 50\r\n * </code>\r\n *\r\n * @author Chris Malley (PixelZoom, Inc.)\r\n */\r\ndefine( 'DOT/LinearFunction',['require','DOT/dot','DOT/Util'],function( require ) {\r\n  'use strict';\r\n  \r\n  var dot = require( 'DOT/dot' );\r\n  \r\n  // imports\r\n  require( 'DOT/Util' );\r\n  \r\n  /**\r\n   * @param {Number} a1\r\n   * @param {Number} a2\r\n   * @param {Number} b1\r\n   * @param {Number} b2\r\n   * @param {Boolean} clamp clamp the result to the provided ranges, false by default\r\n   * @constructor\r\n   */\r\n  dot.LinearFunction = function LinearFunction( a1, a2, b1, b2, clamp ) {\r\n    \r\n    clamp = _.isUndefined( clamp ) ? false : clamp;\r\n\r\n    /*\r\n     * Linearly interpolate two points and evaluate the line equation for a third point.\r\n     * f( a1 ) = b1, f( a2 ) = b2, f( a3 ) = <linear mapped value>\r\n     * Optionally clamp the result to the range [b1,b2].\r\n     */\r\n    var map = function( a1, a2, b1, b2, a3, clamp ) {\r\n      var b3 = dot.Util.linear( a1, a2, b1, b2, a3 );\r\n      if ( clamp ) {\r\n        var max = Math.max( b1, b2 );\r\n        var min = Math.min( b1, b2 );\r\n        b3 = dot.Util.clamp( b3, min, max );\r\n      }\r\n      return b3;\r\n    };\r\n    \r\n    // Maps from a to b.\r\n    var evaluate = function( a3 ) {\r\n      return map( a1, a2, b1, b2, a3, clamp );\r\n    };\r\n\r\n    // Maps from b to a.\r\n    evaluate.inverse = function( b3 ) {\r\n      return map( b1, b2, a1, a2, b3, clamp );\r\n    };\r\n    \r\n    return evaluate; // return the evaluation function, so we use sites look like: f(a) f.inverse(b)\r\n  };\r\n  \r\n  return dot.LinearFunction;\r\n} );\r\n","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * view for vertical slider control\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner)\r\n */\r\n\r\ndefine( 'view/shape-views/slider-box-view/Slider',['require','SCENERY/nodes/Node','PHET_CORE/inherit','SCENERY/nodes/Image','SCENERY/nodes/Rectangle','SCENERY/input/SimpleDragHandler','DOT/LinearFunction'],function( require ) {\r\n  'use strict';\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Image = require( 'SCENERY/nodes/Image' );\r\n  var Rectangle = require( 'SCENERY/nodes/Rectangle' );\r\n  var SimpleDragHandler = require( 'SCENERY/input/SimpleDragHandler' );\r\n  var LinearFunction = require( 'DOT/LinearFunction' );\r\n\r\n  function Slider( x, y, h, targetProperty, img, value ) {\r\n    var thisNode = this;\r\n    Node.call( this, {x: x, y: y} );\r\n    this.addChild( new Rectangle( -3, 0, 6, h, {fill: \"black\" } ) );\r\n\r\n    var track = new Node( {children: [new Image( img, {centerX: 0, top: 0} )], cursor: \"pointer\"} );\r\n\r\n    var clickYOffset,\r\n      yMin = 0,\r\n      yMax = h - track.height;\r\n\r\n    var valueToPosition = new LinearFunction( value.min, value.max, yMax, yMin, true ),\r\n      positionToValue = new LinearFunction( yMax, yMin, value.min, value.max, true );\r\n    this.addChild( track );\r\n    track.addInputListener( new SimpleDragHandler(\r\n      {\r\n        start: function( event ) {\r\n          clickYOffset = thisNode.globalToParentPoint( event.pointer.point ).y - event.currentTarget.y;\r\n        },\r\n        drag: function( event ) {\r\n          var y = thisNode.globalToParentPoint( event.pointer.point ).y - clickYOffset;\r\n          y = Math.max( Math.min( y, yMax ), yMin );\r\n          targetProperty.set( positionToValue( y ) );\r\n        },\r\n        translate: function() {\r\n          // do nothing, override default behavior\r\n        }\r\n      } ) );\r\n    targetProperty.link( function( value ) {\r\n      track.y = valueToPosition( value );\r\n    } );\r\n  }\r\n\r\n  inherit( Node, Slider );\r\n\r\n  return Slider;\r\n} );","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * Block shows resistance TextBlock\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner)\r\n */\r\n\r\n\r\ndefine( 'view/shape-views/slider-box-view/CurrentResistanceView',['require','SCENERY/nodes/Node','PHET_CORE/inherit','resistance-in-a-wire-strings','SCENERY/nodes/Text','SCENERY_PHET/PhetFont'],function( require ) {\r\n  'use strict';\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Strings = require( 'resistance-in-a-wire-strings' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var PhetFont = require( 'SCENERY_PHET/PhetFont' );\r\n\r\n  var FONT = new PhetFont( 30 );\r\n\r\n  function CurrentResistanceView( model, x, y, w ) {\r\n    Node.call( this, {x: x, y: y} );\r\n    var nodeText = new Node();\r\n    var textResistance,\r\n      maxWidth = w * 0.95;\r\n    nodeText.addChild( new Text( Strings.resistanceEq, { font: FONT, fill: \"#F00\", right: 200, y: 0 } ) );\r\n    nodeText.addChild( textResistance = new Text( \"2000\", { font: FONT, fill: \"#F00\", right: 290, y: 0 } ) );\r\n    nodeText.addChild( new Text( Strings.ohm, { font: FONT, fill: \"#F00\", left: 300, y: 0 } ) );\r\n    nodeText.centerX = 0;\r\n    nodeText.centerY = 0;\r\n    this.addChild( nodeText );\r\n\r\n    var scale = 1;\r\n    if ( nodeText.width > maxWidth ) {\r\n      scale = maxWidth / nodeText.width;\r\n    }\r\n    this.scale( scale );\r\n\r\n    model.resistanceProperty.link( function updateTextResistance( value ) {\r\n      textResistance.text = value.toFixed( 2 );\r\n      if ( value > 9 ) {\r\n        textResistance.text = value.toFixed( 1 );\r\n      }\r\n      if ( value > 99 ) {\r\n        textResistance.text = value.toFixed( 0 );\r\n      }\r\n      textResistance.right = 290;\r\n    } );\r\n  }\r\n\r\n  inherit( Node, CurrentResistanceView );\r\n\r\n  return CurrentResistanceView;\r\n} );","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * Container for sliders and circumjacent text\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner)\r\n */\r\n\r\n\r\ndefine( 'view/shape-views/SlidersBox',['require','SCENERY/nodes/Node','PHET_CORE/inherit','resistance-in-a-wire-strings','view/shape-views/slider-box-view/WhiteBox','view/shape-views/slider-box-view/Slider','view/shape-views/slider-box-view/CurrentResistanceView','imageLoader','SCENERY/nodes/Text','SCENERY_PHET/PhetFont'],function( require ) {\r\n  'use strict';\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Strings = require( 'resistance-in-a-wire-strings' );\r\n  var WhiteBox = require( 'view/shape-views/slider-box-view/WhiteBox' );\r\n  var Slider = require( 'view/shape-views/slider-box-view/Slider' );\r\n  var CurrentResistanceView = require( \"view/shape-views/slider-box-view/CurrentResistanceView\" );\r\n  var imageLoader = require( 'imageLoader' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var PhetFont = require( 'SCENERY_PHET/PhetFont' );\r\n\r\n  function SlidersBox( model, x, y, options ) {\r\n    Node.call( this, {x: x, y: y} );\r\n    var rectW = 380,\r\n      rectH = 500,\r\n      textResistivity, textLength, textArea;\r\n    this.addChild( new WhiteBox( 0, 0, rectW, rectH ) );\r\n    //xy Grid\r\n    var yCoords = [60, 120, 410 , 453];\r\n    var xCoords = [70, 195, 320];\r\n\r\n    this.addChild( new Text( \"ρ\", { font: new PhetFont( { family: 'Times New Roman', size: 60 } ), fill: \"#0f0ffb\", centerX: xCoords[0], top: yCoords[0] - 10 } ) );\r\n    this.addChild( new Text( Strings.resistivity, { font: new PhetFont( 16 ), textAlign: \"center\", textAnchor: \"middle\", fill: \"#0f0ffb\", centerX: xCoords[0], top: yCoords[1] } ) );\r\n    this.addChild( textResistivity = new Text( model.resistivity.toFixed( 2 ), { font: new PhetFont( 30 ), textAlign: \"end\", textAnchor: \"end\", fill: \"#000\", centerX: xCoords[0], top: yCoords[2] } ) );\r\n    this.addChild( new Text( \"Ω\" + Strings.cm, { font: new PhetFont( 30 ), textAlign: \"start\", textAnchor: \"start\", fill: \"#0f0ffb\", centerX: xCoords[0], top: yCoords[3] } ) );\r\n\r\n    this.addChild( new Text( \"L\", { font: new PhetFont( { family: 'Times New Roman', size: 60 } ), fill: \"#0f0ffb\", centerX: xCoords[1], top: yCoords[0] } ) );\r\n    this.addChild( new Text( Strings.length, { font: new PhetFont( 16 ), textAlign: \"center\", textAnchor: \"middle\", fill: \"#0f0ffb\", centerX: xCoords[1], top: yCoords[1] } ) );\r\n    this.addChild( textLength = new Text( model.length.toFixed( 2 ), { font: new PhetFont( 30 ), textAlign: \"end\", textAnchor: \"end\", fill: \"#000\", centerX: xCoords[1], top: yCoords[2] } ) );\r\n    this.addChild( new Text( Strings.cm, { font: new PhetFont( 30 ), textAlign: \"start\", textAnchor: \"start\", fill: \"#0f0ffb\", centerX: xCoords[1], top: yCoords[3] } ) );\r\n\r\n    this.addChild( new Text( \"A\", { font: new PhetFont( { family: 'Times New Roman', size: 60 } ), fill: \"#0f0ffb\", centerX: xCoords[2], top: yCoords[0] } ) );\r\n    this.addChild( new Text( Strings.area, { font: new PhetFont( 16 ), textAlign: \"center\", textAnchor: \"middle\", fill: \"#0f0ffb\", centerX: xCoords[2], top: yCoords[1] } ) );\r\n    this.addChild( textArea = new Text( model.area.toFixed( 2 ), { font: new PhetFont( 30 ), textAlign: \"end\", textAnchor: \"end\", fill: \"#000\", centerX: xCoords[2], top: yCoords[2] } ) );\r\n    this.addChild( new Text( Strings.cm + \"²\", { font: new PhetFont( 30 ), textAlign: \"start\", textAnchor: \"start\", fill: \"#0f0ffb\", centerX: xCoords[2], top: yCoords[3] } ) );\r\n\r\n    this.addChild( new Slider( xCoords[0], 145, 260, model.resistivityProperty, imageLoader.getImage( 'slider.png' ), options.resistivity ) );\r\n    this.addChild( new Slider( xCoords[1], 145, 260, model.lengthProperty, imageLoader.getImage( 'slider.png' ), options.length ) );\r\n    this.addChild( new Slider( xCoords[2], 145, 260, model.areaProperty, imageLoader.getImage( 'slider.png' ), options.area ) );\r\n\r\n    model.resistivityProperty.link( function updateTextResistivity( value ) {\r\n      textResistivity.text = value.toFixed( 2 );\r\n      textResistivity.centerX = xCoords[0];\r\n    } );\r\n    model.lengthProperty.link( function updateTextLength( value ) {\r\n      textLength.text = value.toFixed( 2 );\r\n      textLength.centerX = xCoords[1];\r\n    } );\r\n    model.areaProperty.link( function updateTextArea( value ) {\r\n      textArea.text = value.toFixed( 2 );\r\n      textArea.centerX = xCoords[2];\r\n    } );\r\n\r\n    //resistance value\r\n    this.addChild( new CurrentResistanceView( model, rectW / 2, 30, rectW ) );\r\n\r\n  }\r\n\r\n  inherit( Node, SlidersBox );\r\n\r\n  return SlidersBox;\r\n} );","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * Block shows R = ρL/A formula with letters scaling\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner)\r\n */\r\n\r\n\r\ndefine( 'view/shape-views/FormulaView',['require','SCENERY/nodes/Node','PHET_CORE/inherit','SCENERY/nodes/Text','DOT/Matrix3','SCENERY/nodes/Path','KITE/Shape','SCENERY_PHET/PhetFont'],function( require ) {\r\n  'use strict';\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Text = require( 'SCENERY/nodes/Text' );\r\n  var Matrix3 = require( 'DOT/Matrix3' );\r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var PhetFont = require( 'SCENERY_PHET/PhetFont' );\r\n\r\n  function FormulaView( model, x, y ) {\r\n    var thisNode = this;\r\n    Node.call( this, {x: x, y: y} );\r\n    var texts = [\r\n      {\r\n        label: \"R\",\r\n        scale: 3 / 2,\r\n        x: 20,\r\n        y: 0,\r\n        targetProperty: \"resistanceProperty\",\r\n        color: \"#ed1c24\"\r\n      },\r\n      {\r\n        label: \"ρ\",\r\n        x: 220,\r\n        y: -110,\r\n        targetProperty: \"resistivityProperty\",\r\n        color: \"#0f0ffb\"\r\n      },\r\n      {\r\n        label: \"L\",\r\n        x: 320,\r\n        y: -90,\r\n        targetProperty: \"lengthProperty\",\r\n        color: \"#0f0ffb\"\r\n      },\r\n      {\r\n        label: \"A\",\r\n        x: 280,\r\n        y: 90,\r\n        targetProperty: \"areaProperty\",\r\n        color: \"#0f0ffb\"\r\n      }\r\n    ];\r\n    //static text\r\n    thisNode.addChild( new Text( \"=\", { font: new PhetFont( { family: 'Times New Roman', size: 100 } ), fill: \"#000\", centerX: 100, centerY: 0} ) );\r\n    thisNode.addChild( new Path( { shape: Shape.lineSegment( 150, 8, 400, 8 ), stroke: 'black', lineWidth: 6 } ) );\r\n    //dynamic text\r\n    texts.forEach( function( entry ) {\r\n      entry.view = new Text( entry.label, {font: new PhetFont( { family: 'Times New Roman', size: 130 } ), fill: entry.color, centerX: entry.x, centerY: entry.y} );\r\n      thisNode.addChild( entry.view );\r\n      entry.scale = entry.scale || 1 / model[entry.targetProperty].get();\r\n      model[entry.targetProperty].link( function updateProperty( val ) {\r\n        entry.view.matrix = new Matrix3();\r\n        entry.view.scale( entry.scale * val + 0.125 );\r\n        entry.view.centerX = entry.x;\r\n        entry.view.centerY = entry.y;\r\n      } );\r\n    } );\r\n  }\r\n\r\n  inherit( Node, FormulaView );\r\n\r\n  return FormulaView;\r\n} );","\n// Copyright 2002-2013, University of Colorado\r\n\r\n/**\r\n * A circular node that inherits Path, and allows for optimized drawing,\r\n * and improved parameter handling.\r\n *\r\n * @author Jonathan Olson <olsonsjc@gmail.com>\r\n */\r\n\r\ndefine( 'SCENERY/nodes/Circle',['require','PHET_CORE/inherit','SCENERY/scenery','SCENERY/nodes/Path','KITE/Shape'],function( require ) {\r\n  'use strict';\r\n  \r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var scenery = require( 'SCENERY/scenery' );\r\n  \r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  \r\n  scenery.Circle = function Circle( radius, options ) {\r\n    if ( typeof radius === 'object' ) {\r\n      // allow new Circle( { radius: ... } )\r\n      // the mutators will call invalidateCircle() and properly set the shape\r\n      options = radius;\r\n    } else {\r\n      this._radius = radius;\r\n      \r\n      // ensure we have a parameter object\r\n      options = options || {};\r\n      \r\n      // fallback for non-canvas or non-svg rendering, and for proper bounds computation\r\n      options.shape = Shape.circle( 0, 0, radius );\r\n    }\r\n    \r\n    Path.call( this, options );\r\n  };\r\n  var Circle = scenery.Circle;\r\n  \r\n  inherit( Path, Circle, {\r\n    invalidateCircle: function() {\r\n      // setShape should invalidate the path and ensure a redraw\r\n      this.setShape( Shape.circle( 0, 0, this._radius ) );\r\n    },\r\n    \r\n    // create a circle instead of a path, hopefully it is faster in implementations\r\n    createSVGFragment: function( svg, defs, group ) {\r\n      return document.createElementNS( 'http://www.w3.org/2000/svg', 'circle' );\r\n    },\r\n    \r\n    // optimized for the circle element instead of path\r\n    updateSVGFragment: function( circle ) {\r\n      circle.setAttribute( 'r', this._radius );\r\n      \r\n      circle.setAttribute( 'style', this.getSVGFillStyle() + this.getSVGStrokeStyle() );\r\n    },\r\n    \r\n    getBasicConstructor: function( propLines ) {\r\n      return 'new scenery.Circle( ' + this._radius + ', {' + propLines + '} )';\r\n    },\r\n    \r\n    getRadius: function() {\r\n      return this._radius;\r\n    },\r\n    \r\n    setRadius: function( radius ) {\r\n      if ( this._radius !== radius ) {\r\n        this._radius = radius;\r\n        this.invalidateCircle();\r\n      }\r\n      return this;\r\n    },\r\n    \r\n    computeShapeBounds: function() {\r\n      // optimization, where we know our computed bounds will be just expanded by half the lineWidth if we are stroked (don't have to compute the stroke shape)\r\n      return this._stroke ? this._shape.bounds.dilated( this._lineDrawingStyles.lineWidth / 2 ) : this._shape.bounds;\r\n    },\r\n    \r\n    // accelerated hit detection\r\n    containsPointSelf: function( point ) {\r\n      return point.x * point.x + point.y * point.y < this._radius * this._radius;\r\n    },\r\n    \r\n    get radius() { return this.getRadius(); },\r\n    set radius( value ) { return this.setRadius( value ); }\r\n  } );\r\n  \r\n  // not adding mutators for now\r\n  Circle.prototype._mutatorKeys = [ 'radius' ].concat( Path.prototype._mutatorKeys );\r\n  \r\n  return Circle;\r\n} );\r\n","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * Container for resistor and nearby graphics\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner)\r\n */\r\ndefine( 'view/shape-views/ResistorView',['require','SCENERY/nodes/Node','PHET_CORE/inherit','SCENERY/nodes/Circle','SCENERY/util/LinearGradient','SCENERY/nodes/Path','KITE/Shape','DOT/LinearFunction'],function( require ) {\r\n  'use strict';\r\n\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var Circle = require( 'SCENERY/nodes/Circle' );\r\n  var LinearGradient = require( 'SCENERY/util/LinearGradient' );\r\n  var Path = require( 'SCENERY/nodes/Path' );\r\n  var Shape = require( 'KITE/Shape' );\r\n  var LinearFunction = require( 'DOT/LinearFunction' );\r\n\r\n  function ResistorView( model, x, y, options ) {\r\n\r\n    Node.call( this, {x: x, y: y} );\r\n\r\n\r\n    var height = 200,\r\n      width = 500,\r\n      shift = height / 3,\r\n      resistorShape1 = new Shape(),\r\n      resistorShape2 = new Shape(),\r\n      resistor = new Node(),\r\n      path1, path2;\r\n    var linearGradient1 = new LinearGradient( 0, 0, 0, height )\r\n        .addColorStop( 0, \"#e4e4e4\" )\r\n        .addColorStop( 0.2, \"#FFF\" )\r\n        .addColorStop( 0.5, \"#FFF\" )\r\n        .addColorStop( 0.81, \"#bfbfbf\" )\r\n        .addColorStop( 1, \"#575757\" ),\r\n      areaToHeight = new LinearFunction( options.area.min, options.area.max, 3, 200, true ),\r\n      lengthToWidth = new LinearFunction( options.length.min, options.length.max, 15, 500, true ),\r\n      resistivityToDot = new LinearFunction( options.resistivity.min, options.resistivity.max, 25, 500, true );\r\n\r\n    resistor.addChild( path1 = new Path( {\r\n      shape: resistorShape1,\r\n      stroke: \"#000\",\r\n      fill: linearGradient1,\r\n      lineWidth: 1\r\n    } ) );\r\n    resistor.addChild( path2 = new Path( {\r\n      shape: resistorShape2,\r\n      stroke: \"#000\",\r\n      fill: \"#f2f2f2\",\r\n      lineWidth: 1\r\n    } ) );\r\n    this.addChild( resistor );\r\n\r\n    var dotGroup = new Node();\r\n    var maxPoints = 500,\r\n      a = (height - 3) * (width + shift) / maxPoints,    //area per dot\r\n      d = Math.pow( a, 0.5 ), //NN dot separation\r\n      nRows = Math.round( height / d ),\r\n      nCols = Math.round( (width + shift) / d ),\r\n      c = 0; //counter\r\n\r\n    var points = [];\r\n\r\n    for ( var i = 1; i <= nRows; i++ ) {\r\n      for ( var j = 1; j <= nCols; j++ ) {\r\n        var p = new Circle( 2, {fill: \"#000\"} );\r\n        p.y = i * d - d / 2 + Math.random() * d * 0.7 - 3;\r\n        p.x = j * d - d / 2 + Math.random() * d * 0.7;\r\n        points.push( p );\r\n        dotGroup.addChild( p );\r\n        c++;\r\n      }\r\n    }\r\n    maxPoints = c;\r\n\r\n    for ( i = points.length - 1; i > -1; i-- ) {\r\n      var pos = parseInt( Math.random() * i, 10 );\r\n      var tt = points[i];\r\n      points[i] = points[pos];\r\n      points[pos] = tt;\r\n    }\r\n\r\n    this.addChild( dotGroup );\r\n\r\n    function shiftDotInResistor( y, height ) {\r\n      return Math.sqrt( Math.abs( (1 - (y - 100) * (y - 100)) / ((height) * (height)) * ((height / 3) * (height / 3)) ) ) - height / 5;\r\n    }\r\n\r\n    function dotInResistor( dot, height ) {\r\n      return ( dot.y - 100 > -height / 2 + 3 && dot.y - 100 < height / 2 - 3 && dot.x - 290 > -width / 2 + 0 + shiftDotInResistor( dot.y, height ) && dot.x - 290 < width / 2 + 0 - shiftDotInResistor( dot.y, height ) );\r\n    }\r\n\r\n    model.resistanceProperty.link( function updateResistor( val ) {\r\n      resistorShape1 = new Shape();\r\n      resistorShape2 = new Shape();\r\n      height = areaToHeight( model.area );\r\n      width = lengthToWidth( model.length );\r\n      shift = height / 3;\r\n      linearGradient1.end.y = height;\r\n\r\n      resistorShape1.moveTo( 5, 0 );\r\n      resistorShape1.cubicCurveTo( shift + 5, 0, shift + 5, height, 5, height );\r\n      resistorShape1.lineTo( width - 3, height );\r\n      resistorShape1.cubicCurveTo( width - 3 + shift, height, width - 3 + shift, 0, width - 3, 0 );\r\n      resistorShape1.close();\r\n\r\n      resistorShape2.moveTo( 5, 0 );\r\n      resistorShape2.cubicCurveTo( shift + 5, 0, shift + 5, height, 5, height );\r\n      resistorShape2.cubicCurveTo( -shift + 5, height, -shift + 5, 0, 5, 0 );\r\n      resistorShape2.close();\r\n\r\n      path1.shape = resistorShape1;\r\n      path2.shape = resistorShape2;\r\n      resistor.centerX = 0;\r\n      resistor.centerY = 0;\r\n\r\n      var borderNumber = resistivityToDot( model.resistivity );\r\n      for ( var i = 0; i < maxPoints; i++ ) {\r\n        if ( i < borderNumber && dotInResistor( points[i], height ) ) {\r\n          points[i].setVisible( true );\r\n        }\r\n        else {\r\n          points[i].setVisible( false );\r\n        }\r\n      }\r\n      dotGroup.centerX = 0;\r\n      dotGroup.centerY = 0;\r\n    } );\r\n\r\n  }\r\n\r\n  inherit( Node, ResistorView );\r\n  return ResistorView;\r\n} );","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * Stage for the \"ResistanceInAWire\" view.\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner)\r\n */\r\n\r\ndefine( 'view/ResistanceInAWireStageContainer',['require','SCENERY/nodes/Node','PHET_CORE/inherit','view/ResetAllButton','SCENERY_PHET/ArrowNode','view/shape-views/SlidersBox','view/shape-views/FormulaView','view/shape-views/ResistorView'],function( require ) {\r\n  'use strict';\r\n  var Node = require( 'SCENERY/nodes/Node' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n  var ResetAllButton = require( 'view/ResetAllButton' );\r\n  var ArrowNode = require( 'SCENERY_PHET/ArrowNode' );\r\n  var SlidersBox = require( \"view/shape-views/SlidersBox\" );\r\n  var FormulaView = require( \"view/shape-views/FormulaView\" );\r\n  var ResistorView = require( \"view/shape-views/ResistorView\" );\r\n\r\n  function ResistanceInAWireStage( model ) {\r\n    Node.call( this, {scale: 0.75} );\r\n    var options = {\r\n      resistivity: {max: 1, min: 0.01},\r\n      length: {max: 20, min: 0.1},\r\n      area: {max: 15, min: 0.01}\r\n    };\r\n\r\n    this.addChild( new FormulaView( model, 70, 180 ) );\r\n    this.addChild( new ResistorView( model, 290, 470, options ) );\r\n    this.addChild( new ArrowNode( 200, 600, 350, 600, { headHeight: 50, headWidth: 30, tailWidth: 10, fill: \"#FFF\", stroke: \"#000\", lineWidth: 1} ) );\r\n    this.addChild( new SlidersBox( model, 600, 40, options ) );\r\n    this.addChild( new Node( { x: 750, y: 560, children: [ new ResetAllButton( function() {model.reset();} )]} ) );\r\n  }\r\n\r\n  inherit( Node, ResistanceInAWireStage );\r\n  return ResistanceInAWireStage;\r\n} );\r\n","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * View for ResistanceInAWire simulations. Contains stage and reset button\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner)\r\n */\r\n\r\ndefine( 'view/ResistanceInAWireView',['require','view/ResistanceInAWireStageContainer','JOIST/ScreenView','PHET_CORE/inherit'],function( require ) {\r\n  'use strict';\r\n  var ResistanceInAWireStage = require( 'view/ResistanceInAWireStageContainer' );\r\n  var ScreenView = require( 'JOIST/ScreenView' );\r\n  var inherit = require( 'PHET_CORE/inherit' );\r\n\r\n  function ResistanceInAWireView( model ) {\r\n    ScreenView.call( this, { renderer: 'svg' } );\r\n    this.addChild( new ResistanceInAWireStage( model ) );\r\n  }\r\n\r\n  inherit( ScreenView, ResistanceInAWireView );\r\n  return ResistanceInAWireView;\r\n\r\n} )\r\n;\r\n","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * Main entry point for the \"resistance in a wire\" sim.\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner)\r\n */\r\n\r\ndefine( 'resistance-in-a-wire-main',['require','JOIST/SimLauncher','JOIST/Sim','resistance-in-a-wire-strings','SCENERY/nodes/Rectangle','model/ResistanceInAWireModel','view/ResistanceInAWireView','imageLoader'],function( require ) {\r\n  'use strict';\r\n  var SimLauncher = require( 'JOIST/SimLauncher' ),\r\n    Sim = require( 'JOIST/Sim' ),\r\n    Strings = require( 'resistance-in-a-wire-strings' ),\r\n    Rectangle = require( 'SCENERY/nodes/Rectangle' ),\r\n    ResistanceInAWireModel = require( 'model/ResistanceInAWireModel' ),\r\n    ResistanceInAWireView = require( 'view/ResistanceInAWireView' ),\r\n    imageLoader = require( 'imageLoader' );\r\n\r\n  var simOptions = {\r\n    credits: 'PhET Development Team -\\n' +\r\n             'Lead Design: Michael Dubson\\n' +\r\n             'Software Development: Michael Dubson, John Blanco\\n' +\r\n             'Design Team: Ariel Paul\\n' +\r\n             'Interviews: Wendy Adams, Mindy Gratny\\n',\r\n    thanks: 'Thanks -\\n' +\r\n            'Thanks to Mobile Learner Labs for working with the PhET development team to convert this simulation to HTML5.'\r\n  };\r\n  SimLauncher.launch( imageLoader, function() {\r\n    //Create and start the sim\r\n    new Sim( Strings.simTitle, [\r\n      {\r\n        name: Strings.simTitle,\r\n        icon: new Rectangle( 0, 0, 50, 50, { fill: 'blue' } ),\r\n        createModel: function() { return new ResistanceInAWireModel(); },\r\n        createView: function( model ) { return new ResistanceInAWireView( model ); },\r\n        backgroundColor: \"#ffffdf\"\r\n      }\r\n    ], simOptions ).start();\r\n  } );\r\n} );\r\n","\n/**\r\n * Copyright 2002-2013, University of Colorado\r\n * RequireJS configuration file for Resistance in a Wire simulation.\r\n * @author Vasily Shakhov (Mlearner)\r\n * @author Anton Ulyanov (Mlearner\r\n */\r\n\r\n\r\nrequire.config( {\r\n  deps: [\"resistance-in-a-wire-main\"],\r\n\r\n  paths: {\r\n    // third-party libs\r\n    i18n: '../lib/i18n-2.0.2',\r\n\r\n    // PhET libs, uppercase names to identify them in require.js imports\r\n    ASSERT: '../../assert/js',\r\n    AXON: '../../axon/js',\r\n    DOT: '../../dot/js',\r\n    JOIST: '../../joist/js',\r\n    KITE: '../../kite/js',\r\n    NITROGLYCERIN: '../../nitroglycerin/js',\r\n    PHET_CORE: '../../phet-core/js',\r\n    PHETCOMMON: '../../phetcommon/js',\r\n    SCENERY: '../../scenery/js',\r\n    SCENERY_PHET: '../../scenery-phet/js',\r\n    SUN: '../../sun/js'\r\n\r\n  },\r\n\r\n  urlArgs: new Date().getTime()  // cache buster to make browser refresh load all included scripts\r\n\r\n} );\r\n\ndefine(\"resistance-in-a-wire-config\", function(){});\n"]}